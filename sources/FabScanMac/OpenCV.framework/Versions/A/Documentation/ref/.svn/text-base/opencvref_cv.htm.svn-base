<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html><head>
<link rel="STYLESHEET" href="opencvref.css" charset="ISO-8859-1" type="text/css">
<title>OpenCV: Image Processing and Computer Vision Reference Manual</title>
</head><body>

<h1>CV Reference Manual</h1>

<hr><p><ul>
<li><a href="#cv_imgproc">Image Processing</a>
<ul>
<li><a href="#cv_imgproc_features">Gradients, Edges, Corners and Features</a>
<li><a href="#cv_imgproc_resampling">Sampling, Interpolation and Geometrical Transforms</a>
<li><a href="#cv_imgproc_morphology">Morphological Operations</a>
<li><a href="#cv_imgproc_filters">Filters and Color Conversion</a>
<li><a href="#cv_imgproc_pyramids">Pyramids and the Applications</a>
<li><a href="#cv_imgproc_ccomp">Image Segmentation, Connected Components and Contour Retrieval</a>
<li><a href="#cv_imgproc_moments">Image and Contour Moments</a>
<li><a href="#cv_imgproc_special">Special Image Transforms</a>
<li><a href="#cv_imgproc_histograms">Histograms</a>
<li><a href="#cv_imgproc_matching">Matching</a>
</ul>
<li><a href="#cv_sa">Structural Analysis</a>
<ul>
<li><a href="#cv_sa_contours">Contour Processing</a>
<li><a href="#cv_sa_compgeom">Computational Geometry</a>
<li><a href="#cv_sa_subdiv">Planar Subdivisions</a>
</ul>
<li><a href="#cv_motion">Motion Analysis and Object Tracking</a>
<ul>
<li><a href="#cv_motion_acc">Accumulation of Background Statistics</a>
<li><a href="#cv_motion_motempl">Motion Templates</a>
<li><a href="#cv_motion_tracking">Object Tracking</a>
<li><a href="#cv_motion_optflow">Optical Flow</a>
<li><a href="#cv_motion_feature">Feature Matching</a>
<li><a href="#cv_motion_estimators">Estimators</a>
</ul>
<li><a href="#cv_pattern">Pattern Recognition</a>
<ul>
<li><a href="#cv_pattern_objdetection">Object Detection</a>
</ul>
<li><a href="#cv_3d">Camera Calibration and 3D Reconstruction</a>
<ul>
<li><a href="#cv_3d_calibration">Single and Stereo Camera Calibration</a>
<li><a href="#cv_3d_pose">Pose Estimation</a>
<li><a href="#cv_3d_epipolar">Epipolar Geometry, Stereo Correspondence</a>
</ul>
<li><a href="#cv_func_index">Alphabetical List of Functions</a>
<li><a href="#cv_bib">Bibliography</a>
</ul></p>

<hr><h1><a name="cv_imgproc">Image Processing</a></h1>

<p>
Note:<br>
The chapter describes functions for image processing and analysis.
Most of the functions work with 2d arrays of pixels. We refer the arrays
as "images" however they do not necessarily have to be IplImage&#146;s, they may
be CvMat&#146;s or CvMatND&#146;s as well.
</p>

<hr><h2><a name="cv_imgproc_features">Gradients, Edges, Corners and Features</a></h2>

<hr><h3><a name="decl_cvSobel">Sobel</a></h3>
<p class="Blurb">Calculates first, second, third or mixed image derivatives using extended Sobel operator</p>
<pre>
void cvSobel( const CvArr* src, CvArr* dst, int xorder, int yorder, int aperture_size=3 );
</pre><p><dl>
<dt>src<dd>Source image.
<dt>dst<dd>Destination image.
<dt>xorder<dd>Order of the derivative x .
<dt>yorder<dd>Order of the derivative y .
<dt>aperture_size<dd>Size of the extended Sobel kernel, must be 1, 3, 5 or 7.
In all cases except 1, aperture_size &times;aperture_size separable kernel will be used to calculate
the derivative. For <code>aperture_size</code>=1 3x1 or 1x3 kernel is used (Gaussian smoothing is not done).
There is also special value <code>CV_SCHARR</code> (=-1) that corresponds to 3x3 Scharr filter that may
give more accurate results than 3x3 Sobel. Scharr aperture is:
<pre>
| -3 0  3|
|-10 0 10|
| -3 0  3|
</pre>
for x-derivative or transposed for y-derivative.
</dl><p>
The function <code>cvSobel</code> calculates the image derivative by convolving the image
with the appropriate kernel:</p>
<pre>
dst(x,y) = d<sup>xorder+yorder</sup>src/dx<sup>xorder</sup>&bull;dy<sup>yorder</sup> |<sub>(x,y)</sub>
</pre>
The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less
robust to the noise. Most often, the function is called with (xorder=1, yorder=0, aperture_size=3) or
(xorder=0, yorder=1, aperture_size=3) to calculate first x- or y- image derivative.
The first case corresponds to</p>
<pre>
  |-1  0  1|
  |-2  0  2|
  |-1  0  1|
</pre>
<p>kernel and the second one corresponds to</p>
<pre>
  |-1 -2 -1|
  | 0  0  0|
  | 1  2  1|
or
  | 1  2  1|
  | 0  0  0|
  |-1 -2 -1|
</pre>
kernel, depending on the image origin (<code>origin</code> field of <code>IplImage</code> structure).
No scaling is done, so the destination image usually has larger by absolute value numbers than
the source image. To avoid overflow, the function requires 16-bit destination image if
the source image is 8-bit. The result can be converted back to 8-bit using <a href="#decl_cvConvertScale">cvConvertScale</a> or
<a href="opencvref_cxcore.htm#decl_cvConvertScaleAbs">cvConvertScaleAbs</a> functions. Besides 8-bit images the function
can process 32-bit floating-point images.
Both source and destination must be single-channel images of equal size or ROI size.
</p>


<hr><h3><a name="decl_cvLaplace">Laplace</a></h3>
<p class="Blurb">Calculates Laplacian of the image</p>
<pre>
void cvLaplace( const CvArr* src, CvArr* dst, int aperture_size=3 );
</pre><p><dl>
<dt>src<dd>Source image.
<dt>dst<dd>Destination image.
<dt>aperture_size<dd>Aperture size (it has the same meaning as in <a href="#decl_cvSobel">cvSobel</a>).
</dl><p>
The function <code>cvLaplace</code> calculates Laplacian of the source image by summing
second x- and y- derivatives calculated using Sobel operator:</p>
<pre>
dst(x,y) = d<sup>2</sup>src/dx<sup>2</sup> + d<sup>2</sup>src/dy<sup>2</sup>
</pre>
<p>
Specifying <code>aperture_size</code>=1 gives the fastest variant that is equal to
convolving the image with the following kernel:</p>
<pre>
|0  1  0|
|1 -4  1|
|0  1  0|
</pre><p>
Similar to <a href="#decl_cvSobel">cvSobel</a> function, no scaling is done and the same combinations of input and
output formats are supported.
</p>


<hr><h3><a name="decl_cvCanny">Canny</a></h3>
<p class="Blurb">Implements Canny algorithm for edge detection</p>
<pre>
void cvCanny( const CvArr* image, CvArr* edges, double threshold1,
              double threshold2, int aperture_size=3 );
</pre><p><dl>
<dt>image<dd>Input image.
<dt>edges<dd>Image to store the edges found by the function.
<dt>threshold1<dd>The first threshold.
<dt>threshold2<dd>The second threshold.
<dt>aperture_size<dd>Aperture parameter for Sobel operator (see <a href="#decl_cvSobel">cvSobel</a>).
</dl><p>
The function <code>cvCanny</code> finds the edges on the input image <code>image</code> and marks them in the
output image <code>edges</code> using the Canny algorithm. The smallest of <code>threshold1</code> and
<code>threshold2</code> is used for edge linking, the largest - to find initial segments of strong edges.</p>


<hr><h3><a name="decl_cvPreCornerDetect">PreCornerDetect</a></h3>
<p class="Blurb">Calculates feature map for corner detection</p>
<pre>
void cvPreCornerDetect( const CvArr* image, CvArr* corners, int aperture_size=3 );
</pre><p><dl>
<dt>image<dd>Input image.
<dt>corners<dd>Image to store the corner candidates.
<dt>aperture_size<dd>Aperture parameter for Sobel operator (see <a href="#decl_cvSobel">cvSobel</a>).
</dl><p>
The function <code>cvPreCornerDetect</code> calculates the function
D<sub>x</sub><sup>2</sup>D<sub>yy</sub>+D<sub>y</sub><sup>2</sup>D<sub>xx</sub> - 2D<sub>x</sub>D<sub>y</sub>D<sub>xy</sub>
where D<sub>?</sub> denotes one of the first image derivatives and D<sub>??</sub> denotes a second image
derivative. The corners can be found as local maximums of the function:</p>
<pre>
// assume that the image is floating-point
IplImage* corners = cvCloneImage(image);
IplImage* dilated_corners = cvCloneImage(image);
IplImage* corner_mask = cvCreateImage( cvGetSize(image), 8, 1 );
cvPreCornerDetect( image, corners, 3 );
cvDilate( corners, dilated_corners, 0, 1 );
cvSubS( corners, dilated_corners, corners );
cvCmpS( corners, 0, corner_mask, CV_CMP_GE );
cvReleaseImage( &amp;corners );
cvReleaseImage( &amp;dilated_corners );
</pre>

<hr><h3><a name="decl_cvCornerEigenValsAndVecs">CornerEigenValsAndVecs</a></h3>
<p class="Blurb">Calculates eigenvalues and eigenvectors of image blocks for corner detection</p>
<pre>
void cvCornerEigenValsAndVecs( const CvArr* image, CvArr* eigenvv,
                               int block_size, int aperture_size=3 );
</pre><p><dl>
<dt>image<dd>Input image.
<dt>eigenvv<dd>Image to store the results. It must be 6 times wider than the input image.
<dt>block_size<dd>Neighborhood size (see discussion).
<dt>aperture_size<dd>Aperture parameter for Sobel operator (see <a href="#decl_cvSobel">cvSobel</a>).
</dl><p>
For every pixel The function <code>cvCornerEigenValsAndVecs</code> considers
<code>block_size</code> &times; <code>block_size</code> neighborhood S(p). It calculates
covariation matrix of derivatives over the neighborhood as:</p>
<pre>
    | sum<sub>S(p)</sub>(dI/dx)<sup>2</sup>   sum<sub>S(p)</sub>(dI/dx&bull;dI/dy)|
M = |                                 |
    | sum<sub>S(p)</sub>(dI/dx&bull;dI/dy)  sum<sub>S(p)</sub>(dI/dy)<sup>2</sup> |
</pre><p>
After that it finds eigenvectors and eigenvalues of the matrix and stores
them into destination image in form
(&lambda;<sub>1</sub>, &lambda;<sub>2</sub>, x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>),
where<br>
&lambda;<sub>1</sub>, &lambda;<sub>2</sub> - eigenvalues of <code>M</code>; not sorted<br>
(x<sub>1</sub>, y<sub>1</sub>) - eigenvector corresponding to &lambda;<sub>1</sub><br>
(x<sub>2</sub>, y<sub>2</sub>) - eigenvector corresponding to &lambda;<sub>2</sub><br>
</p>


<hr><h3><a name="decl_cvCornerMinEigenVal">CornerMinEigenVal</a></h3>
<p class="Blurb">Calculates minimal eigenvalue of gradient matrices for corner detection</p>
<pre>
void cvCornerMinEigenVal( const CvArr* image, CvArr* eigenval, int block_size, int aperture_size=3 );
</pre><p><dl>
<dt>image<dd>Input image.
<dt>eigenval<dd>Image to store the minimal eigenvalues. Should have the same size as <code>image</code>
<dt>block_size<dd>Neighborhood size (see discussion of <a href="#decl_cvCornerEigenValsAndVecs">cvCornerEigenValsAndVecs</a>).
<dt>aperture_size<dd>Aperture parameter for Sobel operator (see <a href="#decl_cvSobel">cvSobel</a>).
format. In the case of floating-point input format this parameter is the number
of the fixed float filter used for differencing.
</dl><p>
The function <code>cvCornerMinEigenVal</code> is similar to <a href="#decl_cvCornerEigenValsAndVecs">cvCornerEigenValsAndVecs</a> but
it calculates and stores only the minimal eigenvalue of derivative covariation matrix for every pixel,
i.e. min(&lambda;<sub>1</sub>, &lambda;<sub>2</sub>) in terms of the previous function.
</p>


<hr><h3><a name="decl_cvCornerHarris">CornerHarris</a></h3>
<p class="Blurb">Harris edge detector</p>
<pre>
void cvCornerHarris( const CvArr* image, CvArr* harris_dst,
                     int block_size, int aperture_size=3, double k=0.04 );
</pre><p><dl>
<dt>image<dd>Input image.
<dt>harris_dst<dd>Image to store the Harris detector responses. Should have the same size as <code>image</code>
<dt>block_size<dd>Neighborhood size (see discussion of <a href="#decl_cvCornerEigenValsAndVecs">cvCornerEigenValsAndVecs</a>).
<dt>aperture_size<dd>Aperture parameter for Sobel operator (see <a href="#decl_cvSobel">cvSobel</a>).
format. In the case of floating-point input format this parameter is the number
of the fixed float filter used for differencing.
<dt>k<dd>Harris detector free parameter. See the formula below.
</dl><p>
The function <code>cvCornerHarris</code> finds feature points (corners) in the image
using Harris' method. Similarly to
<a href="#decl_cvCornerMinEigenVal">cvCornerMinEigenVal</a> and
<a href="#decl_cvCornerEigenValsAndVecs">cvCornerEigenValsAndVecs</a>,
for each pixel it calculates 2x2 gradient covariation matrix
<code>M</code> over <code>block_size&times;block_size</code> neighborhood.
Then, it stores</p>
<pre>det(M) - k*trace(M)<sup>2</sup></pre>
to the corresponding pixel of the destination image.
The corners can be found as local maxima in the destination image.
</p>


<hr><h3><a name="decl_cvFindCornerSubPix">FindCornerSubPix</a></h3>
<p class="Blurb">Refines corner locations</p>
<pre>
void cvFindCornerSubPix( const CvArr* image, CvPoint2D32f* corners,
                         int count, CvSize win, CvSize zero_zone,
                         CvTermCriteria criteria );
</pre><p><dl>
<dt>image<dd>Input image.
<dt>corners<dd>Initial coordinates of the input corners and refined coordinates on
output.
<dt>count<dd>Number of corners.
<dt>win<dd>Half sizes of the search window. For example, if <code>win</code>=(5,5) then
5*2+1 &times; 5*2+1 = 11 &times; 11 search window is used.
<dt>zero_zone<dd>Half size of the dead region in the middle of the search zone over which the
summation in formulae below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix.
The value of (-1,-1) indicates that there is no such size.
<dt>criteria<dd>Criteria for termination of the iterative process of corner refinement.
That is, the process of corner position refinement stops either after certain number of iteration or
when a required accuracy is achieved. The <code>criteria</code> may specify either of or both the maximum
number of iteration and the required accuracy.
</dl><p>
The function <code>cvFindCornerSubPix</code> iterates to find the sub-pixel accurate location
of corners, or radial saddle points, as shown in on the picture below.</p>
<p>
<image align="center" src="pics/cornersubpix.png">
</p>
<p>
Sub-pixel accurate corner locator is based on the observation that every vector
from the center <code>q</code> to a point <code>p</code> located within a neighborhood of <code>q</code> is orthogonal
to the image gradient at <code>p</code> subject to image and measurement noise. Consider the expression:
</p>
<pre>
&epsilon;<sub>i</sub>=DI<sub>p<sub>i</sub></sub><sup>T</sup>&bull;(q-p<sub>i</sub>)
</pre>
where <code>DI<sub>p<sub>i</sub></sub></code> is the image gradient
at the one of the points <code>p<sub>i</sub></code> in a neighborhood of <code>q</code>.
The value of <code>q</code> is to be found such that <code>&epsilon;<sub>i</sub></code> is minimized.
A system of equations may be set up with <code>&epsilon;<sub>i</sub></code>' set to zero:</p>
<pre>
sum<sub>i</sub>(DI<sub>p<sub>i</sub></sub>&bull;DI<sub>p<sub>i</sub></sub><sup>T</sup>)&bull;q - sum<sub>i</sub>(DI<sub>p<sub>i</sub></sub>&bull;DI<sub>p<sub>i</sub></sub><sup>T</sup>&bull;p<sub>i</sub>) = 0
</pre>
<p>where the gradients are summed within a neighborhood ("search window") of <code>q</code>.
Calling the first gradient term <code>G</code> and the second gradient term <code>b</code> gives:</p>
<pre>
q=G<sup>-1</sup>&bull;b
</pre>
<p>
The algorithm sets the center of the neighborhood window at this new center <code>q</code>
and then iterates until the center keeps within a set threshold.
</p>


<hr><h3><a name="decl_cvGoodFeaturesToTrack">GoodFeaturesToTrack</a></h3>
<p class="Blurb">Determines strong corners on image</p>
<pre>
void cvGoodFeaturesToTrack( const CvArr* image, CvArr* eig_image, CvArr* temp_image,
                            CvPoint2D32f* corners, int* corner_count,
                            double quality_level, double min_distance,
                            const CvArr* mask=NULL, int block_size=3,
                            int use_harris=0, double k=0.04 );
</pre><p><dl>
<dt>image<dd>The source 8-bit or floating-point 32-bit, single-channel image.
<dt>eig_image<dd>Temporary floating-point 32-bit image of the same size as <code>image</code>.
<dt>temp_image<dd>Another temporary image of the same size and same format as <code>eig_image</code>.
<dt>corners<dd>Output parameter. Detected corners.
<dt>corner_count<dd>Output parameter. Number of detected corners.
<dt>quality_level<dd>Multiplier for the maxmin eigenvalue; specifies minimal accepted
quality of image corners.
<dt>min_distance<dd>Limit, specifying minimum possible distance between returned
corners; Euclidean distance is used.
<dt>mask<dd>Region of interest. The function selects points either in the specified region
or in the whole image if the mask is NULL.
<dt>block_size<dd>Size of the averaging block, passed to underlying
           <a href="#decl_cvCornerMinEigenVal">cvCornerMinEigenVal</a> or
           <a href="#decl_cvCornerHarris">cvCornerHarris</a> used by the function.
<dt>use_harris<dd>If nonzero, Harris operator (<a href="#decl_cvCornerHarris">cvCornerHarris</a>)
                  is used instead of default <a href="#decl_cvCornerMinEigenVal">cvCornerMinEigenVal</a>.
<dt>k<dd>Free parameter of Harris detector; used only if <code>use_harris&ne;0</code>
</dl><p>
The function <code>cvGoodFeaturesToTrack</code> finds corners with big eigenvalues in the
image. The function first calculates the minimal eigenvalue for every source image pixel
using <a href="#decl_cvCornerMinEigenVal">cvCornerMinEigenVal</a> function and stores them in <code>eig_image</code>.
Then it performs non-maxima suppression (only local maxima in 3x3 neighborhood remain).
The next step is rejecting the corners with the
minimal eigenvalue less than <code>quality_level</code>&bull;max(<code>eig_image</code>(x,y)). Finally,
the function ensures that all the corners found are distanced enough one from
another by considering the corners (the most strongest corners are considered first)
and checking that the distance between the newly considered feature and the features considered earlier
is larger than <code>min_distance</code>. So, the function removes the features than are too close
to the stronger features.</p>


<hr><h3><a name="decl_cvExtractSURF">ExtractSURF</a></h3>
<p class="Blurb">Extracts Speeded Up Robust Features from image</p>
<pre>
void cvExtractSURF( const CvArr* image, const CvArr* mask,
                    CvSeq** keypoints, CvSeq** descriptors,
                    CvMemStorage* storage, CvSURFParams params );
</pre><p><dl>
<dt>image<dd>The input 8-bit grayscale image.
<dt>mask<dd>The optional input 8-bit mask. The features are only found in the areas
   that contain more than 50% of non-zero mask pixels.
<dt>keypoints<dd>The output parameter; double pointer to the sequence of keypoints.
 This will be the sequence of <code>CvSURFPoint</code> structures:
 <pre>
 typedef struct CvSURFPoint
 {
    CvPoint2D32f pt; // position of the feature within the image
    int laplacian;   // -1, 0 or +1. sign of the laplacian at the point.
                     // can be used to speedup feature comparison
                     // (normally features with laplacians of different signs can not match)
    int size;        // size of the feature
    float dir;       // orientation of the feature: 0..360 degrees
    float hessian;   // value of the hessian (can be used to approximately estimate the feature strengths;
                     // see also params.hessianThreshold)
 }
 CvSURFPoint;
 </pre>
<dt>descriptors<dd>The optional output parameter; double pointer to the sequence of descriptors;
   Depending on the <code>params.extended</code> value, each element of the sequence
   will be either 64-element or 128-element floating-point (CV_32F) vector.
   If the parameter is NULL, the descriptors are not computed.
<dt>storage<dd>Memory storage where keypoints and descriptors will be stored.
<dt>params<dd>Various algorithm parameters put to the structure <code>CvSURFParams</code>:
 <pre>
 typedef struct CvSURFParams
 {
    int extended; // 0 means basic descriptors (64 elements each),
                  // 1 means extended descriptors (128 elements each)
    double hessianThreshold; // only features with keypoint.hessian larger than that are extracted.
                  // good default value is ~300-500 (can depend on the average
                  // local contrast and sharpness of the image).
                  // user can further filter out some features based on their hessian values
                  // and other characteristics
    int nOctaves; // the number of octaves to be used for extraction.
                  // With each next octave the feature size is doubled (3 by default)
    int nOctaveLayers; // The number of layers within each octave (4 by default)
 }
 CvSURFParams;

 CvSURFParams cvSURFParams(double hessianThreshold, int extended=0); // returns default parameters
 </pre>
</dl><p>
The function <code>cvExtractSURF</code> finds robust features in the image, as described in
<a href="#paper_bay06">[Bay06]</a>. For each feature it returns its location, size, orientation
and optionally the descriptor, basic or extended. The function can be used for object tracking
and localization, image stitching etc. See find_obj.cpp demo in OpenCV samples directory.
</p>


<hr><h3><a name="decl_cvGetStarKeypoints">GetStarKeypoints</a></h3>
<p class="Blurb">Retrieves keypoints using StarDetector algorithm</p>
<pre>
CvSeq* cvGetStarKeypoints( const CvArr* image, CvMemStorage* storage,
                           CvStarDetectorParams params=cvStarDetectorParams() );
</pre><p><dl>
<dt>image<dd>The input 8-bit grayscale image.
<dt>storage<dd>Memory storage where the keypoints will be stored.
<dt>params<dd>Various algorithm parameters put to the structure <code>CvStarDetectorParams</code>:
 <pre>
 typedef struct CvStarDetectorParams
 {
    int maxSize; // maximal size of the features detected. The following values
                 // of the parameter are supported:
                 // 4, 6, 8, 11, 12, 16, 22, 23, 32, 45, 46, 64, 90, 128
    int responseThreshold; // threshold for the approximatd laplacian,
                           // used to eliminate weak features
    int lineThresholdProjected; // another threshold for laplacian to eliminate edges
    int lineThresholdBinarized; // another threshold for the feature scale to eliminate edges
    int suppressNonmaxSize; // linear size of a pixel neighborhood for non-maxima suppression
 }
 CvStarDetectorParams;

 inline CvStarDetectorParams cvStarDetectorParams(int maxSize=45,
    int responseThreshold=30, int lineThresholdProjected=10,
    int lineThresholdBinarized=8, int suppressNonmaxSize=5);
 </pre>
</dl><p>
The function <code>cvGetStarKeypoints</code> extracts keypoints that are local scale-space
extremas. The scale-space is constructed by computing approximate values of laplacians
with different sigma's at each pixel. Instead of using pyramids, a popular approach
to save computing time, all the laplacians are computed at each pixel of the original
high-resolution image. But each approximate laplacian value is computed in O(1)
time regardless of the sigma, thanks to the use of integral images. The algorithm is based on the
paper <a href="#paper_agrawal08">[Agrawal08]</a>, but instead of square, hexagon or octagon
it uses 8-end star shape, hence the name, consisting of overlapping upright and tilted squares.
</p>
<p>Each computed feature is represented by the following structure:</p>
<pre>
typedef struct CvStarKeypoint
{
    CvPoint pt; // coordinates of the feature
    int size; // feature size, see CvStarDetectorParams::maxSize
    float response; // the approximated laplacian value at that point.
}
CvStarKeypoint;

inline CvStarKeypoint cvStarKeypoint(CvPoint pt, int size, float response);
</pre>
<p>Below is the small usage sample:</p>
<pre>
#include "cv.h"
#include "highgui.h"

int main(int argc, char** argv)
{
    const char* filename = argc > 1 ? argv[1] : "lena.jpg";
    IplImage* img = cvLoadImage( filename, 0 ), *cimg;
    CvMemStorage* storage = cvCreateMemStorage(0);
    CvSeq* keypoints = 0;
    int i;

    if( !img )
        return 0;
    cvNamedWindow( "image", 1 );
    cvShowImage( "image", img );
    cvNamedWindow( "features", 1 );
    cimg = cvCreateImage( cvGetSize(img), 8, 3 );
    cvCvtColor( img, cimg, CV_GRAY2BGR );

    keypoints = cvGetStarKeypoints( img, storage, cvStarDetectorParams(45) );

    for( i = 0; i < (keypoints ? keypoints->total : 0); i++ )
    {
        CvStarKeypoint kpt = *(CvStarKeypoint*)cvGetSeqElem(keypoints, i);
        int r = kpt.size/2;
        cvCircle( cimg, kpt.pt, r, CV_RGB(0,255,0));
        cvLine( cimg, cvPoint(kpt.pt.x + r, kpt.pt.y + r),
            cvPoint(kpt.pt.x - r, kpt.pt.y - r), CV_RGB(0,255,0));
        cvLine( cimg, cvPoint(kpt.pt.x - r, kpt.pt.y + r),
            cvPoint(kpt.pt.x + r, kpt.pt.y - r), CV_RGB(0,255,0));
    }
    cvShowImage( "features", cimg );
    cvWaitKey();
}
</pre>

<hr><h2><a name="cv_imgproc_resampling">Sampling, Interpolation and Geometrical Transforms</a></h2>

<hr><h3><a name="decl_cvSampleLine">SampleLine</a></h3>
<p class="Blurb">Reads raster line to buffer</p>
<pre>
int cvSampleLine( const CvArr* image, CvPoint pt1, CvPoint pt2,
                  void* buffer, int connectivity=8 );
</pre><p><dl>
<dt>image<dd>Image to sample the line from.
<dt>pt1<dd>Starting the line point.
<dt>pt2<dd>Ending the line point.
<dt>buffer<dd>Buffer to store the line points; must have enough size to store
max( |<code>pt2.x</code>-<code>pt1.x</code>|+1, |<code>pt2.y</code>-<code>pt1.y</code>|+1 )</code> points in case
of 8-connected line and |<code>pt2.x</code>-<code>pt1.x</code>|+|<code>pt2.y</code>-<code>pt1.y</code>|+1 in case
of 4-connected line.
<dt>connectivity<dd>The line connectivity, 4 or 8.
</dl><p>
The function <code>cvSampleLine</code> implements a particular case of application of line
iterators. The function reads all the image points lying on the line between <code>pt1</code>
and <code>pt2</code>, including the ending points, and stores them into the buffer.</p>


<hr><h3><a name="decl_cvGetRectSubPix">GetRectSubPix</a></h3>
<p class="Blurb">Retrieves pixel rectangle from image with sub-pixel accuracy</p>
<pre>
void cvGetRectSubPix( const CvArr* src, CvArr* dst, CvPoint2D32f center );
</pre><p><dl>
<dt>src<dd>Source image.
<dt>dst<dd>Extracted rectangle.
<dt>center<dd>Floating point coordinates of the extracted rectangle center within the source image.
The center must be inside the image.
</dl><p>
The function <code>cvGetRectSubPix</code> extracts pixels from <code>src</code>:</p>
<pre>
dst(x, y) = src(x + center.x - (width(dst)-1)*0.5, y + center.y - (height(dst)-1)*0.5)
</pre>
<p>
where the values of pixels at non-integer coordinates are
retrieved using bilinear interpolation. Every channel of multiple-channel images is processed
independently.
Whereas the rectangle center must be inside the image, the whole rectangle may be partially occluded.
In this case, the replication border mode is used to get pixel values beyond the image boundaries.
</p>


<hr><h3><a name="decl_cvGetQuadrangleSubPix">GetQuadrangleSubPix</a></h3>
<p class="Blurb">Retrieves pixel quadrangle from image with sub-pixel accuracy</p>
<pre>
void cvGetQuadrangleSubPix( const CvArr* src, CvArr* dst, const CvMat* map_matrix );
</pre><p><dl>
<dt>src<dd>Source image.
<dt>dst<dd>Extracted quadrangle.
<dt>map_matrix<dd>The transformation 2 &times; 3 matrix [<code>A</code>|<code>b</code>] (see the discussion).
</dl><p>
The function <code>cvGetQuadrangleSubPix</code> extracts pixels from <code>src</code> at sub-pixel accuracy
and stores them to <code>dst</code> as follows:</p>
<pre>
dst(x, y)= src( A<sub>11</sub>x'+A<sub>12</sub>y'+b<sub>1</sub>, A<sub>21</sub>x'+A<sub>22</sub>y'+b<sub>2</sub>),

where <code>A</code> and <code>b</code> are taken from <code>map_matrix</code>
             | A<sub>11</sub> A<sub>12</sub>  b<sub>1</sub> |
map_matrix = |            |
             | A<sub>21</sub> A<sub>22</sub>  b<sub>2</sub> |,

x'=x-(width(dst)-1)*0.5, y'=y-(height(dst)-1)*0.5
</pre>
<p>
where the values of pixels at non-integer coordinates A&bull;(x,y)<sup>T</sup>+b are
retrieved using bilinear interpolation. When the function needs pixels outside of the image, it uses replication
border mode to reconstruct the values. Every channel of multiple-channel images is processed
independently.</p>


<hr><h3><a name="decl_cvResize">Resize</a></h3>
<p class="Blurb">Resizes image</p>
<pre>
void cvResize( const CvArr* src, CvArr* dst, int interpolation=CV_INTER_LINEAR );
</pre><p><dl>
<dt>src<dd>Source image.
<dt>dst<dd>Destination image.
<dt>interpolation<dd>Interpolation method:<ul>
    <li>CV_INTER_NN - nearest-neighbor interpolation,
    <li>CV_INTER_LINEAR - bilinear interpolation (used by default)
    <li>CV_INTER_AREA - resampling using pixel area relation. It is the preferred method for image
    decimation that gives moire-free results.
    In case of zooming it is similar to <code>CV_INTER_NN</code> method.
    <li>CV_INTER_CUBIC - bicubic interpolation.
    </ul>
</dl><p>
The function <code>cvResize</code> resizes image <code>src</code> (or its ROI)
so that it fits exactly to <code>dst</code> (or its ROI).</p>

<hr><h3><a name="decl_cvWarpAffine">WarpAffine</a></h3>
<p class="Blurb">Applies affine transformation to the image</p>
<pre>
void cvWarpAffine( const CvArr* src, CvArr* dst, const CvMat* map_matrix,
                   int flags=CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS,
                   CvScalar fillval=cvScalarAll(0) );
</pre><p><dl>
<dt>src<dd>Source image.
<dt>dst<dd>Destination image.
<dt>map_matrix<dd>2&times;3 transformation matrix.
<dt>flags<dd>A combination of interpolation method and the following optional flags:<ul>
    <li>CV_WARP_FILL_OUTLIERS - fill all the destination image pixels. If some of them correspond to
            outliers in the source image, they are set to <code>fillval</code>.
    <li>CV_WARP_INVERSE_MAP - indicates that <code>matrix</code> is inverse transform from destination image
                            to source and, thus, can be used directly for pixel interpolation. Otherwise,
                            the function finds the inverse transform from <code>map_matrix</code>.
    </ul>
<dt>fillval<dd>A value used to fill outliers.
</dl><p>
The function <code>cvWarpAffine</code> transforms source image using the specified
matrix:</p>
<pre>
dst(x&#146;,y&#146;)&lt;-src(x,y)
(x&#146;,y&#146;)<sup>T</sup>=map_matrix&bull;(x,y,1)<sup>T</sup>+b if CV_WARP_INVERSE_MAP is not set,
(x, y)<sup>T</sup>=map_matrix&bull;(x&#146;,y&apos,1)<sup>T</sup>+b otherwise
</pre>
<p>
The function is similar to <a href="#decl_cvGetQuadrangleSubPix">cvGetQuadrangleSubPix</a> but they are
not exactly the same. <a href="#decl_cvWarpAffine">cvWarpAffine</a> requires input and output
image have the same data type, has larger overhead (so it is not quite suitable for small images)
and can leave part of destination image unchanged. While <a href="#decl_cvGetQuadrangleSubPix">cvGetQuadrangleSubPix</a>
may extract quadrangles from 8-bit images into floating-point buffer, has smaller overhead and
always changes the whole destination image content.
</p>
<p>
To transform a sparse set of points, use <a href="#decl_cvTransform">cvTransform</a>
function from cxcore.</p>

<hr><h3><a name="decl_cvGetAffineTransform">GetAffineTransform</a></h3>
<p class="Blurb">Calculates affine transform from 3 corresponding points</p>
<pre>
CvMat* cvGetAffineTransform( const CvPoint2D32f* src, const CvPoint2D32f* dst, 
                             CvMat* map_matrix );
</pre><p><dl>
<dt>src<dd>Coordinates of 3 triangle vertices in the source image.
<dt>dst<dd>Coordinates of the 3 corresponding triangle vertices in the destination image.
<dt>map_matrix<dd>Pointer to the destination 2&times;3 matrix.
</dl><p>
The function <code>cvGetAffineTransform</code> calculates the
matrix of an affine transform such that:</p>
<pre>
(x'<sub>i</sub>,y'<sub>i</sub>)<sup>T</sup>=map_matrix&bull;(x<sub>i</sub>,y<sub>i</sub>,1)<sup>T</sup>
</pre>
<p>where <code>dst(i)=(x'<sub>i</sub>,y'<sub>i</sub>), src(i)=(x<sub>i</sub>,y<sub>i</sub>), i=0..2</code>.</p>

<hr><h3><a name="decl_cv2DRotationMatrix">2DRotationMatrix</a></h3>
<p class="Blurb">Calculates affine matrix of 2d rotation</p>
<pre>
CvMat* cv2DRotationMatrix( CvPoint2D32f center, double angle,
                           double scale, CvMat* map_matrix );
</pre><p><dl>
<dt>center<dd>Center of the rotation in the source image.
<dt>angle<dd>The rotation angle in degrees. Positive values mean counter-clockwise rotation
(the coordinate origin is assumed at top-left corner).
<dt>scale<dd>Isotropic scale factor.
<dt>map_matrix<dd>Pointer to the destination 2&times;3 matrix.
</dl><p>
The function <code>cv2DRotationMatrix</code> calculates matrix:</p>
<pre>
[  &alpha;  &beta;  |  (1-&alpha;)*center.x - &beta;*center.y ]
[ -&beta;  &alpha;  |  &beta;*center.x + (1-&alpha;)*center.y ]

where &alpha;=scale*cos(angle), &beta;=scale*sin(angle)
</pre>
<p>The transformation maps the rotation center to itself. If this is not the purpose,
the shift should be adjusted.</p>


<hr><h3><a name="decl_cvWarpPerspective">WarpPerspective</a></h3>
<p class="Blurb">Applies perspective transformation to the image</p>
<pre>
void cvWarpPerspective( const CvArr* src, CvArr* dst, const CvMat* map_matrix,
                        int flags=CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS,
                        CvScalar fillval=cvScalarAll(0) );
</pre><p><dl>
<dt>src<dd>Source image.
<dt>dst<dd>Destination image.
<dt>map_matrix<dd>3&times;3 transformation matrix.
<dt>flags<dd>A combination of interpolation method and the following optional flags:<ul>
    <li>CV_WARP_FILL_OUTLIERS - fill all the destination image pixels. If some of them correspond to
                                outliers in the source image, they are set to <code>fillval</code>.
    <li>CV_WARP_INVERSE_MAP - indicates that <code>matrix</code> is inverse transform from destination image
                            to source and, thus, can be used directly for pixel interpolation. Otherwise,
                            the function finds the inverse transform from <code>map_matrix</code>.
    </ul>
<dt>fillval<dd>A value used to fill outliers.
</dl><p>
The function <code>cvWarpPerspective</code> transforms source image using
the specified matrix:</p>
<pre>
dst(x&#146;,y&#146;)&lt;-src(x,y)
(t&bull;x&#146;,t&bull;y&#146;,t)<sup>T</sup>=map_matrix&bull;(x,y,1)<sup>T</sup>+b if CV_WARP_INVERSE_MAP is not set,
(t&bull;x, t&bull;y, t)<sup>T</sup>=map_matrix&bull;(x&#146;,y&apos,1)<sup>T</sup>+b otherwise
</pre>
<p>
For a sparse set of points
use <a href="#decl_cvPerspectiveTransform">cvPerspectiveTransform</a> function from cxcore.</p>


<hr><h3><a name="decl_cvGetPerspectiveTransform">GetPerspectiveTransform</a></h3>
<p class="Blurb">Calculates perspective transform from 4 corresponding points</p>
<pre>
CvMat* cvGetPerspectiveTransform( const CvPoint2D32f* src, const CvPoint2D32f* dst,
                                  CvMat* map_matrix );

#define cvWarpPerspectiveQMatrix cvGetPerspectiveTransform
</pre><p><dl>
<dt>src<dd>Coordinates of 4 quadrangle vertices in the source image.
<dt>dst<dd>Coordinates of the 4 corresponding quadrangle vertices in the destination image.
<dt>map_matrix<dd>Pointer to the destination 3&times;3 matrix.
</dl><p>
The function <code>cvGetPerspectiveTransform</code> calculates
matrix of perspective transform such that:</p>
<pre>
(t<sub>i</sub>&bull;x'<sub>i</sub>,t<sub>i</sub>&bull;y'<sub>i</sub>,t<sub>i</sub>)<sup>T</sup>=map_matrix&bull;(x<sub>i</sub>,y<sub>i</sub>,1)<sup>T</sup>
</pre>
<p>where <code>dst(i)=(x'<sub>i</sub>,y'<sub>i</sub>), src(i)=(x<sub>i</sub>,y<sub>i</sub>), i=0..3</code>.</p>


<hr><h3><a name="decl_cvRemap">Remap</a></h3>
<p class="Blurb">Applies generic geometrical transformation to the image</p>
<pre>
void cvRemap( const CvArr* src, CvArr* dst,
              const CvArr* mapx, const CvArr* mapy,
              int flags=CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS,
              CvScalar fillval=cvScalarAll(0) );
</pre><p><dl>
<dt>src<dd>Source image.
<dt>dst<dd>Destination image.
<dt>mapx<dd>The map of x-coordinates (32FC1 image).
<dt>mapy<dd>The map of y-coordinates (32FC1 image).
<dt>flags<dd>A combination of interpolation method and the following optional flag(s):<ul>
    <li>CV_WARP_FILL_OUTLIERS - fill all the destination image pixels. If some of them correspond to
                                outliers in the source image, they are set to <code>fillval</code>.
    </ul>
<dt>fillval<dd>A value used to fill outliers.
</dl><p>
The function <code>cvRemap</code> transforms source image using
the specified map:</p>
<pre>
dst(x,y)&lt;-src(mapx(x,y),mapy(x,y))
</pre>
<p>Similar to other geometrical transformations, some interpolation method (specified by user)
is used to extract pixels with non-integer coordinates.
</p>


<hr><h3><a name="decl_cvLogPolar">LogPolar</a></h3>
<p class="Blurb">Remaps image to log-polar space</p>
<pre>
void cvLogPolar( const CvArr* src, CvArr* dst,
                 CvPoint2D32f center, double M,
                 int flags=CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS );
</pre><p><dl>
<dt>src<dd>Source image.
<dt>dst<dd>Destination image.
<dt>center<dd>The transformation center, where the output precision is maximal.
<dt>M<dd>Magnitude scale parameter. See below.
<dt>flags<dd>A combination of interpolation method and the following optional flags:<ul>
    <li>CV_WARP_FILL_OUTLIERS - fill all the destination image pixels. If some of them correspond to
                                outliers in the source image, they are set to zeros.
    <li>CV_WARP_INVERSE_MAP - indicates that <code>matrix</code> is inverse transform from destination image
                            to source and, thus, can be used directly for pixel interpolation. Otherwise,
                            the function finds the inverse transform from <code>map_matrix</code>.
    </ul>
<dt>fillval<dd>A value used to fill outliers.
</dl><p>
The function <code>cvLogPolar</code> transforms source image using
the following transformation:</p>
<pre>
Forward transformation (<code>CV_WARP_INVERSE_MAP</code> is not set):
dst(phi,rho)&lt;-src(x,y)

Inverse transformation (<code>CV_WARP_INVERSE_MAP</code> is set):
dst(x,y)&lt;-src(phi,rho),

where rho=M*log(sqrt(x<sup>2</sup>+y<sup>2</sup>))
      phi=atan(y/x)
</pre>
<p>The function emulates the human "foveal" vision and can be used for fast scale and rotation-invariant
template matching, for object tracking etc.</p>

<h4>Example. Log-polar transformation.</h4>
<pre>
#include &lt;cv.h&gt;
#include &lt;highgui.h&gt;

int main(int argc, char** argv)
{
    IplImage* src;

    if( argc == 2 && (src=cvLoadImage(argv[1],1) != 0 )
    {
        IplImage* dst = cvCreateImage( cvSize(256,256), 8, 3 );
        IplImage* src2 = cvCreateImage( cvGetSize(src), 8, 3 );
        cvLogPolar( src, dst, cvPoint2D32f(src->width/2,src->height/2), 40, CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS );
        cvLogPolar( dst, src2, cvPoint2D32f(src->width/2,src->height/2), 40, CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS+CV_WARP_INVERSE_MAP );
        cvNamedWindow( "log-polar", 1 );
        cvShowImage( "log-polar", dst );
        cvNamedWindow( "inverse log-polar", 1 );
        cvShowImage( "inverse log-polar", src2 );
        cvWaitKey();
    }
    return 0;
}
</pre>

<p>And this is what the program displays when opencv/samples/c/fruits.jpg is passed to it</p>
<p>
<img align="center" src="pics/logpolar.jpg" width=256 height=256>
<img align="center" src="pics/inv_logpolar.jpg" width=256 height=256>
</p>


<hr><h2><a name="cv_imgproc_morphology">Morphological Operations</a></h2>

<hr><h3><a name="decl_cvCreateStructuringElementEx">CreateStructuringElementEx</a></h3>
<p class="Blurb">Creates structuring element</p>
<pre>
IplConvKernel* cvCreateStructuringElementEx( int cols, int rows, int anchor_x, int anchor_y,
                                             int shape, int* values=NULL );
</pre><p><dl>
<dt>cols<dd>Number of columns in the structuring element.
<dt>rows<dd>Number of rows in the structuring element.
<dt>anchor_x<dd>Relative horizontal offset of the anchor point.
<dt>anchor_y<dd>Relative vertical offset of the anchor point.
<dt>shape<dd>Shape of the structuring element; may have the following values:
<ul>
<li><code>CV_SHAPE_RECT</code>, a rectangular element;
<li><code>CV_SHAPE_CROSS</code>, a cross-shaped element;
<li><code>CV_SHAPE_ELLIPSE</code>, an elliptic element;
<li><code>CV_SHAPE_CUSTOM</code>, a user-defined element. In this case the parameter <code>values</code>
specifies the mask, that is, which neighbors of the pixel must be considered.
</ul>
<dt>values<dd> Pointer to the structuring element data, a plane array, representing
row-by-row scanning of the element matrix. Non-zero values indicate points that
belong to the element. If the pointer is <code>NULL</code>, then all values are considered
non-zero, that is, the element is of a rectangular shape. This parameter is
considered only if the shape is <code>CV_SHAPE_CUSTOM</code>  .
</dl><p>
The function <a href="#decl_cv CreateStructuringElementEx">cv CreateStructuringElementEx</a>  allocates and fills the structure
<code> IplConvKernel</code>, which can be used as a structuring element in the morphological
operations.</p>


<hr><h3><a name="decl_cvReleaseStructuringElement">ReleaseStructuringElement</a></h3>
<p class="Blurb">Deletes structuring element</p>
<pre>
void cvReleaseStructuringElement( IplConvKernel** element );
</pre><p><dl>
<dt>element<dd>Pointer to the deleted structuring element.
</dl><p>
The function <code>cvReleaseStructuringElement</code> releases the structure <code>IplConvKernel</code>
that is no longer needed. If <code>*element</code> is <code>NULL</code>, the function has no effect.</p>


<hr><h3><a name="decl_cvErode">Erode</a></h3>
<p class="Blurb">Erodes image by using arbitrary structuring element</p>
<pre>
void cvErode( const CvArr* src, CvArr* dst, IplConvKernel* element=NULL, int iterations=1 );
</pre><p><dl>
<dt>src<dd>Source image.
<dt>dst<dd>Destination image.
<dt>element<dd>Structuring element used for erosion. If it is <code>NULL</code>, a 3&times;3 rectangular
structuring element is used.
<dt>iterations<dd>Number of times erosion is applied.
</dl><p>
The function <code>cvErode</code> erodes the source image using the specified structuring element
that determines the shape of a pixel neighborhood over which the minimum is taken:</p>
<pre>
dst=erode(src,element):  dst(x,y)=min<sub>((x',y') in element)</sub>)</sub>src(x+x',y+y')
</pre>
<p>The function supports the in-place mode. Erosion can be applied several (<code>iterations</code>)
times. In case of color image each channel is processed independently.</p>


<hr><h3><a name="decl_cvDilate">Dilate</a></h3>
<p class="Blurb">Dilates image by using arbitrary structuring element</p>
<pre>
void cvDilate( const CvArr* src, CvArr* dst, IplConvKernel* element=NULL, int iterations=1 );
</pre><p><dl>
<dt>src<dd>Source image.
<dt>dst<dd>Destination image.
<dt>element<dd>Structuring element used for erosion. If it is <code>NULL</code>, a 3&times;3 rectangular
structuring element is used.
<dt>iterations<dd>Number of times erosion is applied.
</dl><p>
The function <code>cvDilate</code> dilates the source image using the specified structuring element
that determines the shape of a pixel neighborhood over which the maximum is taken:</p>
<pre>
dst=dilate(src,element):  dst(x,y)=max<sub>((x',y') in element)</sub>)</sub>src(x+x',y+y')
</pre>
<p>The function supports the in-place mode. Dilation can be applied several (<code>iterations</code>)
times. In case of color image each channel is processed independently.</p>


<hr><h3><a name="decl_cvMorphologyEx">MorphologyEx</a></h3>
<p class="Blurb">Performs advanced morphological transformations</p>
<pre>
void cvMorphologyEx( const CvArr* src, CvArr* dst, CvArr* temp,
                     IplConvKernel* element, int operation, int iterations=1 );
</pre><p><dl>
<dt>src<dd>Source image.
<dt>dst<dd>Destination image.
<dt>temp<dd>Temporary image, required in some cases.
<dt>element<dd>Structuring element.
<dt>operation<dd>Type of morphological operation, one of:<br>
               <code>CV_MOP_OPEN</code> - opening<br>
               <code>CV_MOP_CLOSE</code> - closing<br>
               <code>CV_MOP_GRADIENT</code> - morphological gradient<br>
               <code>CV_MOP_TOPHAT</code> - "top hat"<br>
               <code>CV_MOP_BLACKHAT</code> - "black hat"<br>
<dt>iterations<dd>Number of times erosion and dilation are applied.
</dl><p>
The function <code>cvMorphologyEx</code> can perform advanced morphological
transformations using erosion and dilation as basic operations.</p>
<pre>
Opening:
dst=open(src,element)=dilate(erode(src,element),element)

Closing:
dst=close(src,element)=erode(dilate(src,element),element)

Morphological gradient:
dst=morph_grad(src,element)=dilate(src,element)-erode(src,element)

"Top hat":
dst=tophat(src,element)=src-open(src,element)

"Black hat":
dst=blackhat(src,element)=close(src,element)-src
</pre>
<p>
The temporary image <code>temp</code> is required for morphological gradient and, in case of in-place
operation, for "top hat" and "black hat".
</p>


<hr><h2><a name="cv_imgproc_filters">Filters and Color Conversion</a></h2>

<hr><h3><a name="decl_cvSmooth">Smooth</a></h3>
<p class="Blurb">Smoothes the image in one of several ways</p>
<pre>
void cvSmooth( const CvArr* src, CvArr* dst,
               int smoothtype=CV_GAUSSIAN,
               int size1=3, int size2=0, double sigma1=0, double sigma2=0 );
</pre><p><dl>
<dt>src<dd>The source image.
<dt>dst<dd>The destination image.
<dt>smoothtype<dd>Type of the smoothing operation:<ul>
<li>CV_BLUR_NO_SCALE (simple blur with no scaling) -
              for each pixel the result is a sum of pixels values in
              <code>size1</code>&times;<code>size2</code> neighborhood of the pixel.
              If the neighborhood size varies from pixel to pixel, compute the sums
              using integral image (<a href="#decl_cvIntegral">cvIntegral</a>).
<li>CV_BLUR (simple blur) - for each pixel the result is the average value (brightness/color)
              of <code>size1</code>&times;<code>size2</code> neighborhood of the pixel.
<li>CV_GAUSSIAN (Gaussian blur) - the image is smoothed using the Gaussian kernel
              of aperture size <code>size1</code>&times;<code>size2</code>.
              <code>sigma1</code> and <code>sigma2</code> may optionally be
              used to specify shape of the kernel.
<li>CV_MEDIAN (median blur) - the image is smoothed using medial filter
              of size <code>size1</code>&times;<code>size1</code> (i.e. only square aperture can be used).
              That is, for each pixel the result is the median computed
              over <code>size1</code>&times;<code>size1</code> neighborhood.
<li>CV_BILATERAL (bilateral filter) -
              the image is smoothed using a bilateral 3x3 filter
              with color sigma=<code>sigma1</code> and
              spatial sigma=<code>sigma2</code>. If <code>size1!=0</code>, then
              a circular kernel with diameter <code>size1</code> is used;
              otherwise the diameter of the kernel is computed from <code>sigma2</code>.
              Information about bilateral filtering
              can be found at <a href="http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html">
              http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html</a>
</ul>
<dt>size1<dd>The first parameter of smoothing operation. It should be odd (1, 3, 5, ...),
             so that a pixel neighborhood used for smoothing operation is symmetrical
             relative to the pixel.
<dt>size2<dd>The second parameter of smoothing operation. In case of simple scaled/non-scaled and
             Gaussian blur if <code>size2</code> is zero, it is set to <code>size1</code>.
             When not 0, it should be odd too.
<dt>sigma1<dd><p>In case of Gaussian kernel this parameter may specify Gaussian sigma (standard deviation).
              If it is zero, it is calculated from the kernel size:<br>
              <pre>
              sigma = (n/2 - 1)*0.3 + 0.8, where n=param1 for horizontal kernel,
                                                 n=param2 for vertical kernel.
              </pre>
              With the standard sigma for small kernels (3&times;3 to 7&times;7) the performance is better.
              If <code>param3</code> is not zero, while <code>param1</code> and <code>param2</code>
              are zeros, the kernel size is calculated from the sigma (to provide accurate enough operation).</p>

              <p>In case of Bilateral filter the parameter specifies color sigma; the larger the value,
              the stronger the pasterization effect of the filter is.</p>
<dt>sigma2<dd><p>In case of non-square Gaussian kernel the parameter may be used to specify a different
              (from <code>param3</code>) sigma in the vertical direction.</p>

              <p>In case of Bilateral filter the parameter specifies spatial sigma; the larger the value,
              the stronger the blurring effect of the filter. Note that with large <code>sigma2</code>
              the processing speed decreases substantionally, so it is recommended to limit the kernel
              size using the parameter <code>size1</code>.</p>
</dl><p>
The function <code>cvSmooth</code> smoothes image using one of the pre-defined methods. Every of the methods
has some features and restrictions listed below:</p>
<ul>
<li>Blur with no scaling works with single-channel images only and supports accumulation of
8u to 16s format (similar to <a href="#decl_cvSobel">cvSobel</a> and <a href="#decl_cvLaplace">cvLaplace</a>)
and accumulation of 32f to 32f format.</li>
<li>Simple blur and Gaussian blur support 1- or 3-channel, 8-bit, 16-bit and 32-bit floating-point images.
These two methods can process images in-place.</li>
<li>Median filter works with 1- or 3-channel 8-bit images and can not process images in-place.</li>
<li>Bilateral filter works with 1- or 3-channel, 8-bit or 32-bit floating-point images and can not process images in-place.</li>
</ul>

<hr><h3><a name="decl_cvFilter2D">Filter2D</a></h3>
<p class="Blurb">Applies linear filter to image</p>
<pre>
void cvFilter2D( const CvArr* src, CvArr* dst,
                 const CvMat* kernel,
                 CvPoint anchor=cvPoint(-1,-1));
</pre><p><dl>
<dt>src<dd>The source image.
<dt>dst<dd>The destination image.
<dt>kernel<dd>The filter mask, single-channel 2d floating point matrix of coefficients.
              In case of multi-channel images every channel is processed independently
              using the same kernel. To process different channels differently,
              split the image using
              <a href="opencvref_cxcore.htm#decl_cvSplit">cvSplit</a>
              and filter the channels one by one.
<dt>anchor<dd>The anchor of the kernel. It is relative position of the filtered pixel
inside its neighborhood covered by the kernel mask. The anchor should be inside the kernel.
The special default value (-1,-1) means that the anchor is at the kernel center.
</ul>
</dl></p><p>
The function <code>cvFilter2D</code> applies the specified linear filter to the image.
In-place operation is supported. When the aperture is partially outside the image,
the function interpolates outlier pixel values from the nearest pixels at the
image boundary. If ROI is set in the input
image, cvFilter2D treats it, similarly to many other OpenCV functions, as if
it were an isolated image, i.e. pixels inside the image but outside of the ROI
are ignored. If it is undesirable, consider new C++ filtering classes declared
in cv.hpp.
</p>


<hr><h3><a name="decl_cvCopyMakeBorder">CopyMakeBorder</a></h3>
<p class="Blurb">Copies image and makes border around it</p>
<pre>
void cvCopyMakeBorder( const CvArr* src, CvArr* dst, CvPoint offset,
                       int bordertype, CvScalar value=cvScalarAll(0) );
</pre><p><dl>
<dt>src<dd>The source image.
<dt>dst<dd>The destination image.
<dt>offset<dd>Coordinates of the top-left corner (or bottom-left in case of images with bottom-left origin)
              of the destination image rectangle where the source image (or its ROI) is copied.
              Size of the rectangle matches the source image size/ROI size.
<dt>bordertype<dd>Type of the border to create around the copied source image rectangle:<br>
              <code>IPL_BORDER_CONSTANT</code> -
                  border is filled with the fixed value, passed as last parameter of the function.<br>
              <code>IPL_BORDER_REPLICATE</code> -
                  the pixels from the top and bottom rows, the left-most and right-most columns are replicated
                  to fill the border.<br>
              (The other two border types from IPL, <code>IPL_BORDER_REFLECT</code> and <code>IPL_BORDER_WRAP</code>,
              are currently unsupported).
<dt>value<dd>Value of the border pixels if <code>bordertype=IPL_BORDER_CONSTANT</code>.
</dl></p><p>
The function <code>cvCopyMakeBorder</code> copies the source 2D array into interior of destination array
and makes a border of the specified type around the copied area.
The function is useful when one needs to emulate border type that is different from the one embedded into a specific
algorithm implementation. For example, morphological functions, as well as most of other filtering functions in OpenCV,
internally use replication border type, while the user may need zero border or a border, filled with 1's or 255's.
</p>


<hr><h3><a name="decl_cvIntegral">Integral</a></h3>
<p class="Blurb">Calculates integral images</p>
<pre>
void cvIntegral( const CvArr* image, CvArr* sum, CvArr* sqsum=NULL, CvArr* tilted_sum=NULL );
</pre><p><dl>
<dt>image<dd>The source image, <code>W</code>&times;<code>H</code>, 8-bit or floating-point (32f or 64f) image.
<dt>sum<dd>The integral image, <code>W+1</code>&times;<code>H+1</code>, 32-bit integer or double precision floating-point (64f).
<dt>sqsum<dd>The optional integral image for squared pixel values, <code>W+1</code>&times;<code>H+1</code>, double precision floating-point (64f).
<dt>tilted_sum<dd>The optional integral for the image rotated by 45 degrees, <code>W+1</code>&times;<code>H+1</code>, of the same data type as <code>sum</code>.
</dl><p>
The function <code>cvIntegral</code> calculates one or more integral images for the source image as following:</p>
<pre>
sum(X,Y)=sum<sub>x&lt;X,y&lt;Y</sub>image(x,y)

sqsum(X,Y)=sum<sub>x&lt;X,y&lt;Y</sub>image(x,y)<sup>2</sup>

tilted_sum(X,Y)=sum<sub>y&lt;Y,abs(x-X)&lt;y</sub>image(x,y)
</pre>
<p>Using these integral images, one may calculate sum, mean, standard deviation over
arbitrary up-right or rotated rectangular region of the image in a constant time, for example:</p>
<pre>
sum<sub>x1&lt;=x&lt;x2,y1&lt;=y&lt;y2</sub>image(x,y)=sum(x2,y2)-sum(x1,y2)-sum(x2,y1)+sum(x1,x1)
</pre>
<p>Using integral images it is possible to do variable-size image blurring,
block correlation etc.
In case of multi-channel input images the integral images must have
the same number of channels, and every channel is processed independently.
</p>

<hr><h3><a name="decl_cvCvtColor">CvtColor</a></h3>
<p class="Blurb">Converts image from one color space to another</p>
<pre>
void cvCvtColor( const CvArr* src, CvArr* dst, int code );
</pre><p><dl>
<dt>src<dd>The source 8-bit (8u), 16-bit (16u) or single-precision floating-point (32f) image.
<dt>dst<dd>The destination image of the same data type as the source one.
           The number of channels may be different.
<dt>code<dd>Color conversion operation that can be specified using
CV_&lt;src_color_space&gt;2&lt;dst_color_space&gt; constants (see below).
</dl><p>
The function <code>cvCvtColor</code> converts input image from one color space to another.
The function ignores <code>colorModel</code> and <code>channelSeq</code> fields of <code>IplImage</code> header,
so the source image color space should be specified correctly (including order of the channels in case
of RGB space, e.g. BGR means 24-bit format with B<sub>0</sub> G<sub>0</sub> R<sub>0</sub> B<sub>1</sub> G<sub>1</sub> R<sub>1</sub> ... layout,
whereas RGB means 24-bit format with R<sub>0</sub> G<sub>0</sub> B<sub>0</sub> R<sub>1</sub> G<sub>1</sub> B<sub>1</sub> ... layout).
</p><p>
The conventional range for R,G,B channel values is:
<ul>
<li>0..255 for 8-bit images
<li>0..65535 for 16-bit images and
<li>0..1 for floating-point images.
</ul>
Of course, in case of linear transformations the range can be arbitrary,
but in order to get correct results in case of non-linear transformations,
the input image should be scaled if necessary.
</p><p>
The function can do the following transformations:<ul>
<li>Transformations within RGB space like adding/removing alpha channel, reversing the channel order,
conversion to/from 16-bit RGB color (R5:G6:B5 or R5:G5:B5) color, as well as conversion to/from grayscale using:
<pre>
RGB[A]->Gray: Y&lt;-0.299*R + 0.587*G + 0.114*B
Gray->RGB[A]: R&lt;-Y G&lt;-Y B&lt;-Y A&lt;-0
</pre>
<li>RGB&lt;=&gt;CIE XYZ.Rec 709 with D65 white point (<code>CV_BGR2XYZ, CV_RGB2XYZ, CV_XYZ2BGR, CV_XYZ2RGB</code>):
<pre>
|X|    |0.412453  0.357580  0.180423| |R|
|Y| &lt;- |0.212671  0.715160  0.072169|*|G|
|Z|    |0.019334  0.119193  0.950227| |B|

|R|    | 3.240479  -1.53715  -0.498535| |X|
|G| &lt;- |-0.969256   1.875991  0.041556|*|Y|
|B|    | 0.055648  -0.204043  1.057311| |Z|

X, Y and Z cover the whole value range (in case of floating-point images Z may exceed 1).
</pre>
<p></p>
<li>RGB&lt;=&gt;YCrCb JPEG (a.k.a. YCC) (<code>CV_BGR2YCrCb, CV_RGB2YCrCb, CV_YCrCb2BGR, CV_YCrCb2RGB</code>)
<pre>
Y &lt;- 0.299*R + 0.587*G + 0.114*B
Cr &lt;- (R-Y)*0.713 + delta
Cb &lt;- (B-Y)*0.564 + delta

R &lt;- Y + 1.403*(Cr - delta)
G &lt;- Y - 0.344*(Cr - delta) - 0.714*(Cb - delta)
B &lt;- Y + 1.773*(Cb - delta),

              { 128 for 8-bit images,
where delta = { 32768 for 16-bit images
              { 0.5 for floating-point images

Y, Cr and Cb cover the whole value range.
</pre>
<p></p>
<li>RGB&lt;=&gt;HSV (<code>CV_BGR2HSV, CV_RGB2HSV, CV_HSV2BGR, CV_HSV2RGB</code>)
<pre>
// In case of 8-bit and 16-bit images
// R, G and B are converted to floating-point format and scaled to fit 0..1 range

V &lt;- max(R,G,B)
S &lt;- (V-min(R,G,B))/V   if V&ne;0, 0 otherwise

         (G - B)*60/S,  if V=R
H &lt;- 180+(B - R)*60/S,  if V=G
     240+(R - G)*60/S,  if V=B

if H&lt;0 then H&lt;-H+360

On output 0&le;V&le;1, 0&le;S&le;1, 0&le;H&le;360.
The values are then converted to the destination data type:
    8-bit images:
        V &lt;- V*255, S &lt;- S*255, H &lt;- H/2 (to fit to 0..255)
    16-bit images (currently not supported):
        V &lt;- V*65535, S &lt;- S*65535, H &lt;- H
    32-bit images:
        H, S, V are left as is
</pre>
<li>RGB&lt;=&gt;HLS (<code>CV_BGR2HLS, CV_RGB2HLS, CV_HLS2BGR, CV_HLS2RGB</code>)
<pre>
// In case of 8-bit and 16-bit images
// R, G and B are converted to floating-point format and scaled to fit 0..1 range

V<sub>max</sub> &lt;- max(R,G,B)
V<sub>min</sub> &lt;- min(R,G,B)

L &lt;- (V<sub>max</sub> + V<sub>min</sub>)/2

S &lt;- (V<sub>max</sub> - V<sub>min</sub>)/(V<sub>max</sub> + V<sub>min</sub>)  if L &lt; 0.5
     (V<sub>max</sub> - V<sub>min</sub>)/(2 - (V<sub>max</sub> + V<sub>min</sub>))  if L &ge; 0.5

         (G - B)*60/S,  if V<sub>max</sub>=R
H &lt;- 180+(B - R)*60/S,  if V<sub>max</sub>=G
     240+(R - G)*60/S,  if V<sub>max</sub>=B

if H&lt;0 then H&lt;-H+360

On output 0&le;L&le;1, 0&le;S&le;1, 0&le;H&le;360.
The values are then converted to the destination data type:
    8-bit images:
        L &lt;- L*255, S &lt;- S*255, H &lt;- H/2
    16-bit images (currently not supported):
        L &lt;- L*65535, S &lt;- S*65535, H &lt;- H
    32-bit images:
        H, L, S are left as is
</pre>
<li>RGB&lt;=&gt;CIE L*a*b* (<code>CV_BGR2Lab, CV_RGB2Lab, CV_Lab2BGR, CV_Lab2RGB</code>)
<pre>
// In case of 8-bit and 16-bit images
// R, G and B are converted to floating-point format and scaled to fit 0..1 range

// convert R,G,B to CIE XYZ
|X|    |0.412453  0.357580  0.180423| |R|
|Y| &lt;- |0.212671  0.715160  0.072169|*|G|
|Z|    |0.019334  0.119193  0.950227| |B|

X &lt;- X/Xn, where Xn = 0.950456
Z &lt;- Z/Zn, where Zn = 1.088754

L &lt;- 116*Y<sup>1/3</sup>      for Y>0.008856
L &lt;- 903.3*Y      for Y&lt;=0.008856

a &lt;- 500*(f(X)-f(Y)) + delta
b &lt;- 200*(f(Y)-f(Z)) + delta
where f(t)=t<sup>1/3</sup>              for t>0.008856
      f(t)=7.787*t+16/116   for t&lt;=0.008856


where delta = 128 for 8-bit images,
              0 for floating-point images

On output 0&le;L&le;100, -127&le;a&le;127, -127&le;b&le;127
The values are then converted to the destination data type:
    8-bit images:
        L &lt;- L*255/100, a &lt;- a + 128, b &lt;- b + 128
    16-bit images are currently not supported
    32-bit images:
        L, a, b are left as is
</pre>

<li>RGB&lt;=&gt;CIE L*u*v* (<code>CV_BGR2Luv, CV_RGB2Luv, CV_Luv2BGR, CV_Luv2RGB</code>)
<pre>
// In case of 8-bit and 16-bit images
// R, G and B are converted to floating-point format and scaled to fit 0..1 range

// convert R,G,B to CIE XYZ
|X|    |0.412453  0.357580  0.180423| |R|
|Y| &lt;- |0.212671  0.715160  0.072169|*|G|
|Z|    |0.019334  0.119193  0.950227| |B|

L &lt;- 116*Y<sup>1/3</sup>-16   for Y>0.008856
L &lt;- 903.3*Y      for Y&lt;=0.008856

u' &lt;- 4*X/(X + 15*Y + 3*Z)
v' &lt;- 9*Y/(X + 15*Y + 3*Z)

u &lt;- 13*L*(u' - u<sub>n</sub>), where u<sub>n</sub>=0.19793943
v &lt;- 13*L*(v' - v<sub>n</sub>), where v<sub>n</sub>=0.46831096

On output 0&le;L&le;100, -134&le;u&le;220, -140&le;v&le;122
The values are then converted to the destination data type:
    8-bit images:
        L &lt;- L*255/100, u &lt;- (u + 134)*255/354, v &lt;- (v + 140)*255/256
    16-bit images are currently not supported
    32-bit images:
        L, u, v are left as is
</pre>

The above formulae for converting RGB to/from various color spaces have been taken
from multiple sources on Web, primarily from <a href="#paper_ford98">Color Space Conversions (<b>[Ford98]</b>)</a>
document at Charles Poynton site.

<p></p>
<li>Bayer=>RGB (<code>CV_BayerBG2BGR, CV_BayerGB2BGR, CV_BayerRG2BGR, CV_BayerGR2BGR,<br>
                CV_BayerBG2RGB, CV_BayerGB2RGB, CV_BayerRG2RGB, CV_BayerGR2RGB</code>)
<p>Bayer pattern is widely used in CCD and CMOS cameras. It allows to get color picture
out of a single plane where R,G and B pixels (sensors of a particular component) are interleaved like
this:</p>
<p>
<table border=0 width=400>
<tr>
<td><font size=5 color="#ff0000"><p align="center">R</font></td>
<td><font size=5 color="#008000"><p align="center">G</font></td>
<td><font size=5 color="#ff0000"><p align="center">R</font></td>
<td><font size=5 color="#008000"><p align="center">G</font></td>
<td><font size=5 color="#ff0000"><p align="center">R</font></td>
</tr><tr>
<td><font size=5 color="#008000"><p align="center">G</font></td>
<td bgcolor="pink"><font size=5 color="#0000ff" ><p align="center">B</font></td>
<td bgcolor="pink"><font size=5 color="#008000" ><p align="center">G</font></td>
<td><font size=5 color="#0000ff"><p align="center">B</font></td>
<td><font size=5 color="#008000"><p align="center">G</font></td>
</tr><tr>
<td><font size=5 color="#ff0000"><p align="center">R</font></td>
<td><font size=5 color="#008000"><p align="center">G</font></td>
<td><font size=5 color="#ff0000"><p align="center">R</font></td>
<td><font size=5 color="#008000"><p align="center">G</font></td>
<td><font size=5 color="#ff0000"><p align="center">R</font></td>
</tr><tr>
<td><font size=5 color="#008000"><p align="center">G</font></td>
<td><font size=5 color="#0000ff"><p align="center">B</font></td>
<td><font size=5 color="#008000"><p align="center">G</font></td>
<td><font size=5 color="#0000ff"><p align="center">B</font></td>
<td><font size=5 color="#008000"><p align="center">G</font></td>
</tr><tr>
<td><font size=5 color="#ff0000"><p align="center">R</font></td>
<td><font size=5 color="#008000"><p align="center">G</font></td>
<td><font size=5 color="#ff0000"><p align="center">R</font></td>
<td><font size=5 color="#008000"><p align="center">G</font></td>
<td><font size=5 color="#ff0000"><p align="center">R</font></td>
</tr><tr>
<td><font size=5 color="#008000"><p align="center">G</font></td>
<td><font size=5 color="#0000ff"><p align="center">B</font></td>
<td><font size=5 color="#008000"><p align="center">G</font></td>
<td><font size=5 color="#0000ff"><p align="center">B</font></td>
<td><font size=5 color="#008000"><p align="center">G</font></td>
</tr>
</table>
</p><p>
The output RGB components of a pixel are interpolated from 1, 2 or 4 neighbors of the pixel
having the same color. There are several modifications of the above pattern that can be achieved
by shifting the pattern one pixel left and/or one pixel up.
The two letters C<sub>1</sub> and C<sub>2</sub> in the conversion constants CV_BayerC<sub>1</sub>C<sub>2</sub>2{BGR|RGB}
indicate the particular pattern type -
these are components from the second row, second and third columns, respectively.
For example, the above pattern has very popular "BG" type.</p>
</ul>
</p>


<hr><h3><a name="decl_cvThreshold">Threshold</a></h3>
<p class="Blurb">Applies fixed-level threshold to array elements</p>
<pre>
double cvThreshold( const CvArr* src, CvArr* dst, double threshold,
                    double max_value, int threshold_type );
</pre><p><dl>
<dt>src<dd>Source array (single-channel, 8-bit of 32-bit floating point).
<dt>dst<dd>Destination array; must be either the same type as <code>src</code> or 8-bit.
<dt>threshold<dd>Threshold value.
<dt>max_value<dd>Maximum value to use with <code>CV_THRESH_BINARY</code> and
                 <code>CV_THRESH_BINARY_INV</code> thresholding types.
<dt>threshold_type<dd>Thresholding type (see the discussion)
</dl><p>
The function <code>cvThreshold</code> applies fixed-level thresholding to single-channel array.
The function is typically used to get bi-level (binary) image out of grayscale image
(<a href="opencvref_cxcore.htm#decl_cvCmpS">cvCmpS</a>
could be also used for this purpose) or for removing a noise, i.e. filtering out pixels with too small or too large values.
There are several types of thresholding the function supports that are determined by <code>threshold_type</code>:</p>
<pre>
threshold_type=CV_THRESH_BINARY:
dst(x,y) = max_value, if src(x,y)&gt;threshold
           0, otherwise

threshold_type=CV_THRESH_BINARY_INV:
dst(x,y) = 0, if src(x,y)&gt;threshold
           max_value, otherwise

threshold_type=CV_THRESH_TRUNC:
dst(x,y) = threshold, if src(x,y)&gt;threshold
           src(x,y), otherwise

threshold_type=CV_THRESH_TOZERO:
dst(x,y) = src(x,y), if src(x,y)&gt;threshold
           0, otherwise

threshold_type=CV_THRESH_TOZERO_INV:
dst(x,y) = 0, if src(x,y)&gt;threshold
           src(x,y), otherwise
</pre>
<p>And this is the visual description of thresholding types:</p>
<p>
<image align="center" src="pics/threshold.png">
</p>
Also, the special value <code>CV_THRESH_OTSU</code> may be combined with
one of the above values. In this case the function determines the optimal threshold
value using Otsu algorithm and uses it instead of the specified <code>thresh</code>.
The function returns the computed threshold value.
Currently, Otsu method is implemented only for 8-bit images.
</p>

<hr><h3><a name="decl_cvAdaptiveThreshold">AdaptiveThreshold</a></h3>
<p class="Blurb">Applies adaptive threshold to array</p>
<pre>
void cvAdaptiveThreshold( const CvArr* src, CvArr* dst, double max_value,
                          int adaptive_method=CV_ADAPTIVE_THRESH_MEAN_C,
                          int threshold_type=CV_THRESH_BINARY,
                          int block_size=3, double param1=5 );
</pre><p><dl>
<dt>src<dd>Source image.
<dt>dst<dd>Destination image.
<dt>max_value<dd>Maximum value that is used with <code>CV_THRESH_BINARY</code> and <code>CV_THRESH_BINARY_INV</code>.
<dt>adaptive_method<dd>Adaptive thresholding algorithm to use: <code>CV_ADAPTIVE_THRESH_MEAN_C</code>
or <code>CV_ADAPTIVE_THRESH_GAUSSIAN_C</code> (see the discussion).
<dt>threshold_type<dd>Thresholding type; must be one of
<ul>
<li><code>CV_THRESH_BINARY,</code>
<li><code>CV_THRESH_BINARY_INV</code>
</ul>
<dt>block_size<dd>The size of a pixel neighborhood that is used to calculate a threshold value for the pixel:
3, 5, 7, ...
<dt>param1<dd>The method-dependent parameter.
For the methods <code>CV_ADAPTIVE_THRESH_MEAN_C</code> and <code>CV_ADAPTIVE_THRESH_GAUSSIAN_C</code>
it is a constant subtracted from mean or weighted mean (see the discussion), though it may be negative.
</dl><p>
The function <code>cvAdaptiveThreshold</code> transforms grayscale image to binary image according to
the formulae:</p>
<pre>
threshold_type=<code>CV_THRESH_BINARY</code>:
dst(x,y) = max_value, if src(x,y)&gt;T(x,y)
           0, otherwise

threshold_type=<code>CV_THRESH_BINARY_INV</code>:
dst(x,y) = 0, if src(x,y)&gt;T(x,y)
           max_value, otherwise
</pre>
<p>where T<sub>I</sub> is a threshold calculated individually for each pixel.</p>
<p>
For the method <code>CV_ADAPTIVE_THRESH_MEAN_C</code> it is a mean of <code>block_size</code> &times; <code>block_size</code>
pixel neighborhood, subtracted by <code>param1</code>.</p><p>
For the method <code>CV_ADAPTIVE_THRESH_GAUSSIAN_C</code> it is a weighted sum (Gaussian) of
<code>block_size</code> &times; <code>block_size</code> pixel neighborhood, subtracted by <code>param1</code>.</p>


<hr><h2><a name="cv_imgproc_pyramids">Pyramids and the Applications</a></h2>

<hr><h3><a name="decl_cvPyrDown">PyrDown</a></h3>
<p class="Blurb">Downsamples image</p>
<pre>
void cvPyrDown( const CvArr* src, CvArr* dst, int filter=CV_GAUSSIAN_5x5 );
</pre><p><dl>
<dt>src<dd>The source image.
<dt>dst<dd>The destination image, should have 2x smaller width and height than the source.
<dt>filter<dd>Type of the filter used for convolution; only <code>CV_GAUSSIAN_5x5</code> is
currently supported.
</dl><p>
The function <code>cvPyrDown</code> performs downsampling step of Gaussian pyramid
decomposition. First it convolves source image with the specified filter and
then downsamples the image by rejecting even rows and columns.</p>


<hr><h3><a name="decl_cvPyrUp">PyrUp</a></h3>
<p class="Blurb">Upsamples image</p>
<pre>
void cvPyrUp( const CvArr* src, CvArr* dst, int filter=CV_GAUSSIAN_5x5 );
</pre><p><dl>
<dt>src<dd>The source image.
<dt>dst<dd>The destination image, should have 2x smaller width and height than the source.
<dt>filter<dd>Type of the filter used for convolution; only <code>CV_GAUSSIAN_5x5</code> is
currently supported.
</dl><p>
The function <code>cvPyrUp</code> performs up-sampling step of Gaussian pyramid decomposition.
First it upsamples the source image by injecting even zero rows and columns and
then convolves result with the specified filter multiplied by 4 for
interpolation. So the destination image is four times larger than the source
image.</p>

<hr><h2><a name="cv_imgproc_ccomp">Image Segmentation, Connected Components and Contour Retrieval</a></h2>

<hr><h3><a name="decl_CvConnectedComp">CvConnectedComp</a></h3>
<p class="Blurb">Connected component</p>
<pre>
    typedef struct CvConnectedComp
    {
        double area; /* area of the segmented component */
        float value; /* gray scale value of the segmented component */
        CvRect rect; /* ROI of the segmented component */
    } CvConnectedComp;
</pre>


<hr><h3><a name="decl_cvFloodFill">FloodFill</a></h3>
<p class="Blurb">Fills a connected component with given color</p>
<pre>
void cvFloodFill( CvArr* image, CvPoint seed_point, CvScalar new_val,
                  CvScalar lo_diff=cvScalarAll(0), CvScalar up_diff=cvScalarAll(0),
                  CvConnectedComp* comp=NULL, int flags=4, CvArr* mask=NULL );
#define CV_FLOODFILL_FIXED_RANGE (1 &lt;&lt; 16)
#define CV_FLOODFILL_MASK_ONLY   (1 &lt;&lt; 17)
</pre><p><dl>
<dt>image<dd>Input 1- or 3-channel, 8-bit or floating-point image.
             It is modified by the function unless CV_FLOODFILL_MASK_ONLY flag is set (see below).
<dt>seed_point<dd>The starting point.
<dt>new_val<dd>New value of repainted domain pixels.
<dt>lo_diff<dd>Maximal lower brightness/color difference between the currently observed pixel and one of its
neighbor belong to the component or seed pixel to add the pixel to component.
In case of 8-bit color images it is packed value.
<dt>up_diff<dd>Maximal upper brightness/color difference between the currently observed pixel and one of its
neighbor belong to the component or seed pixel to add the pixel to component.
In case of 8-bit color images it is packed value.
<dt>comp<dd>Pointer to structure the function fills with the information about the
repainted domain.
<dt>flags<dd>The operation flags. Lower bits contain connectivity value, 4 (by default) or 8,
used within the function. Connectivity determines which neighbors of a pixel are considered.
Upper bits can be 0 or combination of the following flags:<ul>
<li>CV_FLOODFILL_FIXED_RANGE - if set the difference between the current pixel and seed pixel is considered,
                               otherwise difference between neighbor pixels is considered (the range is floating).
<li>CV_FLOODFILL_MASK_ONLY - if set, the function does not fill the image (<code>new_val</code> is ignored),
but the fills mask (that must be non-NULL in this case).
</ul>
<dt>mask<dd>Operation mask, should be singe-channel 8-bit image, 2 pixels wider and 2 pixels taller than
<code>image</code>. If not NULL, the function uses and updates the mask, so user takes responsibility of
initializing <code>mask</code> content. Floodfilling can't go across
non-zero pixels in the mask, for example, an edge detector output can be used as a mask
to stop filling at edges. Or it is possible to use the same mask in multiple calls to the function
to make sure the filled area do not overlap. <em>Note</em>: because mask is larger than the filled image,
pixel in <code>mask</code> that corresponds to <code>(x,y)</code> pixel in <code>image</code>
will have coordinates <code>(x+1,y+1)</code>.
</dl><p>
The function <code>cvFloodFill</code> fills a connected component starting from the seed point
with the specified color. The connectivity is determined by the closeness of pixel values.
The pixel at <code>(x, y)</code> is considered to belong to the repainted domain if:</p>
<pre>
src(x',y')-lo_diff&lt;=src(x,y)&lt;=src(x',y')+up_diff,     grayscale image, floating range
src(seed.x,seed.y)-lo&lt;=src(x,y)&lt;=src(seed.x,seed.y)+up_diff, grayscale image, fixed range

src(x',y')<sub>r</sub>-lo_diff<sub>r</sub>&lt;=src(x,y)<sub>r</sub>&lt;=src(x',y')<sub>r</sub>+up_diff<sub>r</sub> and
src(x',y')<sub>g</sub>-lo_diff<sub>g</sub>&lt;=src(x,y)<sub>g</sub>&lt;=src(x',y')<sub>g</sub>+up_diff<sub>g</sub> and
src(x',y')<sub>b</sub>-lo_diff<sub>b</sub>&lt;=src(x,y)<sub>b</sub>&lt;=src(x',y')<sub>b</sub>+up_diff<sub>b</sub>, color image, floating range

src(seed.x,seed.y)<sub>r</sub>-lo_diff<sub>r</sub>&lt;=src(x,y)<sub>r</sub>&lt;=src(seed.x,seed.y)<sub>r</sub>+up_diff<sub>r</sub> and
src(seed.x,seed.y)<sub>g</sub>-lo_diff<sub>g</sub>&lt;=src(x,y)<sub>g</sub>&lt;=src(seed.x,seed.y)<sub>g</sub>+up_diff<sub>g</sub> and
src(seed.x,seed.y)<sub>b</sub>-lo_diff<sub>b</sub>&lt;=src(x,y)<sub>b</sub>&lt;=src(seed.x,seed.y)<sub>b</sub>+up_diff<sub>b</sub>, color image, fixed range
</pre>
where <code>src(x',y')</code> is value of one of pixel neighbors.
That is, to be added to the connected component, a pixel&#146;s color/brightness should be close enough to:
<ul>
<li>color/brightness of one of its neighbors that are already referred to the connected
component in case of floating range
<li>color/brightness of the seed point in case of fixed range.
</ul>
</p>


<hr><h3><a name="decl_cvFindContours">FindContours</a></h3>
<p class="Blurb">Finds contours in binary image</p>
<pre>
int cvFindContours( CvArr* image, CvMemStorage* storage, CvSeq** first_contour,
                    int header_size=sizeof(CvContour), int mode=CV_RETR_LIST,
                    int method=CV_CHAIN_APPROX_SIMPLE, CvPoint offset=cvPoint(0,0) );
</pre><p><dl>
<dt>image<dd>The source 8-bit single channel image. Non-zero pixels are treated as
1&#146;s, zero pixels remain 0&#146;s - that is image treated as <code>binary</code>. To get such a binary image
from grayscale, one may use <a href="#decl_cvThreshold">cvThreshold</a>, <a href="#decl_cvAdaptiveThreshold">cvAdaptiveThreshold</a> or <a href="#decl_cvCanny">cvCanny</a>.
The function modifies the source image content.
<dt>storage<dd>Container of the retrieved contours.
<dt>first_contour<dd>Output parameter, will contain the pointer to the first outer contour.
<dt>header_size<dd>Size of the sequence header, &gt;=sizeof(<a href="#decl_CvChain">CvChain</a>) if <code>method</code>=CV_CHAIN_CODE,
                  and &gt;=sizeof(CvContour) otherwise.
<dt>mode<dd>Retrieval mode.
<ul>
<li><code>CV_RETR_EXTERNAL</code> - retrieve only the extreme outer contours
<li><code>CV_RETR_LIST</code> - retrieve all the contours and puts them in the list
<li><code>CV_RETR_CCOMP</code> - retrieve all the contours and organizes them into two-level hierarchy:
                          top level are external boundaries of the components, second level are                          
                          boundaries of the holes
<li><code>CV_RETR_TREE</code> - retrieve all the contours and reconstructs the full hierarchy of
                         nested contours
</ul>
<dt>method<dd>Approximation method (for all the modes, except <code>CV_RETR_RUNS</code>, which uses
built-in approximation).
<ul>
<li><code>CV_CHAIN_CODE</code> - output contours in the Freeman chain code. All other methods output polygons
     (sequences of vertices).
<li><code>CV_CHAIN_APPROX_NONE</code> - translate all the points from the chain code into
  points;
<li><code>CV_CHAIN_APPROX_SIMPLE</code> - compress horizontal, vertical, and diagonal segments,
  that is, the function leaves only their ending points;
<li><code>CV_CHAIN_APPROX_TC89_L1,<div>CV_CHAIN_APPROX_TC89_KCOS</code> - apply one of the flavors of
  Teh-Chin chain approximation algorithm.
<li><code>CV_LINK_RUNS</code> - use completely different contour retrieval algorithm via
linking of horizontal segments of 1&#146;s. Only <code>CV_RETR_LIST</code> retrieval mode can be used
with this method.
</ul>
<dt>offset<dd>Offset, by which every contour point is shifted. This is useful if the contours are extracted from
the image ROI and then they should be analyzed in the whole image context.
</dl><p>
The function <code>cvFindContours</code> retrieves contours from the binary image and returns
the number of retrieved contours. The pointer <code>first_contour</code> is filled by the function.
It will contain pointer to the first most outer contour or NULL if no contours is detected (if the image is completely black).
Other contours may be reached from <code>first_contour</code> using <code>h_next</code> and <code>v_next</code> links.
The sample in <a href="#decl_cvDrawContours">cvDrawContours</a> discussion shows how to use contours for connected component
detection. Contours can be also used for shape analysis and object recognition - see <code>squares.c</code>
in OpenCV sample directory.</p>


<hr><h3><a name="decl_cvStartFindContours">StartFindContours</a></h3>
<p class="Blurb">Initializes contour scanning process</p>
<pre>
CvContourScanner cvStartFindContours( CvArr* image, CvMemStorage* storage,
                                      int header_size=sizeof(CvContour),
                                      int mode=CV_RETR_LIST,
                                      int method=CV_CHAIN_APPROX_SIMPLE,
                                      CvPoint offset=cvPoint(0,0) );
</pre><p><dl>
<dt>image<dd>The source 8-bit single channel binary image.
<dt>storage<dd>Container of the retrieved contours.
<dt>header_size<dd>Size of the sequence header, &gt;=sizeof(<a href="#decl_CvChain">CvChain</a>) if <code>method</code>=CV_CHAIN_CODE,
                  and &gt;=sizeof(CvContour) otherwise.
<dt>mode<dd>Retrieval mode; see <a href="#decl_cvFindContours">cvFindContours</a>.
<dt>method<dd>Approximation method. It has the same meaning as in <a href="#decl_cvFindContours">cvFindContours</a>,
but CV_LINK_RUNS can not be used here.
<dt>offset<dd>ROI offset; see <a href="#decl_cvFindContours">cvFindContours</a>.
</ul>
</dl><p>
The function <code>cvStartFindContours</code> initializes and returns pointer to the contour
scanner. The scanner is used further in <a href="#decl_cvFindNextContour">cvFindNextContour</a> to retrieve the rest of contours.
</p>


<hr><h3><a name="decl_cvFindNextContour">FindNextContour</a></h3>
<p class="Blurb">Finds next contour in the image</p>
<pre>
CvSeq* cvFindNextContour( CvContourScanner scanner );
</pre><p><dl>
<dt>scanner<dd>Contour scanner initialized by The function <code>cvStartFindContours</code> .
</dl><p>
The function <code>cvFindNextContour</code> locates and retrieves the next contour in the image and
returns pointer to it. The function returns NULL, if there is no more contours.</p>


<hr><h3><a name="decl_cvSubstituteContour">SubstituteContour</a></h3>
<p class="Blurb">Replaces retrieved contour</p>
<pre>
void cvSubstituteContour( CvContourScanner scanner, CvSeq* new_contour );
</pre><p><dl>
<dt>scanner<dd>Contour scanner initialized by the function cvStartFindContours .
<dt>new_contour<dd>Substituting contour.
</dl><p>
The function <code>cvSubstituteContour</code> replaces the retrieved contour, that was returned
from the preceding call of The function <code>cvFindNextContour</code> and stored inside
the contour scanner state, with the user-specified contour. The contour is
inserted into the resulting structure, list, two-level hierarchy, or tree,
depending on the retrieval mode. If the parameter <code>new_contour</code>=NULL, the retrieved
contour is not included into the resulting structure, nor all of its children
that might be added to this structure later.
</p>


<hr><h3><a name="decl_cvEndFindContours">EndFindContours</a></h3>
<p class="Blurb">Finishes scanning process</p>
<pre>
CvSeq* cvEndFindContours( CvContourScanner* scanner );
</pre><p><dl>
<dt>scanner<dd>Pointer to the contour scanner.
</dl><p>
The function <code>cvEndFindContours</code> finishes the scanning process and returns the
pointer to the first contour on the highest level.</p>


<hr><h3><a name="decl_cvPyrSegmentation">PyrSegmentation</a></h3>
<p class="Blurb">Does image segmentation by pyramids</p>
<pre>
void cvPyrSegmentation( IplImage* src, IplImage* dst,
                        CvMemStorage* storage, CvSeq** comp,
                        int level, double threshold1, double threshold2 );
</pre><p><dl>
<dt>src<dd>The source image.
<dt>dst<dd>The destination image.
<dt>storage<dd>Storage; stores the resulting sequence of connected components.
<dt>comp<dd>Pointer to the output sequence of the segmented components.
<dt>level<dd>Maximum level of the pyramid for the segmentation.
<dt>threshold1<dd>Error threshold for establishing the links.
<dt>threshold2<dd>Error threshold for the segments clustering.
</dl><p>
The function <code>cvPyrSegmentation</code> implements image segmentation by pyramids. The
pyramid builds up to the level <code>level</code>. The links between any pixel <code>a</code> on level <code>i</code>
and its candidate father pixel <code>b</code> on the adjacent level are established if
<div> <code>p(c(a),c(b))&lt;threshold1</code>.
After the connected components are defined, they are joined into several
clusters. Any two segments A and B belong to the same cluster, if
<div> <code>p(c(A),c(B))&lt;threshold2</code>. The input
image has only one channel, then
<div><code> p(c&sup1;,c&sup2;)=|c&sup1;-c&sup2;|</code>. If the input image has three channels (red,
green and blue), then
<div><code>p(c&sup1;,c&sup2;)=0,3&middot;(c&sup1;<sub>r</sub>-c&sup2;<sub>r</sub>)+0,59&middot;(c&sup1;<sub>g</sub>-c&sup2;<sub>g</sub>)+0,11&middot;(c&sup1;<sub>b</sub>-c&sup2;<sub>b</sub>) </code> .
There may be more than one connected component per a  cluster.
<div>The images <code>src</code> and <code>dst</code> should be 8-bit single-channel or 3-channel images
or equal size</p>


<hr><h3><a name="decl_cvPyrMeanShiftFiltering">PyrMeanShiftFiltering</a></h3>
<p class="Blurb">Does MeanShift image segmentation</p>
<pre>
void cvPyrMeanShiftFiltering( const CvArr* src, CvArr* dst,
     double sp, double sr, int max_level=1,
     CvTermCriteria termcrit=cvTermCriteria(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS,5,1));
</pre><p><dl>
<dt>src<dd>The source 8-bit 3-channel image.
<dt>dst<dd>The destination image of the same format and the same size as the source.
<dt>sp<dd>The spatial window radius.
<dt>sr<dd>The color window radius.
<dt>max_level<dd>Maximum level of the pyramid for the segmentation.
<dt>termcrit<dd>Termination criteria: when to stop meanshift iterations.
</dl><p>
The function <code>cvPyrMeanShiftFiltering</code> implements the filtering stage of meanshift
segmentation, that is, the output of the function is the filtered "posterized" image with
color gradients and fine-grain texture flattened. At every pixel <code>(X,Y)</code> of the
input image (or down-sized input image, see below) the function executes meanshift iterations,
that is, the pixel <code>(X,Y)</code> neighborhood in the joint space-color
hyper-space is considered:
<pre>{(x,y): X-sp&le;x&le;X+sp && Y-sp&le;y&le;Y+sp && ||(R,G,B)-(r,g,b)|| &le; sr},</pre>
where <code>(R,G,B)</code> and <code>(r,g,b)</code> are the vectors of color components
at <code>(X,Y)</code> and <code>(x,y)</code>, respectively (though, the algorithm does not depend
on the color space used, so any 3-component color space can be used instead).
Over the neighborhood the average spatial value <code>(X',Y')</code> and average color vector
<code>(R',G',B')</code> are found and they act as the neighborhood center on the next iteration:
<pre>(X,Y)~(X',Y'), (R,G,B)~(R',G',B').</pre>
After the iterations over, the color components of the initial pixel
(that is, the pixel from where the iterations started)
are set to the final value (average color at the last iteration):
<pre>I(X,Y) &lt;- (R*,G*,B*).</pre>

<p>Then <code>max_level</code>&gt;0, the Gaussian pyramid of <code>max_level</code>+1 levels is built,
and the above procedure is run on the smallest layer. After that, the results are propagated to the
larger layer and the iterations are run again only on those pixels where the layer colors
differ much (&gt;<code>sr</code>) from the lower-resolution layer, that is,
the boundaries of the color regions are clarified. Note, that the results
will be actually different from the ones obtained by running the meanshift procedure
on the whole original image (i.e. when <code>max_level</code>==0).</p>


<hr><h3><a name="decl_cvWatershed">Watershed</a></h3>
<p class="Blurb">Does watershed segmentation</p>
<pre>
void cvWatershed( const CvArr* image, CvArr* markers );
</pre><p><dl>
<dt>image<dd>The input 8-bit 3-channel image.
<dt>markers<dd>The input/output 32-bit single-channel image (map) of markers.
</dl><p>
The function <code>cvWatershed</code> implements one of the variants of watershed,
non-parametric marker-based segmentation algorithm, described in <a href="#paper_meyer92">[Meyer92]</a>
Before passing the image to the function, user has to outline roughly the desired regions
in the image <code>markers</code> with positive (&gt;0) indices, i.e. every region is represented as one or more
connected components with the pixel values 1, 2, 3 etc. Those components will be "seeds" of the
future image regions.
All the other pixels in <code>markers</code>, which relation to the outlined regions is not known
and should be defined by the algorithm, should be set to 0's. On the output of the function,
each pixel in <code>markers</code> is set to one of values of the "seed" components, or to -1
at boundaries between the regions.</p><p>Note, that it is not necessary that every
two neighbor connected components
are separated by a watershed boundary (-1's pixels), for example, in case when such tangent components
exist in the initial marker image. Visual demonstration and usage example of the function can be
found in OpenCV samples directory; see <code>watershed.cpp</code> demo.</p>

<hr><h2><a name="cv_imgproc_moments">Image and Contour moments</a></h2>

<hr><h3><a name="decl_cvMoments">Moments</a></h3>
<p class="Blurb">Calculates all moments up to third order of a polygon or rasterized shape</p>
<pre>
void cvMoments( const CvArr* arr, CvMoments* moments, int binary=0 );
</pre><p><dl>
<dt>arr<dd>Image (1-channel or 3-channel with COI set)
           or polygon (CvSeq of points or a vector of points).
<dt>moments<dd>Pointer to returned moment state structure.
<dt>binary<dd>(For images only) If the flag is non-zero, all the zero pixel values are treated as
zeroes, all the others are treated as 1&#146;s.
</dl><p>
The function <code>cvMoments</code> calculates spatial and central moments up to the third order and
writes them to <code>moments</code>. The moments may be used then to calculate gravity center of the shape,
its area, main axises and various shape characteristics including 7 Hu invariants.</p>


<hr><h3><a name="decl_cvGetSpatialMoment">GetSpatialMoment</a></h3>
<p class="Blurb">Retrieves spatial moment from moment state structure</p>
<pre>
double cvGetSpatialMoment( CvMoments* moments, int x_order, int y_order );
</pre><p><dl>
<dt>moments<dd>The moment state, calculated by <a href="#decl_cvMoments">cvMoments</a>.
<dt>x_order<dd>x order of the retrieved moment, <code>x_order</code> &gt;= 0.
<dt>y_order<dd>y order of the retrieved moment,
                 <code>y_order</code> &gt;= 0 and <code>x_order</code> + <code>y_order</code> &lt;= 3.
</dl><p>
The function <code>cvGetSpatialMoment</code> retrieves the spatial moment, which in case of
image moments is defined as:</p>
<pre>
M<sub>x_order,y_order</sub>=sum<sub>x,y</sub>(I(x,y)&bull;x<sup>x_order</sup>&bull;y<sup>y_order</sup>)
</pre>
<p>where <code>I(x,y)</code> is the intensity of the pixel <code>(x, y)</code>.


<hr><h3><a name="decl_cvGetCentralMoment">GetCentralMoment</a></h3>
<p class="Blurb">Retrieves central moment from moment state structure</p>
<pre>
double cvGetCentralMoment( CvMoments* moments, int x_order, int y_order );
</pre><p><dl>
<dt>moments<dd>Pointer to the moment state structure.
<dt>x_order<dd>x order of the retrieved moment, <code>x_order</code> &gt;= 0.
<dt>y_order<dd>y order of the retrieved moment,
                 <code>y_order</code> &gt;= 0 and <code>x_order</code> + <code>y_order</code> &lt;= 3.
</dl><p>
The function <code>cvGetCentralMoment</code> retrieves the central moment, which in case of
image moments is defined as:</p>
<pre>
&mu;<sub>x_order,y_order</sub>=sum<sub>x,y</sub>(I(x,y)&bull;(x-x<sub>c</sub>)<sup>x_order</sup>&bull;(y-y<sub>c</sub>)<sup>y_order</sup>),
</pre>
<p>where <code>x<sub>c</sub>=M<sub>10</sub>/M<sub>00</sub>, y<sub>c</sub>=M<sub>01</sub>/M<sub>00</sub></code> - coordinates of the gravity center</p>



<hr><h3><a name="decl_cvGetNormalizedCentralMoment">GetNormalizedCentralMoment</a></h3>
<p class="Blurb">Retrieves normalized central moment from moment state structure</p>
<pre>
double cvGetNormalizedCentralMoment( CvMoments* moments, int x_order, int y_order );
</pre><p><dl>
<dt>moments<dd>Pointer to the moment state structure.
<dt>x_order<dd>x order of the retrieved moment, <code>x_order</code> &gt;= 0.
<dt>y_order<dd>y order of the retrieved moment,
                 <code>y_order</code> &gt;= 0 and <code>x_order</code> + <code>y_order</code> &lt;= 3.
</dl><p>
The function <code>cvGetNormalizedCentralMoment</code>
retrieves the normalized central moment:</p>
<pre>
&eta;<sub>x_order,y_order</sub>= &mu;<sub>x_order,y_order</sub>/M<sub>00</sub><sup>((y_order+x_order)/2+1)</sup>
</pre>


<hr><h3><a name="decl_cvGetHuMoments">GetHuMoments</a></h3>
<p class="Blurb">Calculates seven Hu invariants</p>
<pre>
void cvGetHuMoments( CvMoments* moments, CvHuMoments* hu_moments );
</pre><p><dl>
<dt>moments<dd>Pointer to the moment state structure.
<dt>hu_moments<dd>Pointer to Hu moments structure.
</dl><p>
The function <code>cvGetHuMoments</code> calculates seven Hu invariants that are defined as:
<pre>
 h<sub>1</sub>=&eta;<sub>20</sub>+&eta;<sub>02</sub>

 h<sub>2</sub>=(&eta;<sub>20</sub>-&eta;<sub>02</sub>)&sup2;+4&eta;<sub>11</sub>&sup2;

 h<sub>3</sub>=(&eta;<sub>30</sub>-3&eta;<sub>12</sub>)&sup2;+ (3&eta;<sub>21</sub>-&eta;<sub>03</sub>)&sup2;

 h<sub>4</sub>=(&eta;<sub>30</sub>+&eta;<sub>12</sub>)&sup2;+ (&eta;<sub>21</sub>+&eta;<sub>03</sub>)&sup2;

 h<sub>5</sub>=(&eta;<sub>30</sub>-3&eta;<sub>12</sub>)(&eta;<sub>30</sub>+&eta;<sub>12</sub>)[(&eta;<sub>30</sub>+&eta;<sub>12</sub>)&sup2;-3(&eta;<sub>21</sub>+&eta;<sub>03</sub>)&sup2;]+(3&eta;<sub>21</sub>-&eta;<sub>03</sub>)(&eta;<sub>21</sub>+&eta;<sub>03</sub>)[3(&eta;<sub>30</sub>+&eta;<sub>12</sub>)&sup2;-(&eta;<sub>21</sub>+&eta;<sub>03</sub>)&sup2;]

 h<sub>6</sub>=(&eta;<sub>20</sub>-&eta;<sub>02</sub>)[(&eta;<sub>30</sub>+&eta;<sub>12</sub>)&sup2;- (&eta;<sub>21</sub>+&eta;<sub>03</sub>)&sup2;]+4&eta;<sub>11</sub>(&eta;<sub>30</sub>+&eta;<sub>12</sub>)(&eta;<sub>21</sub>+&eta;<sub>03</sub>)

 h<sub>7</sub>=(3&eta;<sub>21</sub>-&eta;<sub>03</sub>)(&eta;<sub>21</sub>+&eta;<sub>03</sub>)[3(&eta;<sub>30</sub>+&eta;<sub>12</sub>)&sup2;-(&eta;<sub>21</sub>+&eta;<sub>03</sub>)&sup2;]-(&eta;<sub>30</sub>-3&eta;<sub>12</sub>)(&eta;<sub>21</sub>+&eta;<sub>03</sub>)[3(&eta;<sub>30</sub>+&eta;<sub>12</sub>)&sup2;-(&eta;<sub>21</sub>+&eta;<sub>03</sub>)&sup2;]
</pre>
<p>
where <code>&eta;<sub>i,j</sub></code> are normalized central moments of
2-nd and 3-rd orders.
The computed values are proved to be invariant to the image scaling, rotation, and
reflection except the seventh one, whose sign is changed by reflection.
</p>


<hr><h2><a name="cv_imgproc_special">Special Image Transforms</a></h2>

<hr><h3><a name="decl_cvHoughLines2">HoughLines2</a></h3>
<p class="Blurb">Finds lines in binary image using Hough transform</p>
<pre>
CvSeq* cvHoughLines2( CvArr* image, void* line_storage, int method,
                      double rho, double theta, int threshold,
                      double param1=0, double param2=0 );
</pre><p><dl>
<dt>image<dd>The input 8-bit single-channel binary image. In case of probabilistic method the image is
             modified by the function.
<dt>line_storage<dd>The storage for the lines detected. It can be a memory storage (in this case
a sequence of lines is created in the storage and returned by the function) or single row/single column
matrix (CvMat*) of a particular type (see below) to which the lines' parameters are written.
The matrix header is modified by the function so its <code>cols</code> or <code>rows</code> will contain
a number of lines detected. If <code>line_storage</code> is a matrix and the actual number of lines
exceeds the matrix size, the maximum possible number of lines is returned
(in case of standard hough transform the lines are sorted by the accumulator value).
<dt>method<dd>The Hough transform variant, one of:<ul>
    <li><code>CV_HOUGH_STANDARD</code> - classical or standard Hough transform. Every line is represented by two floating-point numbers
         (&rho;, &theta;), where &rho; is a distance between (0,0) point and the line, and &theta; is the angle
         between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will
         be) of CV_32FC2 type.
    <li><code>CV_HOUGH_PROBABILISTIC</code> - probabilistic Hough transform (more efficient in case if picture contains
    a few long linear segments). It returns line segments rather than the whole lines.
    Every segment is represented by starting and ending points, and the matrix must be
    (the created sequence will be) of CV_32SC4 type.
    <li><code>CV_HOUGH_MULTI_SCALE</code> - multi-scale variant of classical Hough transform.
    The lines are encoded the same way as in CV_HOUGH_STANDARD.
    </ul>
<dt>rho<dd>Distance resolution in pixel-related units.
<dt>theta<dd>Angle resolution measured in radians.
<dt>threshold<dd>Threshold parameter. A line is returned by the function if the corresponding
accumulator value is greater than <code>threshold</code>.
<dt>param1<dd>The first method-dependent parameter:<ul>
              <li>For classical Hough transform it is not used (0).
              <li>For probabilistic Hough transform it is the minimum line length.
              <li>For multi-scale Hough transform it is divisor for distance resolution <code>rho</code>.
              (The coarse distance resolution will be <code>rho</code> and the accurate resolution will be (<code>rho</code> / <code>param1</code>)).
              </ul>
<dt>param2<dd>The second method-dependent parameter:<ul>
              <li>For classical Hough transform it is not used (0).
              <li>For probabilistic Hough transform it is the maximum gap between line segments lying on the same line to
                  treat them as the single line segment (i.e. to join them).
              <li>For multi-scale Hough transform it is divisor for angle resolution <code>theta</code>.
              (The coarse angle resolution will be <code>theta</code> and the accurate resolution will be (<code>theta</code> / <code>param2</code>)).
              </ul>
</dl><p>
The function <code>cvHoughLines2</code> implements a few variants of Hough transform for line detection.</p>
<h4>Example. Detecting lines with Hough transform.</h4>
<pre>
/* This is a stand-alone program. Pass an image name as a first parameter of the program.
   Switch between standard and probabilistic Hough transform by changing "#if 1" to "#if 0" and back */
#include &lt;cv.h&gt;
#include &lt;highgui.h&gt;
#include &lt;math.h&gt;

int main(int argc, char** argv)
{
    IplImage* src;
    if( argc == 2 && (src=cvLoadImage(argv[1], 0))!= 0)
    {
        IplImage* dst = cvCreateImage( cvGetSize(src), 8, 1 );
        IplImage* color_dst = cvCreateImage( cvGetSize(src), 8, 3 );
        CvMemStorage* storage = cvCreateMemStorage(0);
        CvSeq* lines = 0;
        int i;
        cvCanny( src, dst, 50, 200, 3 );
        cvCvtColor( dst, color_dst, CV_GRAY2BGR );
#if 1
        lines = cvHoughLines2( dst, storage, CV_HOUGH_STANDARD, 1, CV_PI/180, 100, 0, 0 );

        for( i = 0; i &lt; MIN(lines-&gt;total,100); i++ )
        {
            float* line = (float*)cvGetSeqElem(lines,i);
            float rho = line[0];
            float theta = line[1];
            CvPoint pt1, pt2;
            double a = cos(theta), b = sin(theta);
            double x0 = a*rho, y0 = b*rho;
            pt1.x = cvRound(x0 + 1000*(-b));
            pt1.y = cvRound(y0 + 1000*(a));
            pt2.x = cvRound(x0 - 1000*(-b));
            pt2.y = cvRound(y0 - 1000*(a));
            cvLine( color_dst, pt1, pt2, CV_RGB(255,0,0), 3, 8 );
        }
#else
        lines = cvHoughLines2( dst, storage, CV_HOUGH_PROBABILISTIC, 1, CV_PI/180, 50, 50, 10 );
        for( i = 0; i &lt; lines-&gt;total; i++ )
        {
            CvPoint* line = (CvPoint*)cvGetSeqElem(lines,i);
            cvLine( color_dst, line[0], line[1], CV_RGB(255,0,0), 3, 8 );
        }
#endif
        cvNamedWindow( "Source", 1 );
        cvShowImage( "Source", src );

        cvNamedWindow( "Hough", 1 );
        cvShowImage( "Hough", color_dst );

        cvWaitKey(0);
    }
}
</pre>
<p>This is the sample picture the function parameters have been tuned for:</p>
<p>
<img src="pics/building.jpg" width=320 height=240></a>
</p>
<p>
And this is the output of the above program in case of probabilistic Hough transform ("#if 0" case):
</p>
<p>
<img src="pics/houghp.png" width=320 height=240></a>
</p>


<hr><h3><a name="decl_cvHoughCircles">HoughCircles</a></h3>
<p class="Blurb">Finds circles in grayscale image using Hough transform</p>
<pre>
CvSeq* cvHoughCircles( CvArr* image, void* circle_storage,
                       int method, double dp, double min_dist,
                       double param1=100, double param2=100,
                       int min_radius=0, int max_radius=0 );
</pre><p><dl>
<dt>image<dd>The input 8-bit single-channel grayscale image.
<dt>circle_storage<dd>The storage for the circles detected. It can be a memory storage (in this case
a sequence of circles is created in the storage and returned by the function) or single row/single column
matrix (CvMat*) of type CV_32FC3, to which the circles' parameters are written.
The matrix header is modified by the function so its <code>cols</code> or <code>rows</code> will contain
a number of lines detected. If <code>circle_storage</code> is a matrix and the actual number of lines
exceeds the matrix size, the maximum possible number of circles is returned.
Every circle is encoded as 3 floating-point numbers: center coordinates (x,y) and the radius.
<dt>method<dd>Currently, the only implemented method is <code>CV_HOUGH_GRADIENT</code>, which is basically 21HT, described in
<a href="#paper_yuen03"><b>[Yuen03]</b></a>.
<dt>dp<dd>Resolution of the accumulator used to detect centers of the circles. For example, if it is 1,
the accumulator will have the same resolution as the input image, if it is 2 - accumulator will have twice
smaller width and height, etc.
<dt>min_dist<dd>Minimum distance between centers of the detected circles. If the parameter is too small, multiple
neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed.
<dt>param1<dd>The first method-specific parameter.
 In case of <code>CV_HOUGH_GRADIENT</code> it is the higher threshold of the two passed to Canny edge detector
 (the lower one will be twice smaller).
<dt>param2<dd>The second method-specific parameter.
 In case of <code>CV_HOUGH_GRADIENT</code> it is accumulator threshold at the center detection stage.
 The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator
 values, will be returned first.
<dt>min_radius<dd>Minimal radius of the circles to search for.
<dt>max_radius<dd>Maximal radius of the circles to search for.
 By default the maximal radius is set to <code>max(image_width, image_height)</code>.
</dl><p>
The function <code>cvHoughCircles</code> finds circles in grayscale image using some modification of Hough transform.</p>
<h4>Example. Detecting circles with Hough transform.</h4>
<pre>
#include &lt;cv.h&gt;
#include &lt;highgui.h&gt;
#include &lt;math.h&gt;

int main(int argc, char** argv)
{
    IplImage* img;
    if( argc == 2 && (img=cvLoadImage(argv[1], 1))!= 0)
    {
        IplImage* gray = cvCreateImage( cvGetSize(img), 8, 1 );
        CvMemStorage* storage = cvCreateMemStorage(0);
        cvCvtColor( img, gray, CV_BGR2GRAY );
        cvSmooth( gray, gray, CV_GAUSSIAN, 9, 9 ); // smooth it, otherwise a lot of false circles may be detected
        CvSeq* circles = cvHoughCircles( gray, storage, CV_HOUGH_GRADIENT, 2, gray->height/4, 200, 100 );
        int i;
        for( i = 0; i < circles->total; i++ )
        {
             float* p = (float*)cvGetSeqElem( circles, i );
             cvCircle( img, cvPoint(cvRound(p[0]),cvRound(p[1])), 3, CV_RGB(0,255,0), -1, 8, 0 );
             cvCircle( img, cvPoint(cvRound(p[0]),cvRound(p[1])), cvRound(p[2]), CV_RGB(255,0,0), 3, 8, 0 );
        }
        cvNamedWindow( "circles", 1 );
        cvShowImage( "circles", img );
    }
    return 0;
}
</pre>

<hr><h3><a name="decl_cvDistTransform">DistTransform</a></h3>
<p class="Blurb">Calculates distance to closest zero pixel for all non-zero pixels of source
image</p>
<pre>
void cvDistTransform( const CvArr* src, CvArr* dst, int distance_type=CV_DIST_L2,
                      int mask_size=3, const float* mask=NULL, CvArr* labels=NULL );
</pre><p><dl>
<dt>src<dd>Source 8-bit single-channel (binary) image.
<dt>dst<dd>Output image with calculated distances.
           In most cases it should be 32-bit floating-point, single-channel array of
           the same size as the input image.
           When <code>distance_type</code>==<code>CV_DIST_L1</code>, 8-bit, single-channel
           destination array may be also used (in-place operation is also supported in this case).
<dt>distance_type<dd>Type of distance; can be <code>CV_DIST_L1, CV_DIST_L2, CV_DIST_C</code> or
<code>CV_DIST_USER</code>.
<dt>mask_size<dd>Size of distance transform mask; can be 3, 5 or 0. In case of <code>CV_DIST_L1</code> or
<code>CV_DIST_C</code> the parameter is forced to 3, because 3&times;3 mask gives the same result
as 5&times;5 yet it is faster. When <code>mask_size</code>==0, a different non-approximate algorithm
is used to calculate distances.
<dt>mask<dd>User-defined mask in case of user-defined distance, it consists of 2 numbers
(horizontal/vertical shift cost, diagonal shift cost) in case of 3&times;3 mask and
3 numbers (horizontal/vertical shift cost, diagonal shift cost, knight&#146;s move cost)
in case of 5&times;5 mask.
<dt>labels<dd>The optional output 2d array of labels of integer type
              and the same size as <code>src</code> and <code>dst</code>, can now be used only with
              <code>mask_size</code>==3 or 5.
</dl><p>
The function <code>cvDistTransform</code> calculates the approximated or exact distance from every binary image pixel
to the nearest zero pixel. When <code>mask_size</code>==0, the function uses the accurate algorithm
<a href="#paper_felzenszwalb04">[Felzenszwalb04]</a>. When <code>mask_size</code>==3 or 5, the function
uses the approximate algorithm <a href="#paper_borgefors86">[Borgefors86]</a>.</p><p>Here is how the approximate
algorithm works. For zero pixels the function sets the zero distance. For others it finds
the shortest path to a zero pixel, consisting of basic shifts: horizontal, vertical, diagonal or knight&#146;s move (the
latest is available for 5&times;5 mask). The overall distance is calculated as a sum of these basic distances.
Because the distance function should be symmetric, all the horizontal and vertical shifts must have
the same cost (that is denoted as <code>a</code>), all the diagonal shifts must have the same cost
(denoted <code>b</code>), and all knight&#146;s moves must have the same cost (denoted <code>c</code>).
For <code>CV_DIST_C</code> and <code>CV_DIST_L1</code> types the distance is calculated precisely,
whereas for <code>CV_DIST_L2</code> (Euclidean distance) the distance can be calculated only with
some relative error (5&times;5 mask gives more accurate results), OpenCV uses the values suggested in
<a href="#paper_borgefors86">[Borgefors86]</a>:</p>
<pre>
CV_DIST_C (3&times;3):
a=1, b=1

CV_DIST_L1 (3&times;3):
a=1, b=2

CV_DIST_L2 (3&times;3):
a=0.955, b=1.3693

CV_DIST_L2 (5&times;5):
a=1, b=1.4, c=2.1969
</pre>
<p>
And below are samples of distance field (black (0) pixel is in the middle of white square)
in case of user-defined distance:
</p>
<h4>User-defined 3&times;3 mask (a=1, b=1.5)</h4>
<p>
   <table border=3 cellpadding=5>
   <tr><td>4.5</td><td>4</td><td>3.5</td><td>3</td><td>3.5</td><td>4</td><td>4.5</td></tr>
   <tr><td>4</td><td>3</td><td>2.5</td><td>2</td><td>2.5</td><td>3</td><td>4</td></tr>
   <tr><td>3.5</td><td>2.5</td><td>1.5</td><td>1</td><td>1.5</td><td>2.5</td><td>3.5</td></tr>
   <tr><td>3</td><td>2</td><td>1</td><td>0</td><td>1</td><td>2</td><td>3</td></tr>
   <tr><td>3.5</td><td>2.5</td><td>1.5</td><td>1</td><td>1.5</td><td>2.5</td><td>3.5</td></tr>
   <tr><td>4</td><td>3</td><td>2.5</td><td>2</td><td>2.5</td><td>3</td><td>4</td></tr>
   <tr><td>4.5</td><td>4</td><td>3.5</td><td>3</td><td>3.5</td><td>4</td><td>4.5</td></tr>
   </table>
</p>
<h4>User-defined 5&times;5 mask (a=1, b=1.5, c=2)</h4>
<p>
   <table border=3 cellpadding=5>
   <tr><td>4.5</td><td>3.5</td><td>3</td><td>3</td><td>3</td><td>3.5</td><td>4.5</td></tr>
   <tr><td>3.5</td><td>3</td><td>2</td><td>2</td><td>2</td><td>3</td><td>3.5</td></tr>
   <tr><td>3</td><td>2</td><td>1.5</td><td>1</td><td>1.5</td><td>2</td><td>3</td></tr>
   <tr><td>3</td><td>2</td><td>1</td><td>0</td><td>1</td><td>2</td><td>3</td></tr>
   <tr><td>3</td><td>2</td><td>1.5</td><td>1</td><td>1.5</td><td>2</td><td>3</td></tr>
   <tr><td>3.5</td><td>3</td><td>2</td><td>2</td><td>2</td><td>3</td><td>3.5</td></tr>
   <tr><td>4</td><td>3.5</td><td>3</td><td>3</td><td>3</td><td>3.5</td><td>4</td></tr>
   </table>
</p>

<p>Typically, for fast coarse distance estimation CV_DIST_L2, 3&times;3 mask is used,
and for more accurate distance estimation CV_DIST_L2, 5&times;5 mask is used.</p>

<p>When the output parameter <code>labels</code> is not <code>NULL</code>, for every non-zero pixel
the function also finds the nearest connected component consisting of zero pixels. The connected components
themselves are found as contours in the beginning of the function.</p>
<p>
In this mode the processing time is still O(N), where N is the number of pixels.
Thus, the function provides a very fast way to compute approximate Voronoi diagram for the binary image.</p>


<hr><h3><a name="decl_cvInpaint">Inpaint</a></h3>
<p class="Blurb">Inpaints the selected region in the image</p>
<pre>
void cvInpaint( const CvArr* src, const CvArr* mask, CvArr* dst,
                int flags, double inpaintRadius );
</pre><p><dl>
<dt>src<dd>The input 8-bit 1-channel or 3-channel image.
<dt>mask<dd>The inpainting mask, 8-bit 1-channel image.
           Non-zero pixels indicate the area that needs to be inpainted.
<dt>dst<dd>The output image of the same format and the same size as input.
<dt>flags<dd>The inpainting method, one of the following:<br>
                 <code>CV_INPAINT_NS</code> - Navier-Stokes based method.<br>
                 <code>CV_INPAINT_TELEA</code> - The method by Alexandru Telea <a href="#paper_telea04">[Telea04]</a>
<dt>inpaintRadius<dd>The radius of circular neighborhood of each point inpainted that is considered by the algorithm.
</dl><p>
The function <code>cvInpaint</code> reconstructs the selected image area from the pixel near the
area boundary. The function may be used to remove dust and scratches from a scanned photo, or
to remove undesirable objects from still images or video.</p>


<hr><h2><a name="cv_imgproc_histograms">Histograms</a></h2>

<hr><h3><a name="decl_CvHistogram">CvHistogram</a></h3>
<p class="Blurb">Multi-dimensional histogram</p>
<pre>
typedef struct CvHistogram
{
    int     type;
    CvArr*  bins;
    float   thresh[CV_MAX_DIM][2]; /* for uniform histograms */
    float** thresh2; /* for non-uniform histograms */
    CvMatND mat; /* embedded matrix header for array histograms */
}
CvHistogram;
</pre>

<hr><h3><a name="decl_cvCreateHist">CreateHist</a></h3>
<p class="Blurb">Creates histogram</p>
<pre>
CvHistogram* cvCreateHist( int dims, int* sizes, int type,
                           float** ranges=NULL, int uniform=1 );
</pre><p><dl>
<dt>dims<dd>Number of histogram dimensions.
<dt>sizes<dd>Array of histogram dimension sizes.
<dt>type<dd>Histogram representation format: <code>CV_HIST_ARRAY</code> means that histogram data is
represented as an multi-dimensional dense array <a href="#decl_CvMatND">CvMatND</a>;
<code>CV_HIST_SPARSE</code> means that histogram data is represented
as a multi-dimensional sparse array <a href="#decl_CvSparseMat">CvSparseMat</a>.
<dt>ranges<dd>Array of ranges for histogram bins. Its meaning depends on the <code>uniform</code> parameter value.
The ranges are used for when histogram is calculated or back-projected to determine, which histogram bin
corresponds to which value/tuple of values from the input image[s].
<dt>uniform<dd>Uniformity flag; if not 0, the histogram has evenly spaced bins and
for every <code>0&lt;=i&lt;cDims</code> <code>ranges[i]</code> is array of two numbers: lower and upper
boundaries for the i-th histogram dimension. The whole range [lower,upper] is split then
into <code>dims[i]</code> equal parts to determine <code>i-th</code> input tuple value ranges for every histogram bin.
And if <code>uniform=0</code>, then <code>i-th</code> element of <code>ranges</code> array contains <code>dims[i]+1</code> elements:
<code>lower<sub>0</sub>, upper<sub>0</sub>, lower<sub>1</sub>, upper<sub>1</sub> == lower<sub>2</sub>, ..., upper<sub>dims[i]-1</sub></code>,
where <code>lower<sub>j</sub></code> and <code>upper<sub>j</sub></code> are lower and upper
boundaries of <code>i-th</code> input tuple value for <code>j-th</code> bin, respectively.
In either case, the input values that are beyond the specified range for a histogram bin, are not
counted by <a href="#decl_cvCalcHist">cvCalcHist</a> and filled with 0 by <a href="#decl_cvCalcBackProject">cvCalcBackProject</a>.
</dl><p>
The function <code>cvCreateHist</code> creates a histogram of the specified size and returns
the pointer to the created histogram. If the array <code>ranges</code> is 0, the histogram
bin ranges must be specified later via The function <code>cvSetHistBinRanges</code>, though
<a href="#decl_cvCalcHist">cvCalcHist</a> and <a href="#decl_cvCalcBackProject">cvCalcBackProject</a> may process 8-bit images without setting
bin ranges, they assume equally spaced in 0..255 bins.</p>


<hr><h3><a name="decl_cvSetHistBinRanges">SetHistBinRanges</a></h3>
<p class="Blurb">Sets bounds of histogram bins</p>
<pre>
void cvSetHistBinRanges( CvHistogram* hist, float** ranges, int uniform=1 );
</pre><p><dl>
<dt>hist<dd>Histogram.
<dt>ranges<dd>Array of bin ranges arrays, see <a href="#decl_cvCreateHist">cvCreateHist</a>.
<dt>uniform<dd>Uniformity flag, see <a href="#decl_cvCreateHist">cvCreateHist</a>.
</dl><p>
The function <code>cvSetHistBinRanges</code> is a stand-alone function for setting bin ranges
in the histogram. For more detailed description of the parameters <code>ranges</code> and
<code>uniform</code> see <a href="#decl_cvCalcHist">cvCalcHist</a> function,
that can initialize the ranges as well.
Ranges for histogram bins must be set before the histogram is calculated or
back projection of the histogram is calculated.
</p>


<hr><h3><a name="decl_cvReleaseHist">ReleaseHist</a></h3>
<p class="Blurb">Releases histogram</p>
<pre>
void cvReleaseHist( CvHistogram** hist );
</pre><p><dl>
<dt>hist<dd>Double pointer to the released histogram.
</dl><p>
The function <code>cvReleaseHist</code> releases the histogram (header and the data).
The pointer to histogram is cleared by the function. If <code>*hist</code> pointer is already
<code>NULL</code>, the function does nothing.</p>


<hr><h3><a name="decl_cvClearHist">ClearHist</a></h3>
<p class="Blurb">Clears histogram</p>
<pre>
void cvClearHist( CvHistogram* hist );
</pre><p><dl>
<dt>hist<dd>Histogram.
</dl><p>
The function <code>cvClearHist</code> sets all histogram bins to 0 in case of dense histogram and
removes all histogram bins in case of sparse array.</p>


<hr><h3><a name="decl_cvMakeHistHeaderForArray">MakeHistHeaderForArray</a></h3>
<p class="Blurb">Makes a histogram out of array</p>
<pre>
CvHistogram*  cvMakeHistHeaderForArray( int dims, int* sizes, CvHistogram* hist,
                                        float* data, float** ranges=NULL, int uniform=1 );
</pre><p><dl>
<dt>dims<dd>Number of histogram dimensions.
<dt>sizes<dd>Array of histogram dimension sizes.
<dt>hist<dd>The histogram header initialized by the function.
<dt>data<dd>Array that will be used to store histogram bins.
<dt>ranges<dd>Histogram bin ranges, see <a href="#decl_cvCreateHist">cvCreateHist</a>.
<dt>uniform<dd>Uniformity flag, see <a href="#decl_cvCreateHist">cvCreateHist</a>.
</dl><p>
The function <code>cvMakeHistHeaderForArray</code> initializes the histogram, which header and
bins are allocated by user. No <a href="#decl_cvReleaseHist">cvReleaseHist</a> need to be called afterwards.
Only dense histograms can be initialized this way. The function returns <code>hist</code>.
</p>


<hr><h3><a name="decl_cvQueryHistValue_*D">QueryHistValue_*D</a></h3>
<p class="Blurb">Queries value of histogram bin</p>
<pre>
#define cvQueryHistValue_1D( hist, idx0 ) \
    cvGetReal1D( (hist)->bins, (idx0) )
#define cvQueryHistValue_2D( hist, idx0, idx1 ) \
    cvGetReal2D( (hist)->bins, (idx0), (idx1) )
#define cvQueryHistValue_3D( hist, idx0, idx1, idx2 ) \
    cvGetReal3D( (hist)->bins, (idx0), (idx1), (idx2) )
#define cvQueryHistValue_nD( hist, idx ) \
    cvGetRealND( (hist)->bins, (idx) )
</pre><p><dl>
<dt>hist<dd>Histogram.
<dt>idx0, idx1, idx2, idx3<dd>Indices of the bin.
<dt>idx<dd>Array of indices
</dl><p>
The macros <a href="#decl_cvQueryHistValue_*D">cvQueryHistValue_*D</a> return the value of the specified bin of 1D, 2D, 3D or
N-D histogram. In case of sparse histogram the function returns 0, if the bin is not present in the
histogram, and no new bin is created.
</p>


<hr><h3><a name="decl_cvGetHistValue_*D">GetHistValue_*D</a></h3>
<p class="Blurb">Returns pointer to histogram bin</p>
<pre>
#define cvGetHistValue_1D( hist, idx0 ) \
    ((float*)(cvPtr1D( (hist)->bins, (idx0), 0 ))
#define cvGetHistValue_2D( hist, idx0, idx1 ) \
    ((float*)(cvPtr2D( (hist)->bins, (idx0), (idx1), 0 ))
#define cvGetHistValue_3D( hist, idx0, idx1, idx2 ) \
    ((float*)(cvPtr3D( (hist)->bins, (idx0), (idx1), (idx2), 0 ))
#define cvGetHistValue_nD( hist, idx ) \
    ((float*)(cvPtrND( (hist)->bins, (idx), 0 ))
</pre><p><dl>
<dt>hist<dd>Histogram.
<dt>idx0, idx1, idx2, idx3<dd>Indices of the bin.
<dt>idx<dd>Array of indices
</dl><p>
The macros <a href="#decl_cvGetHistValue_*D">cvGetHistValue_*D</a> return pointer to the specified bin of 1D, 2D, 3D or
N-D histogram. In case of sparse histogram the function creates a new bin and sets it to 0,
unless it exists already.
</p>


<hr><h3><a name="decl_cvGetMinMaxHistValue">GetMinMaxHistValue</a></h3>
<p class="Blurb">Finds minimum and maximum histogram bins</p>
<pre>
void cvGetMinMaxHistValue( const CvHistogram* hist,
                           float* min_value, float* max_value,
                           int* min_idx=NULL, int* max_idx=NULL );
</pre><p><dl>
<dt>hist<dd>Histogram.
<dt>min_value<dd>Pointer to the minimum value of the histogram
<dt>max_value<dd>Pointer to the maximum value of the histogram
<dt>min_idx<dd>Pointer to the array of coordinates for minimum
<dt>max_idx<dd>Pointer to the array of coordinates for maximum
</dl><p>
The function <code>cvGetMinMaxHistValue</code> finds the minimum and maximum histogram bins and
their positions. Any of output arguments is optional.
Among several extremums with the same value the ones with minimum index (in lexicographical order)
In case of several maximums or minimums the earliest in lexicographical order
extrema locations are returned.</p>


<hr><h3><a name="decl_cvNormalizeHist">NormalizeHist</a></h3>
<p class="Blurb">Normalizes histogram</p>
<pre>
void cvNormalizeHist( CvHistogram* hist, double factor );
</pre><p><dl>
<dt>hist<dd>Pointer to the histogram.
<dt>factor<dd>Normalization factor.
</dl><p>
The function <code>cvNormalizeHist</code> normalizes the histogram bins by scaling them,
such that the sum of the bins becomes equal to <code>factor</code>.</p>


<hr><h3><a name="decl_cvThreshHist">ThreshHist</a></h3>
<p class="Blurb">Thresholds histogram</p>
<pre>
void cvThreshHist( CvHistogram* hist, double threshold );
</pre><p><dl>
<dt>hist<dd>Pointer to the histogram.
<dt>threshold<dd>Threshold level.
</dl><p>
The function <code>cvThreshHist</code> clears histogram bins
that are below the specified threshold.</p>


<hr><h3><a name="decl_cvCompareHist">CompareHist</a></h3>
<p class="Blurb">Compares two dense histograms</p>
<pre>
double cvCompareHist( const CvHistogram* hist1, const CvHistogram* hist2, int method );
</pre><p><dl>
<dt>hist1<dd>The first dense histogram.
<dt>hist2<dd>The second dense histogram.
<dt>method<dd>Comparison method, one of:
<ul>
<li>CV_COMP_CORREL
<li>CV_COMP_CHISQR
<li>CV_COMP_INTERSECT
<li>CV_COMP_BHATTACHARYYA
</ul>
</dl><p>
The function <code>cvCompareHist</code> compares two dense histograms using
the specified method as following
(<code>H<sub>1</sub></code> denotes the first histogram, <code>H<sub>2</sub></code> - the second):</p>
<pre>
Correlation (method=CV_COMP_CORREL):
d(H<sub>1</sub>,H<sub>2</sub>)=sum<sub>I</sub>(H'<sub>1</sub>(I)&bull;H'<sub>2</sub>(I))/sqrt(sum<sub>I</sub>[H'<sub>1</sub>(I)<sup>2</sup>]&bull;sum<sub>I</sub>[H'<sub>2</sub>(I)<sup>2</sup>])
where
H'<sub>k</sub>(I)=H<sub>k</sub>(I)-1/N&bull;sum<sub>J</sub>H<sub>k</sub>(J) (N=number of histogram bins)

Chi-Square (method=CV_COMP_CHISQR):
d(H<sub>1</sub>,H<sub>2</sub>)=sum<sub>I</sub>[(H<sub>1</sub>(I)-H<sub>2</sub>(I))/(H<sub>1</sub>(I)+H<sub>2</sub>(I))]

Intersection (method=CV_COMP_INTERSECT):
d(H<sub>1</sub>,H<sub>2</sub>)=sum<sub>I</sub>min(H<sub>1</sub>(I),H<sub>2</sub>(I))

Bhattacharyya distance (method=CV_COMP_BHATTACHARYYA):
d(H<sub>1</sub>,H<sub>2</sub>)=sqrt(1-sum<sub>I</sub>(sqrt(H<sub>1</sub>(I)&bull;H<sub>2</sub>(I))))
</pre>
<p>The function returns <code>d(H<sub>1</sub>,H<sub>2</sub>)</code> value.</p>
<p>Note: the method <code>CV_COMP_BHATTACHARYYA</code> only works with normalized histograms.
<p>To compare sparse histogram or more general sparse configurations of weighted points,
consider using <a href="#decl_cvCalcEMD2">cvCalcEMD2</a> function.</p>


<hr><h3><a name="decl_cvCopyHist">CopyHist</a></h3>
<p class="Blurb">Copies histogram</p>
<pre>
void cvCopyHist( const CvHistogram* src, CvHistogram** dst );
</pre><p><dl>
<dt>src<dd>Source histogram.
<dt>dst<dd>Pointer to destination histogram.
</dl><p>
The function <code>cvCopyHist</code> makes a copy of the histogram. If the second histogram
pointer <code>*dst</code> is NULL, a new histogram of the same size as <code>src</code> is created.
Otherwise, both histograms must have equal types and sizes.
Then the function copies the source histogram bins values to destination histogram and
sets the same bin values ranges as in <code>src</code>.</p>


<hr><h3><a name="decl_cvCalcHist">CalcHist</a></h3>
<p class="Blurb">Calculates histogram of image(s)</p>
<pre>
void cvCalcHist( IplImage** image, CvHistogram* hist,
                 int accumulate=0, const CvArr* mask=NULL );
</pre><p><dl>
<dt>image<dd>Source images (though, you may pass CvMat** as well), all are of the same size and type
<dt>hist<dd>Pointer to the histogram.
<dt>accumulate<dd>Accumulation flag. If it is set, the histogram is not cleared in the beginning.
This feature allows user to compute a single histogram from several images, or to update the histogram online.
<dt>mask<dd>The operation mask, determines what pixels of the source images are counted.
</dl><p>
The function <code>cvCalcHist</code> calculates the histogram of one or more single-channel images.
The elements of a tuple that is used to increment a histogram bin are taken at the same
location from the corresponding input images.</p>
<h4>Sample. Calculating and displaying 2D Hue-Saturation histogram of a color image</h4>
<pre>
#include &lt;cv.h&gt;
#include &lt;highgui.h&gt;

int main( int argc, char** argv )
{
    IplImage* src;
    if( argc == 2 && (src=cvLoadImage(argv[1], 1))!= 0)
    {
        IplImage* h_plane = cvCreateImage( cvGetSize(src), 8, 1 );
        IplImage* s_plane = cvCreateImage( cvGetSize(src), 8, 1 );
        IplImage* v_plane = cvCreateImage( cvGetSize(src), 8, 1 );
        IplImage* planes[] = { h_plane, s_plane };
        IplImage* hsv = cvCreateImage( cvGetSize(src), 8, 3 );
        int h_bins = 30, s_bins = 32;
        int hist_size[] = {h_bins, s_bins};
        float h_ranges[] = { 0, 180 }; /* hue varies from 0 (~0&deg;red) to 180 (~360&deg;red again) */
        float s_ranges[] = { 0, 255 }; /* saturation varies from 0 (black-gray-white) to 255 (pure spectrum color) */
        float* ranges[] = { h_ranges, s_ranges };
        int scale = 10;
        IplImage* hist_img = cvCreateImage( cvSize(h_bins*scale,s_bins*scale), 8, 3 );
        CvHistogram* hist;
        float max_value = 0;
        int h, s;

        cvCvtColor( src, hsv, CV_BGR2HSV );
        cvCvtPixToPlane( hsv, h_plane, s_plane, v_plane, 0 );
        hist = cvCreateHist( 2, hist_size, CV_HIST_ARRAY, ranges, 1 );
        cvCalcHist( planes, hist, 0, 0 );
        cvGetMinMaxHistValue( hist, 0, &max_value, 0, 0 );
        cvZero( hist_img );

        for( h = 0; h &lt; h_bins; h++ )
        {
            for( s = 0; s &lt; s_bins; s++ )
            {
                float bin_val = cvQueryHistValue_2D( hist, h, s );
                int intensity = cvRound(bin_val*255/max_value);
                cvRectangle( hist_img, cvPoint( h*scale, s*scale ),
                             cvPoint( (h+1)*scale - 1, (s+1)*scale - 1),
                             CV_RGB(intensity,intensity,intensity), /* draw a grayscale histogram.
                                                                       if you have idea how to do it
                                                                       nicer let us know */
                             CV_FILLED );
            }
        }

        cvNamedWindow( "Source", 1 );
        cvShowImage( "Source", src );

        cvNamedWindow( "H-S Histogram", 1 );
        cvShowImage( "H-S Histogram", hist_img );

        cvWaitKey(0);
    }
}
</pre>


<hr><h3><a name="decl_cvCalcBackProject">CalcBackProject</a></h3>
<p class="Blurb">Calculates back projection</p>
<pre>
void cvCalcBackProject( IplImage** image, CvArr* back_project, const CvHistogram* hist );
</pre><p><dl>
<dt>image<dd>Source images (though you may pass CvMat** as well), all are of the same size and type
<dt>back_project<dd>Destination back projection image of the same type as the source images.
<dt>hist<dd>Histogram.
</dl><p>
The function <code>cvCalcBackProject</code> calculates the back project of the histogram. For
each tuple of pixels at the same position of all input single-channel
images the function puts the value of the histogram bin, corresponding to the tuple,
to the destination image. In terms of statistics, the value of each output image pixel
is probability of the observed tuple given the distribution (histogram).
For example, to find a red object in the picture, one may do the following:
<ol>
<li>Calculate a hue histogram for the red object assuming the image contains only
  this object. The histogram is likely to have a strong maximum, corresponding
  to red color.
<li>Calculate back projection of a hue plane of input image where the object is searched,
    using the histogram. Threshold the image.
<li>Find connected components in the resulting picture and choose the right
  component using some additional criteria, for example, the largest connected
  component.
</ol>
That is the approximate algorithm of CamShift color object tracker, except for the 3rd step,
instead of which CAMSHIFT algorithm is used to locate the object on the back projection given
the previous object position.
</p>

<hr><h3><a name="decl_cvCalcBackProjectPatch">CalcBackProjectPatch</a></h3>
<p class="Blurb">Locates a template within image by histogram comparison</p>
<pre>
void cvCalcBackProjectPatch( IplImage** images, CvArr* dst,
                             CvSize patch_size, CvHistogram* hist,
                             int method, float factor );
</pre><p><dl>
<dt>images<dd>Source images (though, you may pass CvMat** as well), all of the same size
<dt>dst<dd>Destination image.
<dt>patch_size<dd>Size of patch slid though the source images.
<dt>hist<dd>Histogram
<dt>method<dd>Comparison method, passed to <a href="#decl_cvCompareHist">cvCompareHist</a> (see description of that function).
<dt>factor<dd>Normalization factor for histograms,
    will affect normalization scale of destination image, pass 1. if unsure.
</dl><p>
The function <code>cvCalcBackProjectPatch</code> compares histogram, computed over
each possible rectangular patch of the specified size in the input <code>images</code>,
and stores the results to the output map <code>dst</code>.</p>
<p>
In pseudo-code the operation may be written as:
<pre>
for (x,y) in images (until (x+patch_size.width-1,y+patch_size.height-1) is inside the images) do
    compute histogram over the ROI (x,y,x+patch_size.width,y+patch_size.height) in images
       (see cvCalcHist)
    normalize the histogram using the factor
       (see cvNormalizeHist)
    compare the normalized histogram with input histogram hist using the specified method
       (see cvCompareHist)
    store the result to dst(x,y)
end for
</pre>

See also a similar function <a href="#decl_cvMatchTemplate">cvMatchTemplate</a>.
</p>
<h4>Back Project Calculation by Patches</h4>
<p>
<image align="center" src="pics/backprojectpatch.png">
</p>


<hr><h3><a name="decl_cvCalcProbDensity">CalcProbDensity</a></h3>
<p class="Blurb">Divides one histogram by another</p>
<pre>
void  cvCalcProbDensity( const CvHistogram* hist1, const CvHistogram* hist2,
                         CvHistogram* dst_hist, double scale=255 );
</pre><p><dl>
<dt>hist1<dd>first histogram (the divisor).
<dt>hist2<dd>second histogram.
<dt>dst_hist<dd>destination histogram.
<dt>scale<dd>scale factor for the destination histogram.
</dl></p><p>
The function <code>cvCalcProbDensity</code> calculates the object probability density from
the two histograms as:</p>
<pre>
dist_hist(I)=0      if hist1(I)==0
             scale  if hist1(I)!=0 && hist2(I)&gt;hist1(I)
             hist2(I)*scale/hist1(I) if hist1(I)!=0 && hist2(I)&lt;=hist1(I)
</pre>
<p>
So the destination histogram bins are within less than scale.
</p>


<hr><h3><a name="decl_cvEqualizeHist">EqualizeHist</a></h3>
<p class="Blurb">Equalizes histogram of grayscale image</p>
<pre>
void  cvEqualizeHist( const CvArr* src, CvArr* dst );
</pre><p><dl>
<dt>src<dd>The input 8-bit single-channel image.
<dt>dst<dd>The output image of the same size and the same data type as <code>src</code>.
</dl></p><p>
The function <code>cvEqualizeHist</code> equalizes histogram of the input image
using the following algorithm:</p>
<pre>
1. calculate histogram H for src.
2. normalize histogram, so that the sum of histogram bins is 255.
3. compute integral of the histogram:
   H&#146;(i) = sum<sub>0&le;j&le;i</sub>H(j)
4. transform the image using H&#146; as a look-up table: dst(x,y)=H&#146;(src(x,y))
</pre>
<p>The algorithm normalizes brightness and increases contrast of the image.</p>


<hr><h2><a name="cv_imgproc_matching">Matching</a></h2>

<hr><h3><a name="decl_cvMatchTemplate">MatchTemplate</a></h3>
<p class="Blurb">Compares template against overlapped image regions</p>
<pre>
void cvMatchTemplate( const CvArr* image, const CvArr* templ,
                      CvArr* result, int method );
</pre><p><dl>
<dt>image<dd>Image where the search is running.
           It should be 8-bit or 32-bit floating-point.
<dt>templ<dd>Searched template; must be not greater than the source image and the same data type as the image.
<dt>result<dd>A map of comparison results; single-channel 32-bit floating-point. If <code>image</code> is
<code>W</code>&times;<code>H</code> and <code>templ</code> is <code>w</code>&times;<code>h</code> then <code>result</code> must
be <code>W-w+1</code>&times;<code>H-h+1</code>.
<dt>method<dd>Specifies the way the template must be compared with image regions (see below).
</dl><p>
The function <code>cvMatchTemplate</code> is similar to <a href="#decl_cvCalcBackProjectPatch">cvCalcBackProjectPatch</a>.
It slides through <code>image</code>, compares overlapped patches of size <code>w</code>&times;<code>h</code>
with <code>templ</code> using the specified method and stores the comparison results
to <code>result</code>. Here are the formulae for the different comparison methods one may use
(<code>I</code> denotes image, <code>T</code> - template, <code>R</code> - result.
The summation is done over template and/or the image patch: <code>x'=0..w-1, y'=0..h-1</code>):</p>
<pre>
method=CV_TM_SQDIFF:
R(x,y)=sum<sub>x',y'</sub>[T(x',y')-I(x+x',y+y')]<sup>2</sup>

method=CV_TM_SQDIFF_NORMED:
R(x,y)=sum<sub>x',y'</sub>[T(x',y')-I(x+x',y+y')]<sup>2</sup>/sqrt[sum<sub>x',y'</sub>T(x',y')<sup>2</sup>&bull;sum<sub>x',y'</sub>I(x+x',y+y')<sup>2</sup>]

method=CV_TM_CCORR:
R(x,y)=sum<sub>x',y'</sub>[T(x',y')&bull;I(x+x',y+y')]

method=CV_TM_CCORR_NORMED:
R(x,y)=sum<sub>x',y'</sub>[T(x',y')&bull;I(x+x',y+y')]/sqrt[sum<sub>x',y'</sub>T(x',y')<sup>2</sup>&bull;sum<sub>x',y'</sub>I(x+x',y+y')<sup>2</sup>]

method=CV_TM_CCOEFF:
R(x,y)=sum<sub>x',y'</sub>[T'(x',y')&bull;I'(x+x',y+y')],

where T'(x',y')=T(x',y') - 1/(w&bull;h)&bull;sum<sub>x",y"</sub>T(x",y")
      I'(x+x',y+y')=I(x+x',y+y') - 1/(w&bull;h)&bull;sum<sub>x",y"</sub>I(x+x",y+y")

method=CV_TM_CCOEFF_NORMED:
R(x,y)=sum<sub>x',y'</sub>[T'(x',y')&bull;I'(x+x',y+y')]/sqrt[sum<sub>x',y'</sub>T'(x',y')<sup>2</sup>&bull;sum<sub>x',y'</sub>I'(x+x',y+y')<sup>2</sup>]

</pre>
After the function finishes comparison, the best matches can be found as global minimums (CV_TM_SQDIFF*)
or maximums (CV_TM_CCORR* and CV_TM_CCOEFF*) using <a href="opencvref_cxcore.htm#decl_cvMinMaxLoc">cvMinMaxLoc</a> function.
In case of color image and template summation in both numerator and each sum in denominator is done
over all the channels (and separate mean values are used for each channel).
</p>


<hr><h3><a name="decl_cvMatchShapes">MatchShapes</a></h3>
<p class="Blurb">Compares two shapes</p>
<pre>
double cvMatchShapes( const void* object1, const void* object2,
                      int method, double parameter=0 );
</pre><p><dl>
<dt>object1<dd>First contour or grayscale image
<dt>object2<dd>Second contour or grayscale image
<dt>method<dd>Comparison method, one of CV_CONTOUR_MATCH_I1, CV_CONTOURS_MATCH_I2 or CV_CONTOURS_MATCH_I3.
<dt>parameter<dd>Method-specific parameter (is not used now).
</dl><p>
The function <code>cvMatchShapes</code> compares two shapes. The 3 implemented methods all
use Hu moments (see <a href="#decl_cvGetHuMoments">cvGetHuMoments</a>)
(<code>A</code> ~ <code>object1</code>, <code>B</code> - <code>object2</code>):</p>
<pre>
method=CV_CONTOUR_MATCH_I1:
I<sub>1</sub>(A,B)=sum<sub>i=1..7</sub>abs(1/m<sup>A</sup><sub>i</sub> - 1/m<sup>B</sup><sub>i</sub>)

method=CV_CONTOUR_MATCH_I2:
I<sub>2</sub>(A,B)=sum<sub>i=1..7</sub>abs(m<sup>A</sup><sub>i</sub> - m<sup>B</sup><sub>i</sub>)

method=CV_CONTOUR_MATCH_I3:
I<sub>3</sub>(A,B)=sum<sub>i=1..7</sub>abs(m<sup>A</sup><sub>i</sub> - m<sup>B</sup><sub>i</sub>)/abs(m<sup>A</sup><sub>i</sub>)

where
m<sup>A</sup><sub>i</sub>=sign(h<sup>A</sup><sub>i</sub>)&bull;log(h<sup>A</sup><sub>i</sub>),
m<sup>B</sup><sub>i</sub>=sign(h<sup>B</sup><sub>i</sub>)&bull;log(h<sup>B</sup><sub>i</sub>),
h<sup>A</sup><sub>i</sub>, h<sup>B</sup><sub>i</sub> - Hu moments of A and B, respectively.
</pre>


<hr><h3><a name="decl_cvCalcEMD2">CalcEMD2</a></h3>
<p class="Blurb">Computes "minimal work" distance between two weighted point configurations</p>
<pre>
float cvCalcEMD2( const CvArr* signature1, const CvArr* signature2, int distance_type,
                  CvDistanceFunction distance_func=NULL, const CvArr* cost_matrix=NULL,
                  CvArr* flow=NULL, float* lower_bound=NULL, void* userdata=NULL );
typedef float (*CvDistanceFunction)(const float* f1, const float* f2, void* userdata);
</pre><p><dl>
<dt>signature1<dd>First signature, <code>size1</code>&times;<code>dims+1</code> floating-point matrix.
    Each row stores the point weight followed by the point coordinates. The matrix is allowed to
    have a single column (weights only) if the user-defined cost matrix is used.
<dt>signature2<dd>Second signature of the same format as <code>signature1</code>, though the number
    of rows may be different. The total weights may be different, in this case an extra "dummy" point
    is added to either <code>signature1</code> or <code>signature2</code>.
<dt>distance_type<dd>Metrics used; <code>CV_DIST_L1, CV_DIST_L2</code>, and <code>CV_DIST_C</code> stand for one of
the standard metrics; <code>CV_DIST_USER</code> means that a user-defined function <code>distance_func</code> or
pre-calculated <code>cost_matrix</code> is used.
<dt>distance_func<dd>The user-defined distance function.
                It takes coordinates of two points and returns the distance between the points.
<dt>cost_matrix<dd>The user-defined <code>size1</code>&times;<code>size2</code> cost matrix.
                  At least one of <code>cost_matrix</code> and <code>distance_func</code> must be NULL.
                  Also, if a cost matrix is used, lower boundary (see below) can not be calculated,
                  because it needs a metric function.
<dt>flow<dd>The resultant <code>size1</code>&times;<code>size2</code> flow matrix: <code>flow<sub>ij</sub></code> is a flow
            from i-th point of <code>signature1</code> to j-th point of <code>signature2</code>
<dt>lower_bound<dd>Optional input/output parameter: lower boundary of distance between the two signatures that
                  is a distance between mass centers. The lower boundary may not be calculated if
                  the user-defined cost matrix is used, the total weights of point configurations are
                  not equal, or there is the signatures consist of weights only
                  (i.e. the signature matrices have a single column).
                  User <em>must</em> initialize <code>*lower_bound</code>.
                  If the calculated distance between mass centers is greater or equal to <code>*lower_bound</code>
                  (it means that the signatures are far enough) the function does not calculate EMD.
                  In any case <code>*lower_bound</code> is set to the calculated distance between mass centers
                  on return. Thus, if user wants to calculate both distance between mass centers and EMD,
                  <code>*lower_bound</code> should be set to 0.
<dt>userdata<dd>Pointer to optional data that is passed into the user-defined distance function.
</dl><p>
The function <code>cvCalcEMD2</code> computes earth mover distance and/or a lower boundary of
the distance between the two weighted point configurations.
One of the application described in <a href="#paper_rubnersept98">[RubnerSept98]</a> is multi-dimensional
histogram comparison for image retrieval.
EMD is a transportation problem that is solved using some modification of simplex algorithm,
thus the complexity is exponential in the worst case, though, it is much faster in average.
In case of a real metric the lower boundary can be calculated even faster (using linear-time algorithm)
and it can be used to determine roughly whether the two
signatures are far enough so that they cannot relate to the same object.
</p>

<hr><h1><a name="cv_sa">Structural Analysis</a></h1>

<hr><h2><a name="cv_sa_contours">Contour Processing Functions</a></h2>

<hr><h3><a name="decl_cvApproxChains">ApproxChains</a></h3>
<p class="Blurb">Approximates Freeman chain(s) with polygonal curve</p>
<pre>
CvSeq* cvApproxChains( CvSeq* src_seq, CvMemStorage* storage,
                       int method=CV_CHAIN_APPROX_SIMPLE,
                       double parameter=0, int minimal_perimeter=0, int recursive=0 );
</pre><p><dl>
<dt>src_seq<dd>Pointer to the chain that can refer to other chains.
<dt>storage<dd>Storage location for the resulting polylines.
<dt>method<dd>Approximation method (see the description of the function
<a href="#decl_cvFindContours">cvFindContours</a>).
<dt>parameter<dd>Method parameter (not used now).
<dt>minimal_perimeter<dd>Approximates only those contours whose perimeters are not less
than <code>minimal_perimeter</code>. Other chains are removed from the resulting structure.
<dt>recursive<dd>If not 0, the function approximates all chains that access can be
obtained to from <code>src_seq</code> by <code>h_next</code> or <code>v_next links</code>. If 0, the single chain is
approximated.
</dl><p>
This is a stand-alone approximation routine. The function <code>cvApproxChains</code> works
exactly in the same way as <a href="#decl_cvFindContours">cvFindContours</a> with the corresponding approximation flag.
The function returns pointer to the first resultant contour.
Other approximated contours, if any, can be accessed via <code>v_next</code> or
<code>h_next</code> fields of the returned structure.
</p>


<hr><h3><a name="decl_cvStartReadChainPoints">StartReadChainPoints</a></h3>
<p class="Blurb">Initializes chain reader</p>
<pre>
void cvStartReadChainPoints( CvChain* chain, CvChainPtReader* reader );
</pre><p><dl>
chain Pointer to chain.
reader Chain reader state.
</dl><p>
The function <code>cvStartReadChainPoints</code> initializes a special reader
(see <a href="opencvref_cxcore.htm#cxcore_ds">Dynamic Data Structures</a>
for more information on sets and sequences).
</p>


<hr><h3><a name="decl_cvReadChainPoint">ReadChainPoint</a></h3>
<p class="Blurb">Gets next chain point</p>
<pre>
CvPoint cvReadChainPoint( CvChainPtReader* reader );
</pre><p><dl>
<dt>reader<dd>Chain reader state.
</dl><p>
The function <code>cvReadChainPoint</code> returns the current chain point and updates the reader position.</p>


<hr><h3><a name="decl_cvApproxPoly">ApproxPoly</a></h3>
<p class="Blurb">Approximates polygonal curve(s) with desired precision</p>
<pre>
CvSeq* cvApproxPoly( const void* src_seq, int header_size, CvMemStorage* storage,
                     int method, double parameter, int parameter2=0 );
</pre><p><dl>
<dt>src_seq<dd>Sequence of array of points.
<dt>header_size<dd>Header size of approximated curve[s].
<dt>storage<dd>Container for approximated contours. If it is NULL, the input sequences' storage is used.
<dt>method<dd>Approximation method; only <code>CV_POLY_APPROX_DP</code> is supported, that
corresponds to Douglas-Peucker algorithm.
<dt>parameter<dd>Method-specific parameter; in case of <code>CV_POLY_APPROX_DP</code> it is a desired approximation accuracy.
<dt>parameter2<dd>If case if <code>src_seq</code> is sequence it means whether the single sequence should
be approximated or all sequences on the same level or below <code>src_seq</code> (see <a href="#decl_cvFindContours">cvFindContours</a> for
description of hierarchical contour structures). And if <code>src_seq</code> is array (<a href="#decl_CvMat">CvMat</a>*) of
points, the parameter specifies whether the curve is closed (<code>parameter2</code>!=0) or
not (<code>parameter2</code>=0).
</dl><p>
The function <code>cvApproxPoly</code> approximates one or more curves and returns the approximation
result[s]. In case of multiple curves approximation the resultant tree will have the same structure as
the input one (1:1 correspondence).
</p>


<hr><h3><a name="decl_cvBoundingRect">BoundingRect</a></h3>
<p class="Blurb">Calculates up-right bounding rectangle of point set</p>
<pre>
CvRect cvBoundingRect( CvArr* points, int update=0 );
</pre><p><dl>
<dt>points<dd>Either a 2D point set, represented as a sequence (<code>CvSeq*</code>, <code>CvContour*</code>)
  or vector (<code>CvMat*</code>) of points,
  or 8-bit single-channel mask image (<code>CvMat*</code>, <code>IplImage*</code>),
  in which non-zero pixels are considered.
<dt>update<dd>The update flag. Here is list of possible combination of the flag values and type of <code>contour</code>:
<ul>
<li><code>points</code> is CvContour*, <code>update</code>=0: the bounding rectangle is not calculated, but it is read from <code>rect</code> field of the contour header.
<li><code>points</code> is CvContour*, <code>update</code>=1: the bounding rectangle is calculated and written to <code>rect</code> field of the contour header.
For example, this mode is used by <a href="#decl_cvFindContours">cvFindContours</a>.
<li><code>points</code> is CvSeq* or CvMat*: <code>update</code> is ignored,
the bounding rectangle is calculated and returned.
</ul></dl><p>
The function <code>cvBoundingRect</code> returns the up-right bounding rectangle for 2d point set.
</p>


<hr><h3><a name="decl_cvContourArea">ContourArea</a></h3>
<p class="Blurb">Calculates area of the whole contour or contour section</p>
<pre>
double cvContourArea( const CvArr* contour, CvSlice slice=CV_WHOLE_SEQ );
</pre><p><dl>
<dt>contour<dd>Contour (sequence or array of vertices).
<dt>slice<dd>Starting and ending points of the contour section of interest, by default area of the whole
contour is calculated.
</dl><p>
The function <code>cvContourArea</code> calculates area of the whole contour or contour section. In the latter
case the total area bounded by the contour arc and the chord connecting the 2 selected points is calculated as
shown on the picture below:</p>
<p>
<p>
<img align="center" src="pics/contoursecarea.png" width=150 height=150 >
</p>
<p><b>NOTE:</b> Orientation of the contour affects the area sign, thus the function may return
<code>negative</code> result. Use <code>fabs()</code> function from C runtime to get the absolute value of
area.</p>


<hr><h3><a name="decl_cvArcLength">ArcLength</a></h3>
<p class="Blurb">Calculates contour perimeter or curve length</p>
<pre>
double cvArcLength( const void* curve, CvSlice slice=CV_WHOLE_SEQ, int is_closed=-1 );
</pre><p><dl>
<dt>curve<dd>Sequence or array of the curve points.
<dt>slice<dd>Starting and ending points of the curve, by default the whole curve length is
calculated.
<dt>is_closed<dd>Indicates whether the curve is closed or not. There are 3 cases:<ul>
                <li>is_closed=0 - the curve is assumed to be unclosed.
                <li>is_closed&gt;0 - the curve is assumed to be closed.
                <li>is_closed&lt;0 - if curve is sequence, the flag CV_SEQ_FLAG_CLOSED of
                    ((CvSeq*)curve)->flags is checked to determine if the curve is closed or not,
                     otherwise (curve is represented by array (CvMat*) of points) it is assumed
                     to be unclosed.
</ul>
</dl><p>
The function <code>cvArcLength</code> calculates length or curve as sum of lengths of segments
between subsequent points</p>

<hr><h3><a name="decl_cvCreateContourTree">CreateContourTree</a></h3>
<p class="Blurb">Creates hierarchical representation of contour</p>
<pre>
CvContourTree* cvCreateContourTree( const CvSeq* contour, CvMemStorage* storage, double threshold );
</pre><p><dl>
<dt>contour<dd>Input contour.
<dt>storage<dd>Container for output tree.
<dt>threshold<dd>Approximation accuracy.
</dl><p>
The function <code>cvCreateContourTree</code> creates binary tree representation for the input
<code>contour</code> and returns the pointer to its root. If the parameter <code>threshold</code>
is less than or equal to 0, the function creates full binary tree
representation. If the threshold is greater than 0, the function creates
representation with the precision <code>threshold</code>: if the vertices with the
interceptive area of its base line are less than <code>threshold</code>, the tree should not
be built any further. The function returns the created tree.
</p>


<hr><h3><a name="decl_cvContourFromContourTree">ContourFromContourTree</a></h3>
<p class="Blurb">Restores contour from tree</p>
<pre>
CvSeq* cvContourFromContourTree( const CvContourTree* tree, CvMemStorage* storage,
                                 CvTermCriteria criteria );
</pre><p><dl>
<dt>tree<dd>Contour tree.
<dt>storage<dd>Container for the reconstructed contour.
<dt>criteria<dd>Criteria, where to stop reconstruction.
</dl><p>
The function <code>cvContourFromContourTree</code> restores the contour from its binary tree
representation. The parameter <code>criteria</code> determines the accuracy and/or the
number of tree levels used for reconstruction, so it is possible to build approximated contour.
The function returns reconstructed contour.
</p>


<hr><h3><a name="decl_cvMatchContourTrees">MatchContourTrees</a></h3>
<p class="Blurb">Compares two contours using their tree representations</p>
<pre>
double cvMatchContourTrees( const CvContourTree* tree1, const CvContourTree* tree2,
                            int method, double threshold );
</pre><p><dl>
<dt>tree1<dd>First contour tree.
<dt>tree2<dd>Second contour tree.
<dt>method<dd>Similarity measure, only <code>CV_CONTOUR_TREES_MATCH_I1</code> is supported.
<dt>threshold<dd>Similarity threshold.
</dl><p>
The function <code>cvMatchContourTrees</code> calculates the value of the matching measure for
two contour trees. The similarity measure is calculated level by level from the
binary tree roots. If at the certain level difference between contours becomes less than <code>threshold</code>,
the reconstruction process is interrupted and the current difference is returned.
</p>


<hr><h2><a name="cv_sa_compgeom">Computational Geometry</a></h2>


<hr><h3><a name="decl_cvMaxRect">MaxRect</a></h3>
<p class="Blurb">Finds bounding rectangle for two given rectangles</p>
<pre>
CvRect cvMaxRect( const CvRect* rect1, const CvRect* rect2 );
</pre><p><dl>
<dt>rect1<dd>First rectangle
<dt>rect2<dd>Second rectangle
</dl></p><p>
The function <code>cvMaxRect</code> finds minimum area rectangle that contains both input rectangles inside:</p>
<p>
<img align="center" src="pics/maxrect.png">
</p>


<hr><h3><a name="decl_CvBox2D">CvBox2D</a></h3>
<p class="Blurb">Rotated 2D box</p>
<pre>
typedef struct CvBox2D
{
    CvPoint2D32f center;  /* center of the box */
    CvSize2D32f  size;    /* box width and length */
    float angle;          /* angle between the horizontal axis
                             and the first side (i.e. length) in degrees */
}
CvBox2D;
</pre>


<hr><h3><a name="decl_cvPointSeqFromMat">PointSeqFromMat</a></h3>
<p class="Blurb">Initializes point sequence header from a point vector</p>
<pre>
CvSeq* cvPointSeqFromMat( int seq_kind, const CvArr* mat,
                          CvContour* contour_header,
                          CvSeqBlock* block );
</pre><p><dl>
<dt>seq_kind<dd>Type of the point sequence: point set (0), a curve (<code>CV_SEQ_KIND_CURVE</code>),
                closed curve (<code>CV_SEQ_KIND_CURVE+CV_SEQ_FLAG_CLOSED</code>) etc.
<dt>mat<dd>Input matrix. It should be continuous 1-dimensional vector of points, that is, it should have
type <code>CV_32SC2</code> or <code>CV_32FC2</code>.
<dt>contour_header<dd>Contour header, initialized by the function.
<dt>block<dd>Sequence block header, initialized by the function.
</dl></p><p>
The function <code>cvPointSeqFromMat</code> initializes sequence header to create a "virtual" sequence which
elements reside in the specified matrix. No data is copied. The initialized sequence header may be passed to
any function that takes a point sequence on input. No extra elements could be added to the sequence,
but some may be removed. The function is a specialized variant of
<a href="opencvref_cxcore.htm#decl_cvMakeSeqHeaderForArray">cvMakeSeqHeaderForArray</a> and uses the latter internally.
It returns pointer to the initialized contour header. Note that the bounding rectangle (field <code>rect</code> of
<code>CvContour</code> structure is not initialized by the function. If you need one, use
<a href="#decl_cvBoundingRect">cvBoundingRect</a>.
<p>Here is the simple usage example.</p>
<pre>
CvContour header;
CvSeqBlock block;
CvMat* vector = cvCreateMat( 1, 3, CV_32SC2 );

CV_MAT_ELEM( *vector, CvPoint, 0, 0 ) = cvPoint(100,100);
CV_MAT_ELEM( *vector, CvPoint, 0, 1 ) = cvPoint(100,200);
CV_MAT_ELEM( *vector, CvPoint, 0, 2 ) = cvPoint(200,100);

IplImage* img = cvCreateImage( cvSize(300,300), 8, 3 );
cvZero(img);

cvDrawContours( img, cvPointSeqFromMat(CV_SEQ_KIND_CURVE+CV_SEQ_FLAG_CLOSED,
   vector, &amp;header, &amp;block), CV_RGB(255,0,0), CV_RGB(255,0,0), 0, 3, 8, cvPoint(0,0));
</pre>


<hr><h3><a name="decl_cvBoxPoints">BoxPoints</a></h3>
<p class="Blurb">Finds box vertices</p>
<pre>
void cvBoxPoints( CvBox2D box, CvPoint2D32f pt[4] );
</pre><p><dl>
<dt>box<dd>Box
<dt>pt<dd>Array of vertices
</dl></p><p>
The function <code>cvBoxPoints</code> calculates vertices of the input 2d box.
Here is the function code:</p>
<pre>
void cvBoxPoints( CvBox2D box, CvPoint2D32f pt[4] )
{
    double angle = box.angle*CV_PI/180.
    float a = (float)cos(angle)*0.5f;
    float b = (float)sin(angle)*0.5f;

    pt[0].x = box.center.x - a*box.size.height - b*box.size.width;
    pt[0].y = box.center.y + b*box.size.height - a*box.size.width;
    pt[1].x = box.center.x + a*box.size.height - b*box.size.width;
    pt[1].y = box.center.y - b*box.size.height - a*box.size.width;
    pt[2].x = 2*box.center.x - pt[0].x;
    pt[2].y = 2*box.center.y - pt[0].y;
    pt[3].x = 2*box.center.x - pt[1].x;
    pt[3].y = 2*box.center.y - pt[1].y;
}
</pre>


<hr><h3><a name="decl_cvFitEllipse">FitEllipse</a></h3>
<p class="Blurb">Fits ellipse to set of 2D points</p>
<pre>
CvBox2D cvFitEllipse2( const CvArr* points );
</pre><p><dl>
<dt>points<dd>Sequence or array of points.
</dl><p>
The function <code>cvFitEllipse</code> calculates ellipse that fits best (in least-squares sense)
to a set of 2D points. The meaning of the returned structure fields is similar to those
in <a href="#decl_cvEllipse">cvEllipse</a> except that <code>size</code> stores the full lengths of the ellipse axises,
not half-lengths</p>


<hr><h3><a name="decl_cvFitLine2D">FitLine</a></h3>
<p class="Blurb">Fits line to 2D or 3D point set</p>
<pre>
void  cvFitLine( const CvArr* points, int dist_type, double param,
                 double reps, double aeps, float* line );
</pre><p><dl>
<dt>points<dd>Sequence or array of 2D or 3D points with 32-bit integer or floating-point coordinates.
<dt>dist_type<dd>The distance used for fitting (see the discussion).
<dt>param<dd>Numerical parameter (<code>C</code>) for some types of distances, if 0 then some optimal value is chosen.
<dt>reps, aeps<dd>Sufficient accuracy for radius (distance between the coordinate origin and the line)
and angle, respectively, 0.01 would be a good defaults for both.
<dt>line<dd>The output line parameters. In case of 2d fitting it is array of 4 floats <code>(vx, vy, x0, y0)</code>
where <code>(vx, vy)</code> is a normalized vector collinear to the line and <code>(x0, y0)</code> is some point on the line.
In case of 3D fitting it is array of 6 floats <code>(vx, vy, vz, x0, y0, z0)</code>
where <code>(vx, vy, vz)</code> is a normalized vector collinear to the line and <code>(x0, y0, z0)</code> is some point on the line.
</dl><p>
The function <code>cvFitLine</code> fits line to 2D or 3D point set by minimizing sum<sub>i</sub>&rho;(r<sub>i</sub>),
where r<sub>i</sub> is distance between i-th point and the line and &rho;(r) is a distance function, one of:</p>
<pre>
dist_type=CV_DIST_L2 (L<sub>2</sub>):
&rho;(r)=r<sup>2</sup>/2 (the simplest and the fastest least-squares method)

dist_type=CV_DIST_L1 (L<sub>1</sub>):
&rho;(r)=r

dist_type=CV_DIST_L12 (L<sub>1</sub>-L<sub>2</sub>):
&rho;(r)=2&bull;[sqrt(1+r<sup>2</sup>/2) - 1]

dist_type=CV_DIST_FAIR (Fair):
&rho;(r)=C<sup>2</sup>&bull;[r/C - log(1 + r/C)],  C=1.3998

dist_type=CV_DIST_WELSCH (Welsch):
&rho;(r)=C<sup>2</sup>/2&bull;[1 - exp(-(r/C)<sup>2</sup>)],  C=2.9846

dist_type=CV_DIST_HUBER (Huber):
&rho;(r)= r<sup>2</sup>/2,   if r &lt; C
      C&bull;(r-C/2),   otherwise;   C=1.345

</pre>

<hr><h3><a name="decl_cvConvexHull2">ConvexHull2</a></h3>
<p class="Blurb">Finds convex hull of point set</p>
<pre>
CvSeq* cvConvexHull2( const CvArr* input, void* hull_storage=NULL,
                      int orientation=CV_CLOCKWISE, int return_points=0 );
</pre><p><dl>
<dt>points<dd>Sequence or array of 2D points with 32-bit integer or floating-point coordinates.
<dt>hull_storage<dd>The destination array (CvMat*) or memory storage (CvMemStorage*) that will store the convex hull.
                   If it is array, it should be 1d and have the same number of elements as the input array/sequence.
                   On output the header is modified: the number of columns/rows is truncated down to the hull size.
<dt>orientation<dd>Desired orientation of convex hull: <code>CV_CLOCKWISE</code> or <code>CV_COUNTER_CLOCKWISE</code>.
<dt>return_points<dd>If non-zero, the points themselves will be stored
                    in the hull instead of indices if <code>hull_storage</code> is array, or pointers if <code>hull_storage</code> is memory storage.
</dl><p>
The function <code>cvConvexHull2</code> finds convex hull of 2D point set using Sklansky&#146;s algorithm.
If <code>hull_storage</code> is memory storage, the function creates a sequence containing the hull points or
pointers to them, depending on <code>return_points</code> value and returns the sequence on output.
</p>
<h4>Example. Building convex hull for a sequence or array of points</h4>
<pre>
#include "cv.h"
#include "highgui.h"
#include &lt;stdlib.h&gt;

#define ARRAY  0 /* switch between array/sequence method by replacing 0&lt;=&gt;1 */

void main( int argc, char** argv )
{
    IplImage* img = cvCreateImage( cvSize( 500, 500 ), 8, 3 );
    cvNamedWindow( "hull", 1 );

#if !ARRAY
        CvMemStorage* storage = cvCreateMemStorage();
#endif

    for(;;)
    {
        int i, count = rand()%100 + 1, hullcount;
        CvPoint pt0;
#if !ARRAY
        CvSeq* ptseq = cvCreateSeq( CV_SEQ_KIND_GENERIC|CV_32SC2, sizeof(CvContour),
                                     sizeof(CvPoint), storage );
        CvSeq* hull;

        for( i = 0; i &lt; count; i++ )
        {
            pt0.x = rand() % (img->width/2) + img->width/4;
            pt0.y = rand() % (img->height/2) + img->height/4;
            cvSeqPush( ptseq, &pt0 );
        }
        hull = cvConvexHull2( ptseq, 0, CV_CLOCKWISE, 0 );
        hullcount = hull->total;
#else
        CvPoint* points = (CvPoint*)malloc( count * sizeof(points[0]));
        int* hull = (int*)malloc( count * sizeof(hull[0]));
        CvMat point_mat = cvMat( 1, count, CV_32SC2, points );
        CvMat hull_mat = cvMat( 1, count, CV_32SC1, hull );

        for( i = 0; i &lt; count; i++ )
        {
            pt0.x = rand() % (img->width/2) + img->width/4;
            pt0.y = rand() % (img->height/2) + img->height/4;
            points[i] = pt0;
        }
        cvConvexHull2( &point_mat, &hull_mat, CV_CLOCKWISE, 0 );
        hullcount = hull_mat.cols;
#endif
        cvZero( img );
        for( i = 0; i &lt; count; i++ )
        {
#if !ARRAY
            pt0 = *CV_GET_SEQ_ELEM( CvPoint, ptseq, i );
#else
            pt0 = points[i];
#endif
            cvCircle( img, pt0, 2, CV_RGB( 255, 0, 0 ), CV_FILLED );
        }

#if !ARRAY
        pt0 = **CV_GET_SEQ_ELEM( CvPoint*, hull, hullcount - 1 );
#else
        pt0 = points[hull[hullcount-1]];
#endif

        for( i = 0; i &lt; hullcount; i++ )
        {
#if !ARRAY
            CvPoint pt = **CV_GET_SEQ_ELEM( CvPoint*, hull, i );
#else
            CvPoint pt = points[hull[i]];
#endif
            cvLine( img, pt0, pt, CV_RGB( 0, 255, 0 ));
            pt0 = pt;
        }

        cvShowImage( "hull", img );

        int key = cvWaitKey(0);
        if( key == 27 ) // 'ESC'
            break;

#if !ARRAY
        cvClearMemStorage( storage );
#else
        free( points );
        free( hull );
#endif
    }
}
</pre>


<hr><h3><a name="decl_cvCheckContourConvexity">CheckContourConvexity</a></h3>
<p class="Blurb">Tests contour convex</p>
<pre>
int cvCheckContourConvexity( const CvArr* contour );
</pre><p><dl>
<dt>contour<dd>Tested contour (sequence or array of points).
</dl><p>
The function <code>cvCheckContourConvexity</code> tests whether the input contour is convex or not.
The contour must be simple, i.e. without self-intersections.
</p>


<hr><h3><a name="decl_CvConvexityDefect">CvConvexityDefect</a></h3>
<p class="Blurb">Structure describing a single contour convexity detect</p>
<pre>
typedef struct CvConvexityDefect
{
    CvPoint* start; /* point of the contour where the defect begins */
    CvPoint* end; /* point of the contour where the defect ends */
    CvPoint* depth_point; /* the farthest from the convex hull point within the defect */
    float depth; /* distance between the farthest point and the convex hull */
} CvConvexityDefect;
</pre>
<h4>Picture. Convexity defects of hand contour.</h4>
<p>
<img src="pics/defects.png" width=200 height=200>
</p>


<hr><h3><a name="decl_cvConvexityDefects">ConvexityDefects</a></h3>
<p class="Blurb">Finds convexity defects of contour</p>
<pre>
CvSeq* cvConvexityDefects( const CvArr* contour, const CvArr* convexhull,
                           CvMemStorage* storage=NULL );
</pre><p><dl>
<dt>contour<dd>Input contour.
<dt>convexhull<dd>Convex hull obtained using <a href="#decl_cvConvexHull2">cvConvexHull2</a> that should contain pointers or indices
to the contour points, not the hull points themselves, i.e. <code>return_points</code> parameter in <a href="#decl_cvConvexHull2">cvConvexHull2</a>
should be 0.
<dt>storage<dd>Container for output sequence of convexity defects. If it is NULL, contour or hull
(in that order) storage is used.
</dl><p>
The function <code>cvConvexityDefects</code> finds all convexity defects of the input contour
and returns a sequence of the <a href="#decl_CvConvexityDefect">CvConvexityDefect</a> structures.
</p>


<hr><h3><a name="decl_cvPointPolygonTest">PointPolygonTest</a></h3>
<p class="Blurb">Point in contour test</p>
<pre>
double cvPointPolygonTest( const CvArr* contour,
                           CvPoint2D32f pt, int measure_dist );
</pre><p><dl>
<dt>contour<dd>Input contour.
<dt>pt<dd>The point tested against the contour.
<dt>measure_dist<dd>If it is non-zero, the function estimates distance from the point to the nearest contour edge.
</dl><p>
The function <code>cvPointPolygonTest</code> determines whether the point is inside contour, outside, or lies
on an edge (or coincides with a vertex). It returns positive, negative or zero value, correspondingly.
When <code>measure_dist=0</code>, the return value is +1, -1 and 0, respectively.
When <code>measure_dist&ne;0</code>, it is a signed distance between the point and the nearest contour edge.
</p><p>Here is the sample output of the function, where each image pixel is tested against the contour.</p>

<p><img src="pics/pointpolygon.png" width=200 height=200></p>


<hr><h3><a name="decl_cvMinAreaRect2">MinAreaRect2</a></h3>
<p class="Blurb">Finds circumscribed rectangle of minimal area for given 2D point set</p>
<pre>
CvBox2D  cvMinAreaRect2( const CvArr* points, CvMemStorage* storage=NULL );
</pre><p><dl>
<dt>points<dd>Sequence or array of points.
<dt>storage<dd>Optional temporary memory storage.
</dl><p>
The function <code>cvMinAreaRect2</code> finds a circumscribed rectangle of the minimal area for 2D point set
by building convex hull for the set and applying rotating calipers technique to the hull.</p>
<h4>Picture. Minimal-area bounding rectangle for contour</h4>
<p>
<img align=center src="pics/minareabox.png">
</p>


<hr><h3><a name="decl_cvMinEnclosingCircle">MinEnclosingCircle</a></h3>
<p class="Blurb">Finds circumscribed circle of minimal area for given 2D point set</p>
<pre>
int cvMinEnclosingCircle( const CvArr* points, CvPoint2D32f* center, float* radius );
</pre><p><dl>
<dt>points<dd>Sequence or array of 2D points.
<dt>center<dd>Output parameter. The center of the enclosing circle.
<dt>radius<dd>Output parameter. The radius of the enclosing circle.
</dl><p>
The function <code>cvMinEnclosingCircle</code> finds the minimal circumscribed circle for
2D point set using iterative algorithm. It returns nonzero if the resultant circle contains all the
input points and zero otherwise (i.e. algorithm failed).
</p>


<hr><h3><a name="decl_cvCalcPGH">CalcPGH</a></h3>
<p class="Blurb">Calculates pair-wise geometrical histogram for contour</p>
<pre>
void cvCalcPGH( const CvSeq* contour, CvHistogram* hist );
</pre><p><dl>
<dt>contour<dd>Input contour. Currently, only integer point coordinates are allowed.
<dt>hist<dd>Calculated histogram; must be two-dimensional.
</dl><p>
The function <code>cvCalcPGH</code> calculates 2D pair-wise geometrical histogram (PGH), described in
<a href="#paper_iivarinen97">[Iivarinen97]</a>, for the contour.
The algorithm considers every pair of the contour edges. The angle
between the edges and the minimum/maximum distances are determined for every
pair. To do this each of the edges in turn is taken as the base, while the
function loops through all the other edges. When the base edge and any other
edge are considered, the minimum and maximum distances from the points on the
non-base edge and line of the base edge are selected. The angle between the
edges defines the row of the histogram in which all the bins that correspond to
the distance between the calculated minimum and maximum distances are
incremented (that is, the histogram is transposed relatively to [Iivarninen97] definition).
The histogram can be used for contour matching.
</p>


<hr><h2><a name="cv_sa_subdiv">Planar Subdivisions</a></h2>

<hr><h3><a name="decl_CvSubdiv2D">CvSubdiv2D</a></h3>
<p class="Blurb">Planar subdivision</p>
<pre>
#define CV_SUBDIV2D_FIELDS()    \
    CV_GRAPH_FIELDS()           \
    int  quad_edges;            \
    int  is_geometry_valid;     \
    CvSubdiv2DEdge recent_edge; \
    CvPoint2D32f  topleft;      \
    CvPoint2D32f  bottomright;

typedef struct CvSubdiv2D
{
    CV_SUBDIV2D_FIELDS()
}
CvSubdiv2D;
</pre><p>
Planar subdivision is a subdivision of a plane into a set of non-overlapped regions (facets) that
cover the whole plane. The above structure describes a subdivision built on 2d point set, where
the points are linked together and form a planar graph, which, together with a few edges connecting
exterior subdivision points (namely, convex hull points) with infinity, subdivides a plane into facets
by its edges.
</p><p>
For every subdivision there exists dual subdivision there facets and points (subdivision vertices)
swap their roles, that is, a facet is treated as a vertex (called virtual point below) of dual subdivision
and the original subdivision vertices become facets. On the picture below original subdivision is marked with solid lines
and dual subdivision with dot lines</p>
<p>
<img src="pics/subdiv.png">
</p><p>
OpenCV subdivides plane into triangles using Delaunay&#146;s algorithm.
Subdivision is built iteratively starting from a dummy triangle that includes
all the subdivision points for sure.
In this case the dual subdivision is Voronoi diagram of input 2d point set.
The subdivisions can be used for 3d piece-wise transformation of a plane, morphing, fast location of
points on the plane, building special graphs (such as NNG,RNG) etc.</p>


<hr><h3><a name="decl_CvQuadEdge2D">CvQuadEdge2D</a></h3>
<p class="Blurb">Quad-edge of planar subdivision</p>
<pre>
/* one of edges within quad-edge, lower 2 bits is index (0..3)
   and upper bits are quad-edge pointer */
typedef long CvSubdiv2DEdge;

/* quad-edge structure fields */
#define CV_QUADEDGE2D_FIELDS()     \
    int flags;                     \
    struct CvSubdiv2DPoint* pt[4]; \
    CvSubdiv2DEdge  next[4];

typedef struct CvQuadEdge2D
{
    CV_QUADEDGE2D_FIELDS()
}
CvQuadEdge2D;
</pre><p>
Quad-edge is a basic element of subdivision, it contains four edges (e, eRot (in red) and reversed e &amp; eRot (in green)):
</p><p>
<img src="pics/quadedge.png" width=200 height=200>
</p>


<hr><h3><a name="decl_CvSubdiv2DPoint">CvSubdiv2DPoint</a></h3>
<p class="Blurb">Point of original or dual subdivision</p>
<pre>
#define CV_SUBDIV2D_POINT_FIELDS()\
    int            flags;      \
    CvSubdiv2DEdge first;      \
    CvPoint2D32f   pt;

#define CV_SUBDIV2D_VIRTUAL_POINT_FLAG (1 &lt;&lt; 30)

typedef struct CvSubdiv2DPoint
{
    CV_SUBDIV2D_POINT_FIELDS()
}
CvSubdiv2DPoint;
</pre>


<hr><h3><a name="decl_cvSubdiv2DGetEdge">Subdiv2DGetEdge</a></h3>
<p class="Blurb">Returns one of edges related to given</p>
<pre>
CvSubdiv2DEdge  cvSubdiv2DGetEdge( CvSubdiv2DEdge edge, CvNextEdgeType type );
#define cvSubdiv2DNextEdge( edge ) cvSubdiv2DGetEdge( edge, CV_NEXT_AROUND_ORG )
</pre><p><dl>
<dt>edge<dd>Subdivision edge (not a quad-edge)
<dt>type<dd>Specifies, which of related edges to return, one of:<ul>
<li>CV_NEXT_AROUND_ORG - next around the edge origin (<code>eOnext</code> on the picture above if <code>e</code> is the input edge)
<li>CV_NEXT_AROUND_DST - next around the edge vertex (<code>eDnext</code>)
<li>CV_PREV_AROUND_ORG - previous around the edge origin (reversed <code>eRnext</code>)
<li>CV_PREV_AROUND_DST - previous around the edge destination (reversed <code>eLnext</code>)
<li>CV_NEXT_AROUND_LEFT - next around the left facet (<code>eLnext</code>)
<li>CV_NEXT_AROUND_RIGHT - next around the right facet (<code>eRnext</code>)
<li>CV_PREV_AROUND_LEFT - previous around the left facet (reversed <code>eOnext</code>)
<li>CV_PREV_AROUND_RIGHT - previous around the right facet (reversed <code>eDnext</code>)
</ul>
</dl><p>
The function <code>cvSubdiv2DGetEdge</code> returns one the edges related to the input edge.
</p>


<hr><h3><a name="decl_cvSubdiv2DRotateEdge">Subdiv2DRotateEdge</a></h3>
<p class="Blurb">Returns another edge of the same quad-edge</p>
<pre>
CvSubdiv2DEdge  cvSubdiv2DRotateEdge( CvSubdiv2DEdge edge, int rotate );
</pre><p><dl>
<dt>edge<dd>Subdivision edge (not a quad-edge)
<dt>type<dd>Specifies, which of edges of the same quad-edge as the input one to return, one of:<ul>
<li>0 - the input edge (<code>e</code> on the picture above if <code>e</code> is the input edge)
<li>1 - the rotated edge (<code>eRot</code>)
<li>2 - the reversed edge (reversed <code>e</code> (in green))
<li>3 - the reversed rotated edge (reversed <code>eRot</code> (in green))
</ul>
</dl><p>
The function <code>cvSubdiv2DRotateEdge</code> returns one the edges of the same quad-edge as the input edge.
</p>


<hr><h3><a name="decl_cvSubdiv2DEdgeOrg">Subdiv2DEdgeOrg</a></h3>
<p class="Blurb">Returns edge origin</p>
<pre>
CvSubdiv2DPoint* cvSubdiv2DEdgeOrg( CvSubdiv2DEdge edge );
</pre><p><dl>
<dt>edge<dd>Subdivision edge (not a quad-edge)
</dl><p>
The function <code>cvSubdiv2DEdgeOrg</code> returns the edge origin. The returned pointer may be NULL if
the edge is from dual subdivision and the virtual point coordinates are not calculated yet.
The virtual points can be calculated using function <a href="#decl_cvCalcSubdivVoronoi2D">cvCalcSubdivVoronoi2D</a>.
</p>

<hr><h3><a name="decl_cvSubdiv2DEdgeDst">Subdiv2DEdgeDst</a></h3>
<p class="Blurb">Returns edge destination</p>
<pre>
CvSubdiv2DPoint* cvSubdiv2DEdgeDst( CvSubdiv2DEdge edge );
</pre><p><dl>
<dt>edge<dd>Subdivision edge (not a quad-edge)
</dl><p>
The function <code>cvSubdiv2DEdgeDst</code> returns the edge destination. The returned pointer may be NULL if
the edge is from dual subdivision and the virtual point coordinates are not calculated yet.
The virtual points can be calculated using function <a href="#decl_cvCalcSubdivVoronoi2D">cvCalcSubdivVoronoi2D</a>.
</p>


<hr><h3><a name="decl_cvCreateSubdivDelaunay2D">CreateSubdivDelaunay2D</a></h3>
<p class="Blurb">Creates empty Delaunay triangulation</p>
<pre>
CvSubdiv2D* cvCreateSubdivDelaunay2D( CvRect rect, CvMemStorage* storage );
</pre><p><dl>
<dt>rect<dd>Rectangle that includes all the 2d points that are to be added to subdivision.
<dt>storage<dd>Container for subdivision.
</dl><p>
The function <code>cvCreateSubdivDelaunay2D</code> creates an empty Delaunay subdivision,
where 2d points can be added further using function <a href="#decl_cvSubdivDelaunay2DInsert">cvSubdivDelaunay2DInsert</a>.
All the points to be added must be within the specified rectangle, otherwise a runtime error will be
raised.
</p>


<hr><h3><a name="decl_cvSubdivDelaunay2DInsert">SubdivDelaunay2DInsert</a></h3>
<p class="Blurb">Inserts a single point to Delaunay triangulation</p>
<pre>
CvSubdiv2DPoint*  cvSubdivDelaunay2DInsert( CvSubdiv2D* subdiv, CvPoint2D32f pt);
</pre><p><dl>
<dt>subdiv<dd>Delaunay subdivision created by function <a href="#decl_cvCreateSubdivDelaunay2D">cvCreateSubdivDelaunay2D</a>.
<dt>pt<dd>Inserted point.
</dl><p>
The function <code>cvSubdivDelaunay2DInsert</code> inserts a single point to subdivision and
modifies the subdivision topology appropriately.
If a points with same coordinates exists already, no new points is added.
The function returns pointer to the allocated point.
No virtual points coordinates is calculated at this stage.
</p>


<hr><h3><a name="decl_cvSubdiv2DLocate">Subdiv2DLocate</a></h3>
<p class="Blurb">Inserts a single point to Delaunay triangulation</p>
<pre>
CvSubdiv2DPointLocation  cvSubdiv2DLocate( CvSubdiv2D* subdiv, CvPoint2D32f pt,
                                           CvSubdiv2DEdge* edge,
                                           CvSubdiv2DPoint** vertex=NULL );
</pre><p><dl>
<dt>subdiv<dd>Delaunay or another subdivision.
<dt>pt<dd>The point to locate.
<dt>edge<dd>The output edge the point falls onto or right to.
<dt>vertex<dd>Optional output vertex double pointer the input point coincides with.
</dl><p>
The function <code>cvSubdiv2DLocate</code> locates input point within subdivision.
There are 5 cases:<ul>
<li>point falls into some facet. The function returns CV_PTLOC_INSIDE and <code>*edge</code> will contain one of edges of the facet.
<li>point falls onto the edge. The function returns CV_PTLOC_ON_EDGE and <code>*edge</code> will contain this edge.
<li>point coincides with one of subdivision vertices. The function returns CV_PTLOC_VERTEX and <code>*vertex</code> will contain pointer to the vertex.
<li>point is outside the subdivision reference rectangle. The function returns CV_PTLOC_OUTSIDE_RECT and no pointers is filled.
<li>one of input arguments is invalid. Runtime error is raised or, if silent or "parent" error processing mode
is selected, CV_PTLOC_ERROR is returned.
</ul>
</p>


<hr><h3><a name="decl_cvFindNearestPoint2D">FindNearestPoint2D</a></h3>
<p class="Blurb">Finds the closest subdivision vertex to given point</p>
<pre>
CvSubdiv2DPoint* cvFindNearestPoint2D( CvSubdiv2D* subdiv, CvPoint2D32f pt );
</pre><p><dl>
<dt>subdiv<dd>Delaunay or another subdivision.
<dt>pt<dd>Input point.
</dl><p>
The function <code>cvFindNearestPoint2D</code> is another function that locates input point within subdivision.
It finds subdivision vertex that is the closest to the input point. It is not necessarily one of
vertices of the facet containing the input point, though the facet (located using <a href="#decl_cvSubdiv2DLocate">cvSubdiv2DLocate</a>)
is used as a starting point. The function returns pointer to the found subdivision vertex</code>


<hr><h3><a name="decl_cvCalcSubdivVoronoi2D">CalcSubdivVoronoi2D</a></h3>
<p class="Blurb">Calculates coordinates of Voronoi diagram cells</p>
<pre>
void cvCalcSubdivVoronoi2D( CvSubdiv2D* subdiv );
</pre><p><dl>
<dt>subdiv<dd>Delaunay subdivision, where all the points are added already.
</dl><p>
The function <code>cvCalcSubdivVoronoi2D</code> calculates coordinates of virtual points.
All virtual points corresponding to some vertex of original subdivision form (when connected together)
a boundary of Voronoi cell of that point.
</p>


<hr><h3><a name="decl_cvClearSubdivVoronoi2D">ClearSubdivVoronoi2D</a></h3>
<p class="Blurb">Removes all virtual points</p>
<pre>
void cvClearSubdivVoronoi2D( CvSubdiv2D* subdiv );
</pre><p><dl>
<dt>subdiv<dd>Delaunay subdivision.
</dl><p>
The function <code>cvClearSubdivVoronoi2D</code> removes all virtual points.
It is called internally in <a href="#decl_cvCalcSubdivVoronoi2D">cvCalcSubdivVoronoi2D</a> if the subdivision was modified
after previous call to the function.
</p>

<hr><p>
There are a few other lower-level functions that work with planar subdivisions, see cv.h
and the sources. Demo script delaunay.c that builds Delaunay triangulation and Voronoi diagram of
random 2d point set can be found at opencv/samples/c.
</p>


<hr><h1><a name="cv_motion">Motion Analysis and Object Tracking Reference</a></h1>


<hr><h2><a name="cv_motion_acc">Accumulation of Background Statistics</a></h2>

<hr><h3><a name="decl_cvAcc">Acc</a></h3>
<p class="Blurb">Adds frame to accumulator</p>
<pre>
void cvAcc( const CvArr* image, CvArr* sum, const CvArr* mask=NULL );
</pre><p><dl>
<dt>image<dd>Input image, 1- or 3-channel, 8-bit or 32-bit floating point.
         (each channel of multi-channel image is processed independently).
<dt>sum<dd>Accumulator of the same number of channels as input image, 32-bit floating-point.
<dt>mask<dd>Optional operation mask.
</dl></p><p>
The function <code>cvAcc</code> adds the whole image <code>image</code> or its selected region to accumulator <code>sum</code>:</p>
<pre>
sum(x,y)=sum(x,y)+image(x,y) if mask(x,y)!=0
</pre>


<hr><h3><a name="decl_cvSquareAcc">SquareAcc</a></h3>
<p class="Blurb">Adds the square of source image to accumulator</p>
<pre>
void cvSquareAcc( const CvArr* image, CvArr* sqsum, const CvArr* mask=NULL );
</pre><p><dl>
<dt>image<dd>Input image, 1- or 3-channel, 8-bit or 32-bit floating point
         (each channel of multi-channel image is processed independently).
<dt>sqsum<dd>Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point.
<dt>mask<dd>Optional operation mask.
</dl></p><p>
The function <code>cvSquareAcc</code> adds the input image <code>image</code> or its selected region,
raised to power 2, to the accumulator <code>sqsum</code>:</p>
<pre>
sqsum(x,y)=sqsum(x,y)+image(x,y)<sup>2</sup> if mask(x,y)!=0
</pre>


<hr><h3><a name="decl_cvMultiplyAcc">MultiplyAcc</a></h3>
<p class="Blurb">Adds product of two input images to accumulator</p>
<pre>
void cvMultiplyAcc( const CvArr* image1, const CvArr* image2, CvArr* acc, const CvArr* mask=NULL );
</pre><p><dl>
<dt>image1<dd>First input image, 1- or 3-channel, 8-bit or 32-bit floating point
         (each channel of multi-channel image is processed independently).
<dt>image2<dd>Second input image, the same format as the first one.
<dt>acc<dd>Accumulator of the same number of channels as input images, 32-bit or 64-bit floating-point.
<dt>mask<dd>Optional operation mask.
</dl></p><p>
The function <code>cvMultiplyAcc</code> adds product of 2 images
or their selected regions to accumulator <code>acc</code>:</p>
<pre>
acc(x,y)=acc(x,y) + image1(x,y)&bull;image2(x,y) if mask(x,y)!=0
</pre>


<hr><h3><a name="decl_cvRunningAvg">RunningAvg</a></h3>
<p class="Blurb">Updates running average</p>
<pre>
void cvRunningAvg( const CvArr* image, CvArr* acc, double alpha, const CvArr* mask=NULL );
</pre><p><dl>
<dt>image<dd>Input image, 1- or 3-channel, 8-bit or 32-bit floating point
          (each channel of multi-channel image is processed independently).
<dt>acc<dd>Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point.
<dt>alpha<dd>Weight of input image.
<dt>mask<dd>Optional operation mask.
</dl></p><p>
The function <code>cvRunningAvg</code> calculates weighted sum of input image <code>image</code> and
the accumulator <code>acc</code> so that <code>acc</code> becomes a running average of frame sequence:</p>
<pre>
acc(x,y)=(1-&alpha;)&bull;acc(x,y) + &alpha;&bull;image(x,y) if mask(x,y)!=0
</pre><p>
where &alpha; (alpha) regulates update speed (how fast accumulator forgets about previous frames).
</p>


<hr><h2><a name="cv_motion_motempl">Motion Templates</a></h2>

<hr><h3><a name="decl_cvUpdateMotionHistory">UpdateMotionHistory</a></h3>
<p class="Blurb">Updates motion history image by moving silhouette</p>
<pre>
void cvUpdateMotionHistory( const CvArr* silhouette, CvArr* mhi,
                            double timestamp, double duration );
</pre><p><dl>
<dt>silhouette<dd>Silhouette mask that has non-zero pixels where the motion occurs.
<dt>mhi<dd>Motion history image, that is updated by the function (single-channel, 32-bit floating-point)
<dt>timestamp<dd>Current time in milliseconds or other units.
<dt>duration<dd>Maximal duration of motion track in the same units as <code>timestamp</code>.
</dl></p><p>
The function <code>cvUpdateMotionHistory</code> updates the motion history image as following:</p>
<pre>
mhi(x,y)=timestamp  if silhouette(x,y)!=0
         0          if silhouette(x,y)=0 and mhi(x,y)&lt;timestamp-duration
         mhi(x,y)   otherwise
</pre><p>
That is, MHI pixels where motion occurs are set to the current timestamp, while the pixels
where motion happened far ago are cleared.
</p>


<hr><h3><a name="decl_cvCalcMotionGradient">CalcMotionGradient</a></h3>
<p class="Blurb">Calculates gradient orientation of motion history image</p>
<pre>
void cvCalcMotionGradient( const CvArr* mhi, CvArr* mask, CvArr* orientation,
                           double delta1, double delta2, int aperture_size=3 );
</pre><p><dl>
<dt>mhi<dd>Motion history image.
<dt>mask<dd>Mask image; marks pixels where motion gradient data is correct. Output
parameter.
<dt>orientation<dd>Motion gradient orientation image; contains angles from 0 to ~360&deg;.
<dt>delta1, delta2<dd>The function finds minimum (m(x,y)) and maximum (M(x,y)) mhi values over
each pixel (x,y) neighborhood and assumes the gradient is valid only if
<pre>min(delta1,delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1,delta2).</pre>
<dt>aperture_size<dd>Aperture size of derivative operators used by the function:
CV_SCHARR, 1, 3, 5 or 7 (see <a href="#decl_cvSobel">cvSobel</a>).
</dl></p><p>
The function <code>cvCalcMotionGradient</code> calculates the derivatives <code>Dx</code> and <code>Dy</code> of
<code>mhi</code> and then calculates gradient orientation as:</p>
<pre>
orientation(x,y)=arctan(Dy(x,y)/Dx(x,y))
</pre>
<p>
where both <code>Dx(x,y)</code>' and <code>Dy(x,y)</code>' signs are taken into account
(as in <a href="opencvref_cxcore.htm#decl_cvCartToPolar">cvCartToPolar</a> function).
After that <code>mask</code> is filled to indicate
where the orientation is valid (see <code>delta1</code> and <code>delta2</code> description).
</p>


<hr><h3><a name="decl_cvCalcGlobalOrientation">CalcGlobalOrientation</a></h3>
<p class="Blurb">Calculates global motion orientation of some selected region</p>
<pre>
double cvCalcGlobalOrientation( const CvArr* orientation, const CvArr* mask, const CvArr* mhi,
                                double timestamp, double duration );
</pre><p><dl>
<dt>orientation<dd>Motion gradient orientation image; calculated by the function
<a href="#decl_cvCalcMotionGradient">cvCalcMotionGradient</a>.
<dt>mask<dd>Mask image. It may be a conjunction of valid gradient mask, obtained with
<a href="#decl_cvCalcMotionGradient">cvCalcMotionGradient</a> and mask of the region, whose direction needs to be
calculated.
<dt>mhi<dd>Motion history image.
<dt>timestamp<dd>Current time in milliseconds or other units, it is better to store time passed to
<a href="#decl_cvUpdateMotionHistory">cvUpdateMotionHistory</a> before and reuse it here, because running <a href="#decl_cvUpdateMotionHistory">cvUpdateMotionHistory</a>
and <a href="#decl_cvCalcMotionGradient">cvCalcMotionGradient</a> on large images may take some time.
<dt>duration<dd>Maximal duration of motion track in milliseconds, the same as in <a href="#decl_cvUpdateMotionHistory">cvUpdateMotionHistory</a>.
</dl></p><p>
The function <code>cvCalcGlobalOrientation</code>
calculates the general motion direction in
the selected region and returns the angle between 0&deg; and 360&deg;.
At first the function builds the orientation histogram and finds the basic
orientation as a coordinate of the histogram maximum. After that the function
calculates the shift relative to the basic orientation as a weighted sum of all
orientation vectors: the more recent is the motion, the greater is the weight.
The resultant angle is a circular sum of the basic orientation and the shift.


<hr><h3><a name="decl_cvSegmentMotion">SegmentMotion</a></h3>
<p class="Blurb">Segments whole motion into separate moving parts</p>
<pre>
CvSeq* cvSegmentMotion( const CvArr* mhi, CvArr* seg_mask, CvMemStorage* storage,
                        double timestamp, double seg_thresh );
</pre><p><dl>
<dt>mhi<dd>Motion history image.
<dt>seg_mask<dd>Image where the mask found should be stored, single-channel, 32-bit floating-point.
<dt>storage<dd>Memory storage that will contain a sequence of motion connected components.
<dt>timestamp<dd>Current time in milliseconds or other units.
<dt>seg_thresh<dd>Segmentation threshold; recommended to be equal to the interval
between motion history "steps" or greater.
</dl></p><p>
The function <code>cvSegmentMotion</code> finds all the motion segments and marks them in <code>seg_mask</code>
with individual values each (1,2,...). It also returns a sequence of <a href="#decl_CvConnectedComp">CvConnectedComp</a> structures,
one per each motion components. After than the motion direction for every component can be calculated
with <a href="#decl_cvCalcGlobalOrientation">cvCalcGlobalOrientation</a> using extracted mask of the particular component
(using <a href="opencvref_cxcore.htm#decl_cvCmp">cvCmp</a>)
</p>


<hr><h2><a name="cv_motion_tracking">Object Tracking</a></h2>


<hr><h3><a name="decl_cvMeanShift">MeanShift</a></h3>
<p class="Blurb">Finds object center on back projection</p>
<pre>
int cvMeanShift( const CvArr* prob_image, CvRect window,
                 CvTermCriteria criteria, CvConnectedComp* comp );
</pre><p><dl>
<dt>prob_image<dd>Back projection of object histogram (see <a href="#decl_cvCalcBackProject">cvCalcBackProject</a>).
<dt>window<dd>Initial search window.
<dt>criteria<dd>Criteria applied to determine when the window search should be
finished.
<dt>comp<dd>Resultant structure that contains converged search window coordinates
(<code>comp->rect</code> field) and sum of all pixels inside the window (<code>comp->area</code> field).
</dl></p><p>
The function <code>cvMeanShift</code> iterates to find the object center given its back projection and
initial position of search window. The iterations are made until the search window
center moves by less than the given value and/or until the function has done the
maximum number of iterations. The function returns the number of iterations
made.
</p>


<hr><h3><a name="decl_cvCamShift">CamShift</a></h3>
<p class="Blurb">Finds object center, size, and orientation</p>
<pre>
int cvCamShift( const CvArr* prob_image, CvRect window, CvTermCriteria criteria,
                CvConnectedComp* comp, CvBox2D* box=NULL );
</pre><p><dl>
<dt>prob_image<dd>Back projection of object histogram (see <a href="#decl_cvCalcBackProject">cvCalcBackProject</a>).
<dt>window<dd>Initial search window.
<dt>criteria<dd>Criteria applied to determine when the window search should be
finished.
<dt>comp<dd>Resultant structure that contains converged search window coordinates
(<code>comp->rect</code> field) and sum of all pixels inside the window (<code>comp->area</code> field).
<dt>box<dd>Circumscribed box for the object. If not <code>NULL</code>, contains object size and
orientation.
</dl></p><p>
The function <code>cvCamShift</code> implements CAMSHIFT object tracking
algorithm (<a href="#paper_bradski98">[Bradski98]</a>).
First, it finds an object center using <a href="#decl_cvMeanShift">cvMeanShift</a> and,
after that, calculates the object size and orientation. The function returns
number of iterations made within <a href="#decl_cvMeanShift">cvMeanShift</a>.
</p><p>
<a href="#decl_CvCamShiftTracker">CvCamShiftTracker</a> class declared in cv.hpp implements color object tracker that uses
the function.
</p>


<hr><h3><a name="decl_cvSnakeImage">SnakeImage</a></h3>
<p class="Blurb">Changes contour position to minimize its energy</p>
<pre>
void cvSnakeImage( const IplImage* image, CvPoint* points, int length,
                   float* alpha, float* beta, float* gamma, int coeff_usage,
                   CvSize win, CvTermCriteria criteria, int calc_gradient=1 );
</pre><p><dl>
<dt>image<dd>The source image or external energy field.
<dt>points<dd>Contour points (snake).
<dt>length<dd>Number of points in the contour.
<dt>alpha<dd>Weight[s] of continuity energy, single float or array of <code>length</code> floats,
             one per each contour point.
<dt>beta<dd>Weight[s] of curvature energy, similar to <code>alpha</code>.
<dt>gamma<dd>Weight[s] of image energy, similar to <code>alpha</code>.
<dt>coeff_usage<dd>Variant of usage of the previous three parameters:
<ul>
<li><code>CV_VALUE</code> indicates that each of <code>alpha, beta, gamma</code> is a pointer to a single
  value to be used for all points;
<li><code>CV_ARRAY</code> indicates that each of <code>alpha, beta, gamma</code> is a pointer to an array
  of coefficients different for all the points of the snake. All the arrays must
  have the size equal to the contour size.
</ul>
<dt>win<dd>Size of neighborhood of every point used to search the minimum, both <code>win.width</code> and
<code>win.height</code> must be odd.
<dt>criteria<dd>Termination criteria.
<dt>calc_gradient<dd>Gradient flag. If not 0, the function calculates gradient magnitude for every image pixel and
considers it as the energy field, otherwise the input image itself is considered.
</dl></p><p>
The function <code>cvSnakeImage</code> updates snake in order to minimize its total energy that is a sum
of internal energy that depends on contour shape (the smoother contour is, the smaller internal energy is)
and external energy that depends on the energy field and reaches minimum at the local energy extremums
that correspond to the image edges in case of image gradient.</p><p>
The parameter <code>criteria.epsilon</code> is used to define the minimal number of points
that must be moved during any iteration to keep the iteration process running.
<p>
If at some iteration the number of moved points is less than <code>criteria.epsilon</code> or the function
performed <code>criteria.max_iter</code> iterations, the function terminates.
</p>


<hr><h2><a name="cv_motion_optflow">Optical Flow</a></h2>

<hr><h3><a name="decl_cvCalcOpticalFlowHS">CalcOpticalFlowHS</a></h3>
<p class="Blurb">Calculates optical flow for two images</p>
<pre>
void cvCalcOpticalFlowHS( const CvArr* prev, const CvArr* curr, int use_previous,
                          CvArr* velx, CvArr* vely, double lambda,
                          CvTermCriteria criteria );
</pre><p><dl>
<dt>prev<dd>First image, 8-bit, single-channel.
<dt>curr<dd>Second image, 8-bit, single-channel.
<dt>use_previous<dd>Uses previous (input) velocity field.
<dt>velx<dd>Horizontal component of the optical flow of the same size as input images,
            32-bit floating-point, single-channel.
<dt>vely<dd>Vertical component of the optical flow of the same size as input images,
            32-bit floating-point, single-channel.
<dt>lambda<dd>Lagrangian multiplier.
<dt>criteria<dd>Criteria of termination of velocity computing.
</dl></p><p>
The function <code>cvCalcOpticalFlowHS</code> computes flow for every pixel of the first input image using
Horn & Schunck algorithm <a href="#paper_horn81">[Horn81]</a>.
</p>


<hr><h3><a name="decl_cvCalcOpticalFlowLK">CalcOpticalFlowLK</a></h3>
<p class="Blurb">Calculates optical flow for two images</p>
<pre>
void cvCalcOpticalFlowLK( const CvArr* prev, const CvArr* curr, CvSize win_size,
                          CvArr* velx, CvArr* vely );
</pre><p><dl>
<dt>prev<dd>First image, 8-bit, single-channel.
<dt>curr<dd>Second image, 8-bit, single-channel.
<dt>win_size<dd>Size of the averaging window used for grouping pixels.
<dt>velx<dd>Horizontal component of the optical flow of the same size as input images,
            32-bit floating-point, single-channel.
<dt>vely<dd>Vertical component of the optical flow of the same size as input images,
            32-bit floating-point, single-channel.
</dl></p><p>
The function <code>cvCalcOpticalFlowLK</code> computes flow for every pixel of the first input image using
Lucas & Kanade algorithm <a href="#paper_lucas81">[Lucas81]</a>.
</p>


<hr><h3><a name="decl_cvCalcOpticalFlowBM">CalcOpticalFlowBM</a></h3>
<p class="Blurb">Calculates optical flow for two images by block matching method</p>
<pre>
void cvCalcOpticalFlowBM( const CvArr* prev, const CvArr* curr, CvSize block_size,
                          CvSize shift_size, CvSize max_range, int use_previous,
                          CvArr* velx, CvArr* vely );
</pre><p><dl>
<dt>prev<dd>First image, 8-bit, single-channel.
<dt>curr<dd>Second image, 8-bit, single-channel.
<dt>block_size<dd>Size of basic blocks that are compared.
<dt>shift_size<dd>Block coordinate increments.
<dt>max_range<dd>Size of the scanned neighborhood in pixels around block.
<dt>use_previous<dd>Uses previous (input) velocity field.
<dt>velx<dd>Horizontal component of the optical flow of<br>
            floor((prev->width - block_size.width)/shiftSize.width) &times; floor((prev->height - block_size.height)/shiftSize.height) size,
            32-bit floating-point, single-channel.
<dt>vely<dd>Vertical component of the optical flow of the same size <code>velx</code>,
            32-bit floating-point, single-channel.
</dl></p><p>
The function <code>cvCalcOpticalFlowBM</code> calculates optical flow for
overlapped blocks <code>block_size.width&times;block_size.height</code> pixels each,
thus the velocity fields are smaller than the original images. For every block in <code>prev</code>
the functions tries to find a similar block in <code>curr</code> in some neighborhood of the original
block or shifted by (velx(x0,y0),vely(x0,y0)) block as has been calculated
by previous function call (if <code>use_previous=1</code>)
</p>


<hr><h3><a name="decl_cvCalcOpticalFlowPyrLK">CalcOpticalFlowPyrLK</a></h3>
<p class="Blurb">Calculates optical flow for a sparse feature set using iterative Lucas-Kanade method in
        pyramids</p>
<pre>
void cvCalcOpticalFlowPyrLK( const CvArr* prev, const CvArr* curr, CvArr* prev_pyr, CvArr* curr_pyr,
                             const CvPoint2D32f* prev_features, CvPoint2D32f* curr_features,
                             int count, CvSize win_size, int level, char* status,
                             float* track_error, CvTermCriteria criteria, int flags );
</pre><p><dl>
<dt>prev<dd>First frame, at time <code>t</code>.
<dt>curr<dd>Second frame, at time <code>t + dt</code> .
<dt>prev_pyr<dd>Buffer for the pyramid for the first frame. If the pointer is not <code>NULL</code> ,
the buffer must have a sufficient size to store the pyramid from level <code>1</code> to
level #<code>level</code> ; the total size of <code>(image_width+8)*image_height/3</code> bytes
is sufficient.
<dt>curr_pyr<dd>Similar to <code>prev_pyr</code>, used for the second frame.
<dt>prev_features<dd>Array of points for which the flow needs to be found.
<dt>curr_features<dd>Array of 2D points containing calculated new positions of input features in the second image.
<dt>count<dd>Number of feature points.
<dt>win_size<dd>Size of the search window of each pyramid level.
<dt>level<dd>Maximal pyramid level number. If <code>0</code> , pyramids are not used (single level),
if <code>1</code> , two levels are used, etc.
<dt>status<dd>Array. Every element of the array is set to <code>1</code> if the flow for the
corresponding feature has been found, <code>0</code> otherwise.
<dt>track_error<dd>Array of double numbers containing difference between patches around the
original and moved points. Optional parameter; can be <code>NULL </code>.
<dt>criteria<dd>Specifies when the iteration process of finding the flow for each point
on each pyramid level should be stopped.
<dt>flags<dd>Miscellaneous flags:
<ul>
<li>  <code>CV_LKFLOW_PYR_A_READY </code>, pyramid for the first frame is pre-calculated before
  the call;
<li>  <code>CV_LKFLOW_PYR_B_READY</code> , pyramid for the second frame is pre-calculated before
  the call;
<li>  <code>CV_LKFLOW_INITIAL_GUESSES</code> , array B contains initial coordinates of features
  before the function call.
</ul>
</dl></p><p>
The function <code>cvCalcOpticalFlowPyrLK</code> implements
sparse iterative version of Lucas-Kanade optical flow in pyramids (<a href="#paper_bouguet00">[Bouguet00]</a>).
It calculates coordinates of the feature points on the current video frame given
their coordinates on the previous frame. The function finds the coordinates with sub-pixel accuracy.
<p>
Both parameters <code>prev_pyr</code> and <code>curr_pyr</code> comply with the following rules: if the image
pointer is 0, the function allocates the buffer internally, calculates the
pyramid, and releases the buffer after processing. Otherwise, the function
calculates the pyramid and stores it in the buffer unless the flag
<code>CV_LKFLOW_PYR_A[B]_READY</code> is set. The image should be large enough to fit the
Gaussian pyramid data. After the function call both pyramids are calculated and
the readiness flag for the corresponding image can be set in the next call (i.e., typically,
for all the image pairs except the very first one <code>CV_LKFLOW_PYR_A_READY</code> is set).
</p>

<hr><h2><a name="cv_motion_feature">Feature Matching</a></h2>

<hr><h3><a name="decl_cvCreateFeatureTree">CreateFeatureTree</a></h3>
<p class="Blurb">Constructs a tree of feature vectors</p>
<pre>
CvFeatureTree* cvCreateFeatureTree(CvMat* desc);
</pre><p><dl>
<dt>desc<dd>n x d matrix of n d-dimensional feature vectors (CV_32FC1 or CV_64FC1).
</dl></p><p>
The function <code>cvCreateFeatureTree</code> constructs a balanced kd-tree index of 
the given feature vectors. The lifetime of the desc matrix must exceed that 
of the returned tree. I.e., no copy is made of the vectors.
</p>

<hr><h3><a name="decl_cvReleaseFeatureTree">ReleaseFeatureTree</a></h3>
<p class="Blurb">Destroys a tree of feature vectors</p>
<pre>
void cvReleaseFeatureTree(CvFeatureTree* tr);
</pre><p><dl>
<dt>tr<dd>pointer to tree being destroyed.
</dl></p><p>
The function <code>cvReleaseFeatureTree</code> deallocates the given kd-tree.
</p>

<hr><h3><a name="decl_cvFindFeatures">FindFeatures</a></h3>
<p class="Blurb">Finds approximate k nearest neighbors of given vectors using best-bin-first search</p>
<pre>
void cvFindFeatures(CvFeatureTree* tr, CvMat* desc,
		    CvMat* results, CvMat* dist, int k=2, int emax=20);
</pre><p><dl>
<dt>tr<dd>pointer to kd-tree index of reference vectors.
<dt>desc<dd>m x d matrix of (row-)vectors to find the nearest neighbors of.
<dt>results<dd>m x k set of row indices of matching vectors (referring to matrix passed to cvCreateFeatureTree). Contains -1 in some columns if fewer than k neighbors found.
<dt>dist<dd>m x k matrix of distances to k nearest neighbors.
<dt>k<dd>The number of neighbors to find.
<dt>emax<dd>The maximum number of leaves to visit.
</dl></p><p>
The function <code>cvFindFeatures</code> finds (with high probability) the <code>k</code> nearest
neighbors in <code>tr</code> for each of the given (row-)vectors in <code>desc</code>, using
best-bin-first searching (<a href="#paper_beis97">[Beis97]</a>).
The complexity of the entire operation is at most <code>O(m*emax*log2(n))</code>, 
where <code>n</code> is the number of vectors in the tree.
</p>

<hr><h3><a name="decl_cvFindFeaturesBoxed">FindFeaturesBoxed</a></h3>
<p class="Blurb">Orthogonal range search</p>
<pre>
int cvFindFeaturesBoxed(CvFeatureTree* tr,
			CvMat* bounds_min, CvMat* bounds_max,
			CvMat* results);
</pre><p><dl>
<dt>tr<dd>pointer to kd-tree index of reference vectors.
<dt>bounds_min<dd>1 x d or d x 1 vector (CV_32FC1 or CV_64FC1) giving minimum value for each dimension.
<dt>bounds_max<dd>1 x d or d x 1 vector (CV_32FC1 or CV_64FC1) giving maximum value for each dimension.
<dt>results<dd>1 x m or m x 1 vector (CV_32SC1) to contain output row indices (referring to matrix passed to cvCreateFeatureTree).
</dl></p><p>
The function <code>cvFindFeaturesBoxed</code> performs orthogonal range seaching on the
given kd-tree. That is, it returns the set of vectors <code>v</code> in <code>tr</code> that satisfy
<code>bounds_min[i] <= v[i] <= bounds_max[i], 0 <= i < d</code>, where <code>d</code> is the dimension
of vectors in the tree. 
The function returns the number of such vectors found.
</p>

<hr><h2><a name="cv_motion_estimators">Estimators</a></h2>

<hr><h3><a name="decl_CvKalman">CvKalman</a></h3>
<p class="Blurb">Kalman filter state</p>
<pre>
typedef struct CvKalman
{
    int MP;                     /* number of measurement vector dimensions */
    int DP;                     /* number of state vector dimensions */
    int CP;                     /* number of control vector dimensions */

    /* backward compatibility fields */
#if 1
    float* PosterState;         /* =state_pre->data.fl */
    float* PriorState;          /* =state_post->data.fl */
    float* DynamMatr;           /* =transition_matrix->data.fl */
    float* MeasurementMatr;     /* =measurement_matrix->data.fl */
    float* MNCovariance;        /* =measurement_noise_cov->data.fl */
    float* PNCovariance;        /* =process_noise_cov->data.fl */
    float* KalmGainMatr;        /* =gain->data.fl */
    float* PriorErrorCovariance;/* =error_cov_pre->data.fl */
    float* PosterErrorCovariance;/* =error_cov_post->data.fl */
    float* Temp1;               /* temp1->data.fl */
    float* Temp2;               /* temp2->data.fl */
#endif

    CvMat* state_pre;           /* predicted state (x'(k)):
                                    x(k)=A*x(k-1)+B*u(k) */
    CvMat* state_post;          /* corrected state (x(k)):
                                    x(k)=x'(k)+K(k)*(z(k)-H*x'(k)) */
    CvMat* transition_matrix;   /* state transition matrix (A) */
    CvMat* control_matrix;      /* control matrix (B)
                                   (it is not used if there is no control)*/
    CvMat* measurement_matrix;  /* measurement matrix (H) */
    CvMat* process_noise_cov;   /* process noise covariance matrix (Q) */
    CvMat* measurement_noise_cov; /* measurement noise covariance matrix (R) */
    CvMat* error_cov_pre;       /* priori error estimate covariance matrix (P'(k)):
                                    P'(k)=A*P(k-1)*At + Q)*/
    CvMat* gain;                /* Kalman gain matrix (K(k)):
                                    K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)*/
    CvMat* error_cov_post;      /* posteriori error estimate covariance matrix (P(k)):
                                    P(k)=(I-K(k)*H)*P'(k) */
    CvMat* temp1;               /* temporary matrices */
    CvMat* temp2;
    CvMat* temp3;
    CvMat* temp4;
    CvMat* temp5;
}
CvKalman;
</pre>
<p>
The structure <a href="#decl_CvKalman">CvKalman</a> is used to keep Kalman filter state. It is created
by <a href="#decl_cvCreateKalman">cvCreateKalman</a> function, updated by <a href="#decl_cvKalmanPredict">cvKalmanPredict</a> and
<a href="#decl_cvKalmanCorrect">cvKalmanCorrect</a> functions and released by <a href="#decl_cvReleaseKalman">cvReleaseKalman</a> functions.
Normally, the structure is used for standard Kalman filter (notation and the formulae below are borrowed
from the excellent Kalman tutorial <a href="#paper_welch95">[Welch95]</a>):</p>
<pre>
x<sub>k</sub>=A&bull;x<sub>k-1</sub>+B&bull;u<sub>k</sub>+w<sub>k</sub>
z<sub>k</sub>=H&bull;x<sub>k</sub>+v<sub>k</sub>,
</pre>
<p>where:</p>
<pre>
x<sub>k</sub> (x<sub>k-1</sub>) - state of the system at the moment k (k-1)
z<sub>k</sub> - measurement of the system state at the moment k
u<sub>k</sub> - external control applied at the moment k

w<sub>k</sub> and v<sub>k</sub> are normally-distributed process and measurement noise, respectively:
p(w) ~ N(0,Q)
p(v) ~ N(0,R),

that is,
Q - process noise covariance matrix, constant or variable,
R - measurement noise covariance matrix, constant or variable
</pre><p>
In case of standard Kalman filter, all the matrices: A, B, H, Q and R are initialized once after
<a href="#decl_CvKalman">CvKalman</a> structure is allocated via <a href="#decl_cvCreateKalman">cvCreateKalman</a>.
However, the same structure and the same functions may be used to simulate extended Kalman filter by
linearizing extended Kalman filter equation in the current system state neighborhood,
in this case A, B, H (and, probably, Q and R) should be updated on every step.
</p>


<hr><h3><a name="decl_cvCreateKalman">CreateKalman</a></h3>
<p class="Blurb">Allocates Kalman filter structure</p>
<pre>
CvKalman* cvCreateKalman( int dynam_params, int measure_params, int control_params=0 );
</pre><p><dl>
<dt>dynam_params<dd>dimensionality of the state vector
<dt>measure_params<dd>dimensionality of the measurement vector
<dt>control_params<dd>dimensionality of the control vector
</dl></p><p>
The function <code>cvCreateKalman</code> allocates <a href="#decl_CvKalman">CvKalman</a> and all its matrices
and initializes them somehow.
</p>


<hr><h3><a name="decl_cvReleaseKalman">ReleaseKalman</a></h3>
<p class="Blurb">Deallocates Kalman filter structure</p>
<pre>
void cvReleaseKalman( CvKalman** kalman );
</pre><p><dl>
<dt>kalman<dd>double pointer to the Kalman filter structure.
</dl></p><p>
The function <code>cvReleaseKalman</code> releases the structure <a href="#decl_CvKalman">CvKalman</a>
and all underlying matrices.
</p>


<hr><h3><a name="decl_cvKalmanPredict">KalmanPredict</a></h3>
<p class="Blurb">Estimates subsequent model state</p>
<pre>
const CvMat* cvKalmanPredict( CvKalman* kalman, const CvMat* control=NULL );
#define cvKalmanUpdateByTime cvKalmanPredict
</pre><p><dl>
<dt>kalman<dd>Kalman filter state.
<dt>control<dd>Control vector (u<sub>k</sub>),
               should be NULL iff there is no external control (<code>control_params</code>=0).
</dl></p><p>
The function <code>cvKalmanPredict</code> estimates the subsequent stochastic model state
by its current state and stores it at <code>kalman->state_pre</code>:</p>
<pre>
    x'<sub>k</sub>=A&bull;x<sub>k</sub>+B&bull;u<sub>k</sub>
    P'<sub>k</sub>=A&bull;P<sub>k-1</sub>*A<sup>T</sup> + Q,
where
x'<sub>k</sub> is predicted state (kalman->state_pre),
x<sub>k-1</sub> is corrected state on the previous step (kalman->state_post)
                (should be initialized somehow in the beginning, zero vector by default),
u<sub>k</sub> is external control (<code>control</code> parameter),
P'<sub>k</sub> is priori error covariance matrix (kalman->error_cov_pre)
P<sub>k-1</sub> is posteriori error covariance matrix on the previous step (kalman->error_cov_post)
                (should be initialized somehow in the beginning, identity matrix by default),
</pre>
The function returns the estimated state.
</p>


<hr><h3><a name="decl_cvKalmanCorrect">KalmanCorrect</a></h3>
<p class="Blurb">Adjusts model state</p>
<pre>
const CvMat* cvKalmanCorrect( CvKalman* kalman, const CvMat* measurement );
#define cvKalmanUpdateByMeasurement cvKalmanCorrect
</pre><p><dl>
<dt>kalman<dd>Pointer to the structure to be updated.
<dt>measurement<dd>Pointer to the structure CvMat containing the measurement vector.
</dl></p><p>
The function <code>cvKalmanCorrect</code> adjusts stochastic model state on the
basis of the given measurement of the model state:</p>
<pre>
K<sub>k</sub>=P'<sub>k</sub>&bull;H<sup>T</sup>&bull;(H&bull;P'<sub>k</sub>&bull;H<sup>T</sup>+R)<sup>-1</sup>
x<sub>k</sub>=x'<sub>k</sub>+K<sub>k</sub>&bull;(z<sub>k</sub>-H&bull;x'<sub>k</sub>)
P<sub>k</sub>=(I-K<sub>k</sub>&bull;H)&bull;P'<sub>k</sub>
where
z<sub>k</sub> - given measurement (<code>mesurement</code> parameter)
K<sub>k</sub> - Kalman "gain" matrix.
</pre>
<p>
The function stores adjusted state at <code>kalman->state_post</code> and returns it on output.
</p>

<h4>Example. Using Kalman filter to track a rotating point</h4>
<pre>
#include "cv.h"
#include "highgui.h"
#include &lt;math.h&gt;

int main(int argc, char** argv)
{
    /* A matrix data */
    const float A[] = { 1, 1, 0, 1 };

    IplImage* img = cvCreateImage( cvSize(500,500), 8, 3 );
    CvKalman* kalman = cvCreateKalman( 2, 1, 0 );
    /* state is (phi, delta_phi) - angle and angle increment */
    CvMat* state = cvCreateMat( 2, 1, CV_32FC1 );
    CvMat* process_noise = cvCreateMat( 2, 1, CV_32FC1 );
    /* only phi (angle) is measured */
    CvMat* measurement = cvCreateMat( 1, 1, CV_32FC1 );
    CvRandState rng;
    int code = -1;

    cvRandInit( &rng, 0, 1, -1, CV_RAND_UNI );

    cvZero( measurement );
    cvNamedWindow( "Kalman", 1 );

    for(;;)
    {
        cvRandSetRange( &rng, 0, 0.1, 0 );
        rng.disttype = CV_RAND_NORMAL;

        cvRand( &rng, state );

        memcpy( kalman->transition_matrix->data.fl, A, sizeof(A));
        cvSetIdentity( kalman->measurement_matrix, cvRealScalar(1) );
        cvSetIdentity( kalman->process_noise_cov, cvRealScalar(1e-5) );
        cvSetIdentity( kalman->measurement_noise_cov, cvRealScalar(1e-1) );
        cvSetIdentity( kalman->error_cov_post, cvRealScalar(1));
        /* choose random initial state */
        cvRand( &rng, kalman->state_post );

        rng.disttype = CV_RAND_NORMAL;

        for(;;)
        {
            #define calc_point(angle)                                      \
                cvPoint( cvRound(img->width/2 + img->width/3*cos(angle)),  \
                         cvRound(img->height/2 - img->width/3*sin(angle)))

            float state_angle = state->data.fl[0];
            CvPoint state_pt = calc_point(state_angle);

            /* predict point position */
            const CvMat* prediction = cvKalmanPredict( kalman, 0 );
            float predict_angle = prediction->data.fl[0];
            CvPoint predict_pt = calc_point(predict_angle);
            float measurement_angle;
            CvPoint measurement_pt;

            cvRandSetRange( &rng, 0, sqrt(kalman->measurement_noise_cov->data.fl[0]), 0 );
            cvRand( &rng, measurement );

            /* generate measurement */
            cvMatMulAdd( kalman->measurement_matrix, state, measurement, measurement );

            measurement_angle = measurement->data.fl[0];
            measurement_pt = calc_point(measurement_angle);

            /* plot points */
            #define draw_cross( center, color, d )                                 \
                cvLine( img, cvPoint( center.x - d, center.y - d ),                \
                             cvPoint( center.x + d, center.y + d ), color, 1, 0 ); \
                cvLine( img, cvPoint( center.x + d, center.y - d ),                \
                             cvPoint( center.x - d, center.y + d ), color, 1, 0 )

            cvZero( img );
            draw_cross( state_pt, CV_RGB(255,255,255), 3 );
            draw_cross( measurement_pt, CV_RGB(255,0,0), 3 );
            draw_cross( predict_pt, CV_RGB(0,255,0), 3 );
            cvLine( img, state_pt, predict_pt, CV_RGB(255,255,0), 3, 0 );

            /* adjust Kalman filter state */
            cvKalmanCorrect( kalman, measurement );

            cvRandSetRange( &rng, 0, sqrt(kalman->process_noise_cov->data.fl[0]), 0 );
            cvRand( &rng, process_noise );
            cvMatMulAdd( kalman->transition_matrix, state, process_noise, state );

            cvShowImage( "Kalman", img );
            code = cvWaitKey( 100 );

            if( code > 0 ) /* break current simulation by pressing a key */
                break;
        }
        if( code == 27 ) /* exit by ESCAPE */
            break;
    }

    return 0;
}
</pre>

<hr><h3><a name="data_CvConDensation">CvConDensation</a></h3>
<p class="Blurb">ConDenstation state</p>
<pre>
    typedef struct CvConDensation
    {
        int MP;     //Dimension of measurement vector
        int DP;     // Dimension of state vector
        float* DynamMatr;       // Matrix of the linear Dynamics system
        float* State;           // Vector of State
        int SamplesNum;         // Number of the Samples
        float** flSamples;      // array of the Sample Vectors
        float** flNewSamples;   // temporary array of the Sample Vectors
        float* flConfidence;    // Confidence for each Sample
        float* flCumulative;    // Cumulative confidence
        float* Temp;            // Temporary vector
        float* RandomSample;    // RandomVector to update sample set
        CvRandState* RandS;     // Array of structures to generate random vectors
    } CvConDensation;
</pre>
<p>
The structure <a href="#decl_CvConDensation">CvConDensation</a> stores CONditional DENSity propagATION tracker state.
The information about the algorithm can be found at
<a href="http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/ISARD1/condensation.html">
http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/ISARD1/condensation.html</a>
</p>


<hr><h3><a name="decl_cvCreateConDensation">CreateConDensation</a></h3>
<p class="Blurb">Allocates ConDensation filter structure</p>
<pre>
CvConDensation* cvCreateConDensation( int dynam_params, int measure_params, int sample_count );
</pre><p><dl>
<dt>dynam_params<dd>Dimension of the state vector.
<dt>measure_params<dd>Dimension of the measurement vector.
<dt>sample_count<dd>Number of samples.
</dl></p><p>
The function <code>cvCreateConDensation</code> creates <a href="#decl_CvConDensation">CvConDensation</a>
structure and returns pointer to the structure.
</p>


<hr><h3><a name="decl_cvReleaseConDensation">ReleaseConDensation</a></h3>
<p class="Blurb">Deallocates ConDensation filter structure</p>
<pre>
void cvReleaseConDensation( CvConDensation** condens );
</pre><p><dl>
<dt>condens<dd>Pointer to the pointer to the structure to be released.
</dl></p><p>
The function <code>cvReleaseConDensation</code> releases the structure <a href="#decl_CvConDensation">CvConDensation</a> (see
<a href="#decl_CvConDensation">cvConDensation</a>) and frees all memory previously allocated for the structure.
</p>


<hr><h3><a name="decl_cvConDensInitSampleSet">ConDensInitSampleSet</a></h3>
<p class="Blurb">Initializes sample set for ConDensation algorithm</p>
<pre>
void cvConDensInitSampleSet( CvConDensation* condens, CvMat* lower_bound, CvMat* upper_bound );
</pre><p><dl>
<dt>condens<dd>Pointer to a structure to be initialized.
<dt>lower_bound<dd>Vector of the lower boundary for each dimension.
<dt>upper_bound<dd>Vector of the upper boundary for each dimension.
</dl></p><p>
The function <code>cvConDensInitSampleSet</code> fills the samples arrays in the structure
<a href="#decl_CvConDensation">CvConDensation</a> with values within specified ranges.
</p>


<hr><h3><a name="decl_cvConDensUpdateByTime">ConDensUpdateByTime</a></h3>
<p class="Blurb">Estimates subsequent model state</p>
<pre>
void cvConDensUpdateByTime( CvConDensation* condens );
</pre><p><dl>
<dt>condens<dd>Pointer to the structure to be updated.
</dl></p><p>
The function <code>cvConDensUpdateByTime</code>
estimates the subsequent stochastic model state from its current state.
</p>


<hr><h1><a name="cv_pattern">Pattern Recognition</a></h1>

<hr><h2><a name="cv_pattern_objdetection">Object Detection</a></h2>

<p>
The object detector described below has been initially proposed by Paul Viola
<a href="#paper_viola01">[Viola01]</a> and improved by Rainer Lienhart
<a href="#paper_lienhart02">[Lienhart02]</a>.
First, a classifier (namely a <code>cascade of boosted classifiers working
with haar-like features</code>) is trained with a few hundreds of sample
views of a particular object (i.e., a face or a car), called positive
examples, that are scaled to the same size (say, 20x20), and negative examples
- arbitrary images of the same size.
</p><p>
After a classifier is trained, it can be applied to a region of interest (of
the same size as used during the training) in an input image. The
classifier outputs a "1" if the region is likely to show the object
(i.e., face/car), and "0" otherwise. To search for the object in the
whole image one can move the search window across the image and check
every location using the classifier. The classifier is designed so that it can
be easily "resized" in order to be able to find the objects of interest
at different sizes, which is more efficient than resizing the image itself. So,
to find an object of an unknown size in the image the scan procedure should be
done several times at different scales.
</p>
<p>
The word "cascade" in the classifier name means that the resultant classifier
consists of several simpler classifiers (<code>stages</code>) that are applied
subsequently to a region of interest until at some stage the candidate
is rejected or all the stages are passed. The word
"boosted" means that the classifiers at every stage of the cascade are complex
themselves and they are built out of basic classifiers using one of four
different <code>boosting</code> techniques (weighted voting). Currently
Discrete Adaboost, Real Adaboost, Gentle Adaboost and Logitboost are supported.
The basic classifiers are decision-tree classifiers with at least
2 leaves. Haar-like features are the input to the basic classifiers, and
are calculated as described below. The current algorithm uses the following
Haar-like features:</p>
<p>
<img src="pics/haarfeatures.png">
</p>
<p>
The feature used in a particular classifier is specified by its shape (1a,
2b etc.), position within the region of interest and the scale (this scale is
not the same as the scale used at the detection stage, though these two scales
are multiplied). For example, in case of the third line feature (2c) the
response is calculated as the difference between the sum of image pixels
under the rectangle covering the whole feature (including the two white
stripes and the black stripe in the middle) and the sum of the image
pixels under the black stripe multiplied by 3 in order to compensate for
the differences in the size of areas. The sums of pixel values over a
rectangular regions are calculated rapidly using integral images
(see below and <a href="#decl_cvIntegral">
cvIntegral</a> description).
</p><p>
To see the object detector at work, have a look at HaarFaceDetect demo.
</p><p>
The following reference is for the detection part only. There is a
separate application called <code>haartraining</code> that can train a
cascade of boosted classifiers from a set of samples.
See <code>opencv/apps/haartraining</code> for details.
</p>


<hr><h3><a name="decl_CvHaar*">CvHaarFeature, CvHaarClassifier, CvHaarStageClassifier, CvHaarClassifierCascade</a></h3>
<p class="Blurb">Boosted Haar classifier structures</p>
<pre>
#define CV_HAAR_FEATURE_MAX  3

/* a haar feature consists of 2-3 rectangles with appropriate weights */
typedef struct CvHaarFeature
{
    int  tilted;  /* 0 means up-right feature, 1 means 45--rotated feature */
    
    /* 2-3 rectangles with weights of opposite signs and
       with absolute values inversely proportional to the areas of the rectangles.
       if rect[2].weight !=0, then
       the feature consists of 3 rectangles, otherwise it consists of 2 */
    struct
    {
        CvRect r;
        float weight;
    } rect[CV_HAAR_FEATURE_MAX];
}
CvHaarFeature;

/* a single tree classifier (stump in the simplest case) that returns the response for the feature
   at the particular image location (i.e. pixel sum over sub-rectangles of the window) and gives out
   a value depending on the response */
typedef struct CvHaarClassifier
{
    int count;  /* number of nodes in the decision tree */

    /* these are "parallel" arrays. Every index <code>i</code>
       corresponds to a node of the decision tree (root has 0-th index).

       left[i] - index of the left child (or negated index if the left child is a leaf)
       right[i] - index of the right child (or negated index if the right child is a leaf)
       threshold[i] - branch threshold. if feature response is &lt;= threshold, left branch
                      is chosen, otherwise right branch is chosen.
       alpha[i] - output value corresponding to the leaf. */
    CvHaarFeature* haar_feature;
    float* threshold;
    int* left;
    int* right;
    float* alpha;
}
CvHaarClassifier;

/* a boosted battery of classifiers(=stage classifier):
   the stage classifier returns 1
   if the sum of the classifiers' responses
   is greater than <code>threshold</code> and 0 otherwise */
typedef struct CvHaarStageClassifier
{
    int  count;  /* number of classifiers in the battery */
    float threshold; /* threshold for the boosted classifier */
    CvHaarClassifier* classifier; /* array of classifiers */

    /* these fields are used for organizing trees of stage classifiers,
       rather than just straight cascades */
    int next;
    int child;
    int parent;
}
CvHaarStageClassifier;

typedef struct CvHidHaarClassifierCascade CvHidHaarClassifierCascade;

/* cascade or tree of stage classifiers */
typedef struct CvHaarClassifierCascade
{
    int  flags; /* signature */
    int  count; /* number of stages */
    CvSize orig_window_size; /* original object size (the cascade is trained for) */

    /* these two parameters are set by cvSetImagesForHaarClassifierCascade */
    CvSize real_window_size; /* current object size */
    double scale; /* current scale */
    CvHaarStageClassifier* stage_classifier; /* array of stage classifiers */
    CvHidHaarClassifierCascade* hid_cascade; /* hidden optimized representation of the cascade,
                                                created by cvSetImagesForHaarClassifierCascade */
}
CvHaarClassifierCascade;

</pre>
<p>
All the structures are used for representing a cascaded of boosted Haar
classifiers. The cascade has the following hierarchical structure:</p>
<pre>
    Cascade:
        Stage<sub>1</sub>:
            Classifier<sub>11</sub>:
                Feature<sub>11</sub>
            Classifier<sub>12</sub>:
                Feature<sub>12</sub>
            ...
        Stage<sub>2</sub>:
            Classifier<sub>21</sub>:
                Feature<sub>21</sub>
            ...
        ...
</pre><p>
The whole hierarchy can be constructed manually or loaded from a file
using functions <a href="#decl_cvLoadHaarClassifierCascade">cvLoadHaarClassifierCascade</a>
or <a href="opencvref_cv.htm#decl_cvLoad">cvLoad</a>.
</p>


<hr><h3><a name="decl_cvLoadHaarClassifierCascade">cvLoadHaarClassifierCascade</a></h3>
<p class="Blurb">Loads a trained cascade classifier from file
                 or the classifier database embedded in OpenCV</p>
<pre>
CvHaarClassifierCascade* cvLoadHaarClassifierCascade(
                         const char* directory,
                         CvSize orig_window_size );
</pre><p><dl>
<dt>directory<dd>Name of directory containing the description of a trained cascade
                 classifier.
<dt>orig_window_size<dd>Original size of objects the cascade has been
                   trained on. Note that it is not stored in the cascade and therefore must
                   be specified separately.
</dl><p>
The function <code>cvLoadHaarClassifierCascade</code>
loads a trained cascade of haar classifiers from a file or the classifier
database embedded in OpenCV. The base can be trained using <code>haartraining</code>
application (see opencv/apps/haartraining for details).</p>
<p>
<em>The function is obsolete</em>. Nowadays object detection classifiers are stored in
XML or YAML files, rather than in directories. To load cascade from a
file, use <a href="opencvref_cxcore.htm#decl_cvLoad">cvLoad</a> function.
</p>


<hr><h3><a name="decl_cvReleaseHaarClassifierCascade">cvReleaseHaarClassifierCascade</a></h3>
<p class="Blurb">Releases haar classifier cascade</p>
<pre>
void cvReleaseHaarClassifierCascade( CvHaarClassifierCascade** cascade );
</pre>
<p><dl>
<dt>cascade<dd>Double pointer to the released cascade.
               The pointer is cleared by the function.
</dl>
<p>
The function <code>cvReleaseHaarClassifierCascade</code>
deallocates the cascade that has been created manually or loaded using
<a href="#decl_cvLoadHaarClassifierCascade">cvLoadHaarClassifierCascade</a> or
<a href="opencvref_cxcore.htm#decl_cvLoad">cvLoad</a>.
</p>


<hr><h3><a name="decl_cvHaarDetectObjects">cvHaarDetectObjects</a></h3>
<p class="Blurb">Detects objects in the image</p>
<pre>
typedef struct CvAvgComp
{
    CvRect rect; /* bounding rectangle for the object (average rectangle of a group) */
    int neighbors; /* number of neighbor rectangles in the group */
}
CvAvgComp;

CvSeq* cvHaarDetectObjects( const CvArr* image, CvHaarClassifierCascade* cascade,
                            CvMemStorage* storage, double scale_factor=1.1,
                            int min_neighbors=3, int flags=0,
                            CvSize min_size=cvSize(0,0) );
</pre>
<p><dl>
<dt>image<dd>Image to detect objects in.
<dt>cascade<dd>Haar classifier cascade in internal representation.
<dt>storage<dd>Memory storage to store the resultant sequence of the
               object candidate rectangles.
<dt>scale_factor<dd>The factor by which the search window is scaled between the subsequent scans,
                    for example, 1.1 means increasing window by 10%.
<dt>min_neighbors<dd>Minimum number (minus 1) of neighbor rectangles
                     that makes up an object. All the groups of a smaller number of rectangles
                     than <code>min_neighbors</code>-1 are rejected.
                     If <code>min_neighbors</code> is 0, the function does not any
                     grouping at all and returns all the detected candidate rectangles,
                     which may be useful if the user wants to apply a customized grouping procedure.
<dt>flags<dd>Mode of operation. It can be a combination of zero or more of the following values:<br>
             <code>CV_HAAR_SCALE_IMAGE</code> - for each scale factor used the function will
             downscale the image rather than "zoom" the feature coordinates in the classifier cascade.
             Currently, the option can only be used alone, i.e. the flag can not be set together with the others.<br>
             <code>CV_HAAR_DO_CANNY_PRUNING</code> - If it is set, the function uses Canny
             edge detector to reject some image regions that contain too few or too much edges
             and thus can not contain the searched object. The particular threshold values
             are tuned for face detection and in this case the pruning speeds up the processing.<br>
             <code>CV_HAAR_FIND_BIGGEST_OBJECT</code> - If it is set, the function finds
             the largest object (if any) in the image. That is, the output sequence will
             contain one (or zero) element(s).<br>
             <code>CV_HAAR_DO_ROUGH_SEARCH</code> - It should be used only when
             <code>CV_HAAR_FIND_BIGGEST_OBJECT</code> is set and <code>min_neighbors</code> > 0.
             If the flag is set, the function does not look for candidates of a smaller size
             as soon as it has found the object (with enough neighbor candidates) at the current
             scale. Typically, when <code>min_neighbors</code> is fixed, the
             mode yields less accurate (a bit larger) object rectangle than
             the regular single-object mode (<code>flags</code>=<code>CV_HAAR_FIND_BIGGEST_OBJECT</code>),
             but it is much faster, up to an order of magnitude. A greater value of
             <code>min_neighbors</code> may be specified to improve the accuracy.<p>
             
             Note, that in single-object mode <code>CV_HAAR_DO_CANNY_PRUNING</code>
             does not improve performance much and can even slow down the processing.

<dt>min_size<dd>Minimum window size. By default, it is set to the size of samples the classifier
has been trained on (~20&times;20 for face detection).
</dl>
<p>
The function <code>cvHaarDetectObjects</code> finds
rectangular regions in the given image that are likely to contain objects
the cascade has been trained for and returns those regions as
a sequence of rectangles. The function scans the image several
times at different scales (see <a href="#decl_cvSetImagesForHaarClassifierCascade">
cvSetImagesForHaarClassifierCascade</a>). Each time it considers
overlapping regions in the image and applies the classifiers to the regions
using <a href="#decl_cvRunHaarClassifierCascade">cvRunHaarClassifierCascade</a>.
It may also apply some heuristics to reduce number of analyzed regions, such as
Canny pruning. After it has proceeded and collected the candidate rectangles
(regions that passed the classifier cascade), it groups them and returns a
sequence of average rectangles for each large enough group. The default
parameters (<code>scale_factor</code>=1.1, <code>min_neighbors</code>=3, <code>flags</code>=0)
are tuned for accurate yet slow object detection. For a faster operation on
real video images the more preferable settings are: <code>scale_factor</code>=1.2, <code>min_neighbors</code>=2,
<code>flags</code>=CV_HAAR_DO_CANNY_PRUNING, <code>min_size</code>=&lt;minimum possible face size&gt;
(for example, ~1/4 to 1/16 of the image area in case of video conferencing).
</p>
<h4>Example. Using cascade of Haar classifiers to find objects (e.g. faces).</h4>
<pre>
#include "cv.h"
#include "highgui.h"

CvHaarClassifierCascade* load_object_detector( const char* cascade_path )
{
    return (CvHaarClassifierCascade*)cvLoad( cascade_path );
}

void detect_and_draw_objects( IplImage* image,
                              CvHaarClassifierCascade* cascade,
                              int do_pyramids )
{
    IplImage* small_image = image;
    CvMemStorage* storage = cvCreateMemStorage(0);
    CvSeq* faces;
    int i, scale = 1;

    /* if the flag is specified, down-scale the input image to get a
       performance boost w/o loosing quality (perhaps) */
    if( do_pyramids )
    {
        small_image = cvCreateImage( cvSize(image-&gt;width/2,image-&gt;height/2), IPL_DEPTH_8U, 3 );
        cvPyrDown( image, small_image, CV_GAUSSIAN_5x5 );
        scale = 2;
    }

    /* use the fastest variant */
    faces = cvHaarDetectObjects( small_image, cascade, storage, 1.2, 2, CV_HAAR_DO_CANNY_PRUNING );

    /* draw all the rectangles */
    for( i = 0; i &lt; faces-&gt;total; i++ )
    {
        /* extract the rectangles only */
        CvRect face_rect = *(CvRect*)cvGetSeqElem( faces, i, 0 );
        cvRectangle( image, cvPoint(face_rect.x*scale,face_rect.y*scale),
                     cvPoint((face_rect.x+face_rect.width)*scale,
                             (face_rect.y+face_rect.height)*scale),
                     CV_RGB(255,0,0), 3 );
    }

    if( small_image != image )
        cvReleaseImage( &amp;small_image );
    cvReleaseMemStorage( &amp;storage );
}

/* takes image filename and cascade path from the command line */
int main( int argc, char** argv )
{
    IplImage* image;
    if( argc==3 &amp;&amp; (image = cvLoadImage( argv[1], 1 )) != 0 )
    {
        CvHaarClassifierCascade* cascade = load_object_detector(argv[2]);
        detect_and_draw_objects( image, cascade, 1 );
        cvNamedWindow( "test", 0 );
        cvShowImage( "test", image );
        cvWaitKey(0);
        cvReleaseHaarClassifierCascade( &amp;cascade );
        cvReleaseImage( &amp;image );
    }

    return 0;
}
</pre>


<hr><h3><a name="decl_cvSetImagesForHaarClassifierCascade">cvSetImagesForHaarClassifierCascade</a></h3>
<p class="Blurb">Assigns images to the hidden cascade</p>
<pre>
void cvSetImagesForHaarClassifierCascade( CvHaarClassifierCascade* cascade,
                                          const CvArr* sum, const CvArr* sqsum,
                                          const CvArr* tilted_sum, double scale );
</pre>
<p><dl>
<dt>cascade<dd>Hidden Haar classifier cascade, created by <a href="#decl_cvCreateHidHaarClassifierCascade">
cvCreateHidHaarClassifierCascade</a>.
<dt>sum<dd>Integral (sum) single-channel image of 32-bit integer format. This image as well as the
                two subsequent images are used for fast feature evaluation and
                brightness/contrast normalization. They all can be retrieved from input 8-bit
                or floating point single-channel image using The function <code>cvIntegral</code>.
<dt>sqsum<dd>Square sum single-channel image of 64-bit floating-point format.
<dt>tilted_sum<dd>Tilted sum single-channel image of 32-bit integer format.
<dt>scale<dd>Window scale for the cascade. If <code>scale</code>=1, original window size is
             used (objects of that size are searched) - the same size as specified in
             <a href="#decl_cvLoadHaarClassifierCascade">cvLoadHaarClassifierCascade</a>
             (24x24 in case of "&lt;default_face_cascade&gt;"), if <code>scale</code>=2,
             a two times larger window is used (48x48 in case of default face cascade).
             While this will speed-up search about four times,
             faces smaller than 48x48 cannot be detected.
</dl>
<p>
The function <code>cvSetImagesForHaarClassifierCascade</code>
assigns images and/or window scale to the hidden classifier cascade.
If image pointers are NULL, the previously set images are used further
(i.e. NULLs mean "do not change images"). Scale parameter has no such a "protection" value, but
the previous value can be retrieved by <a href="#decl_cvGetHaarClassifierCascadeScale">
cvGetHaarClassifierCascadeScale</a> function and reused again. The function
is used to prepare cascade for detecting object of the particular size in the
particular image. The function is called internally by <a href="#decl_cvHaarDetectObjects">
cvHaarDetectObjects</a>, but it can be called by user if there is a need in
using lower-level function <a href="#decl_cvRunHaarClassifierCascade">cvRunHaarClassifierCascade</a>.
</p>


<hr>
<h3><a name="decl_cvRunHaarClassifierCascade">cvRunHaarClassifierCascade</a></h3>
<p class="Blurb">Runs cascade of boosted classifier at given image location</p>
<pre>
int cvRunHaarClassifierCascade( CvHaarClassifierCascade* cascade,
                                CvPoint pt, int start_stage=0 );
</pre>
<p><dl>
<dt>cascade<dd>Haar classifier cascade.
<dt>pt<dd>Top-left corner of the analyzed
          region. Size of the region is a original window size scaled by the currently set
          scale. The current window size may be retrieved using <a href="#decl_cvGetHaarClassifierCascadeWindowSize">
          cvGetHaarClassifierCascadeWindowSize</a> function.
<dt>start_stage<dd>Initial zero-based index of the cascade stage to start from.
                  The function assumes that all the previous stages are passed.
                  This feature is used internally by <a href="#decl_cvHaarDetectObjects">
                  cvHaarDetectObjects</a> for better processor cache utilization.
</dl><p>
The function <code>cvRunHaarHaarClassifierCascade</code>
runs Haar classifier cascade at a single image location. Before using this
function the integral images and the appropriate scale (=&gt; window size)
should be set using <a href="#decl_cvSetImagesForHaarClassifierCascade">cvSetImagesForHaarClassifierCascade</a>.
The function returns positive value if the analyzed rectangle passed all the classifier
stages (it is a candidate) and zero or negative value otherwise.
</p>


<hr><h1><a name="cv_3d">Camera Calibration and 3D Reconstruction</a></h1>

<hr><h2><a name="cv_3d_model">Pinhole Camera Model, Distortion</a></h2>

<p>
The functions in this section use so-called pinhole camera model. That is,
a scene view is formed by projecting 3D points into the image plane using perspective transformation.
<pre>

s*m' = A*[R|t]*M', or

 [u]   [fx 0 cx] [r<sub>11</sub> r<sub>12</sub> r<sub>13</sub> t<sub>1</sub>] [X]
s[v] = [0 fy cy]*[r<sub>21</sub> r<sub>22</sub> r<sub>23</sub> t<sub>2</sub>]*[Y]
 [1]   [0  0  1] [r<sub>31</sub> r<sub>32</sub> r<sub>33</sub> t<sub>2</sub>] [Z]
                                 [1]
</pre>

Where <code>(X, Y, Z)</code> are coordinates of a 3D point in the world coordinate space,
<code>(u, v)</code> are coordinates of point projection in pixels.
<code>A</code> is called a camera matrix, or matrix of intrinsic parameters.
<code>(cx, cy)</code> is a principal point (that is usually at the image center),
and <code>fx, fy</code> are focal lengths expressed in pixel-related units.
Thus, if an image from camera is up-sampled/down-sampled by some factor,
all these parameters (<code>fx, fy, cx</code> and <code>cy</code>) should be scaled
(multiplied/divided, respectively) by the same factor.
The matrix of intrinsic parameters does not depend on the scene viewed
and, once estimated, can be re-used (as long as the focal length is fixed (in case of zoom lens)).

The joint rotation-translation matrix <code>[R|t]</code> is called a matrix of extrinsic parameters.
It is used to describe the camera motion around a static scene, or vice versa,
rigid motion of an object in front of still camera. That is, <code>[R|t]</code> translates coordinates
of a point <code>(X, Y, Z)</code> to some coordinate system, fixed with respect to the camera.

The transformation above is equivalent to the following (when z&ne;0):

<pre>
[x]     [X]
[y] = R*[Y] + t
[z]     [Z]

x' = x/z
y' = y/z

u = fx*x' + cx
v = fy*y' + cy
</pre>

Real lens usually have some distortion, which is mainly a radial distortion
and slight tangential distortion. So, the above model is extended as:

<pre>
[x]     [X]
[y] = R*[Y] + t
[z]     [Z]

x' = x/z
y' = y/z

x" = x'*(1 + k<sub>1</sub>r<sup>2</sup> + k<sub>2</sub>r<sup>4</sup> + k<sub>3</sub>r<sup>6</sup>) + 2*p<sub>1</sub>x'*y' + p<sub>2</sub>(r<sup>2</sup>+2*x'<sup>2</sup>)
y" = y'*(1 + k<sub>1</sub>r<sup>2</sup> + k<sub>2</sub>r<sup>4</sup> + k<sub>3</sub>r<sup>6</sup>) + p<sub>1</sub>(r<sup>2</sup>+2*y'<sup>2</sup>) + 2*p<sub>2</sub>*x'*y'
where r<sup>2</sup> = x'<sup>2</sup>+y'<sup>2</sup>

u = fx*x" + cx
v = fy*y" + cy
</pre>

k<sub>1</sub>, k<sub>2</sub>, k<sub>3</sub> are radial distortion coefficients,
p<sub>1</sub>, p<sub>2</sub> are tangential distortion coefficients.
Higher-order coefficients are not considered in OpenCV.
The distortion coefficients also do not depend on the scene viewed,
thus they are intrinsic camera parameters.
<b>And they remain the same regardless of the captured image resolution.</b>
That is, if, for example, a camera has been calibrated on images of 320x240 resolution, absolutely the same distortion
coefficients can be used for images of 640x480 resolution from the same camera (while fx, fy, cx and cy need to be scaled appropriately).
<p>
<a name="dist_coeffs_ordering">Another note.Many of calibration related functions take the vector of distortion coefficients. It can be 4x1, 1x4, 5x1 or 1x5
floating-point vector (CvMat*). The ordering of the distortion coefficients is the following:</a></p>
<pre>
(k<sub>1</sub>, k<sub>2</sub>, p<sub>1</sub>, p<sub>2</sub>[, k<sub>3</sub>]).
</pre>
<p>That is, the first 2 radial distortion coefficients are followed by 2 tangential distortion coefficients and then, optionally,
by the third radial distortion coefficients. Such ordering is used to keep backward compatibility with previous versions of OpenCV.
</p><p>
The functions below use the above model to
<ul>
<li>Project 3D points to the image plane given intrinsic and extrinsic parameters
<li>Compute extrinsic parameters given intrinsic parameters, a few 3D points and their projections.
<li>Estimate intrinsic and extrinsic camera parameters from several views of a known calibration pattern
    (i.e. every view is described by several 3D-2D point correspondences).
</ul>
The functionality described in this section is largely based on the camera calibration toolbox
<a href="#paper_bouguet04">[Bouguet04]</a>

<hr><h2><a name="cv_3d_calibration">Single and Stereo Camera Calibration</a></h2>

<hr><h3><a name="decl_cvProjectPoints2">ProjectPoints2</a></h3>
<p class="Blurb">Projects 3D points to image plane</p>
<pre>
void cvProjectPoints2( const CvMat* object_points, const CvMat* rotation_vector,
                       const CvMat* translation_vector, const CvMat* intrinsic_matrix,
                       const CvMat* distortion_coeffs, CvMat* image_points,
                       CvMat* dpdrot=NULL, CvMat* dpdt=NULL, CvMat* dpdf=NULL,
                       CvMat* dpdc=NULL, CvMat* dpddist=NULL, double aspect_ratio=0 );
</pre><p><dl>
<dt>object_points<dd>The array of object points, 3xN or Nx3,
                     where N is the number of points in the view.
<dt>rotation_vector<dd>The rotation vector, 1x3 or 3x1.
<dt>translation_vector<dd>The translation vector, 1x3 or 3x1.
<dt>intrinsic_matrix<dd>The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1].
<dt>distortion_coeffs<dd>The vector of distortion coefficients, <a href="#dist_coeffs_ordering">4x1, 1x4, 5x1 or 1x5</a>.
                    If the vector is NULL, the function assumes that all the distortion coefficients are 0's.
<dt>image_points<dd>The output array of image points, 2xN or Nx2,
                    where N is the total number of points in the view.
<dt>dpdrot<dd>Optional Nx3 matrix of derivatives of image points with respect to components of the rotation vector.
<dt>dpdt<dd>Optional Nx3 matrix of derivatives of image points w.r.t. components of the translation vector.
<dt>dpdf<dd>Optional Nx2 matrix of derivatives of image points w.r.t. fx and fy.
<dt>dpdc<dd>Optional Nx2 matrix of derivatives of image points w.r.t. cx and cy.
<dt>dpddist<dd>Optional Nx4 matrix of derivatives of image points w.r.t. distortion coefficients.
<dt>aspect_ratio<dd>Optional aspect ratio parameter used to correct the output <code>dpdf</code>.
   (When <a href="#decl_cvCalibrateCamera2">cvCalibrateCamera2</a> or <a href="#decl_cvStereoCalibrate">cvStereoCalibrate</a>
    are called with the flag <code>CV_CALIB_FIX_ASPECT_RATIO</code>, only <code>fy</code> is estimated as
    independent parameter, and <code>fx</code> is computed as <code>fy*apect_ratio</code>; this affects <code>dpdf</code> too).
    If the parameter is 0, it means that the aspect ratio is not fixed.
</dl></p><p>
The function <code>cvProjectPoints2</code> computes projections of 3D points to the image plane given
intrinsic and extrinsic camera parameters. Optionally, the function computes Jacobians - matrices of
partial derivatives of image points as functions of all the input parameters w.r.t. the particular parameters,
intrinsic and/or extrinsic. The Jacobians are used during the global optimization in
<a href="#decl_cvCalibrateCamera2">cvCalibrateCamera2</a> and
<a href="#decl_cvFindExtrinsicParams2">cvFindExtrinsicCameraParams2</a>.
The function itself is also used to compute reprojection error for with current
intrinsic and extrinsic parameters.
</p><p>
Note, that with intrinsic and/or extrinsic parameters set to special values,
the function can be used to compute just extrinsic transformation or just intrinsic
transformation (i.e. distortion of a sparse set of points).
</p>


<hr><h3><a name="decl_cvFindHomography">FindHomography</a></h3>
<p class="Blurb">Finds perspective transformation between two planes</p>
<pre>
void cvFindHomography( const CvMat* src_points, const CvMat* dst_points,
                       CvMat* homography, int method=0,
                       double ransacReprojThreshold=0, CvMat* mask=NULL );

</pre><p><dl>
<dt>src_points<dd>Point coordinates in the original plane, 2xN, Nx2, 3xN or Nx3 array
                  (the latter two are for representation in homogeneous coordinates),
                  where N is the number of points.
<dt>dst_points<dd>Point coordinates in the destination plane, 2xN, Nx2, 3xN or Nx3 array
                  (the latter two are for representation in homogeneous coordinates)
<dt>homography<dd>Output 3x3 homography matrix.
<dt>method<dd>The method used to computed homography matrix. One of:<br>
  <code>0</code> - regular method using all the point pairs<br>
  <code>CV_RANSAC</code> - RANSAC-based robust method<br>
  <code>CV_LMEDS</code> - Least-Median robust method<br>
<dt>ransacReprojThreshold<dd>The maximum allowed reprojection error to treat a point pair as an inlier.
  The parameter is only used in RANSAC-based homography estimation. E.g. if <code>dst_points</code> coordinates are measured in pixels
  with pixel-accurate precision, it makes sense to set this parameter somewhere in the range ~1..3.
<dt>mask<dd>The optional output mask set by a robust method (<code>CV_RANSAC</code> or <code>CV_LMEDS</code>).
  
</dl></p><p>
The function <code>cvFindHomography</code> finds perspective transformation <code>H=||hij||</code> between the source
and the destination planes:

<pre>
  [x'<sub>i</sub>]   [x<sub>i</sub>]
s<sub>i</sub>[y'<sub>i</sub>]~H*[y<sub>i</sub>]
  [1  ]  [ 1]
</pre>

So that the reprojection error is minimized:

<pre>
sum_i((x'<sub>i</sub>-(h11*x<sub>i</sub> + h12*y<sub>i</sub> + h13)/(h31*x<sub>i</sub> + h32*y<sub>i</sub> + h33))<sup>2</sup>+
      (y'<sub>i</sub>-(h21*x<sub>i</sub> + h22*y<sub>i</sub> + h23)/(h31*x<sub>i</sub> + h32*y<sub>i</sub> + h33))<sup>2</sup>) -> min
</pre>

<p>If the parameter <code>method</code> is set to the default value 0, the function uses all the point pairs and estimates
the best suitable homography matrix. However, if there can not all the points pairs
(<code>src_points</code><sub>i</sub>, <code>dst_points</code><sub>i</sub>) fit the rigid perspective transformation
(i.e. there can be outliers), it is still possible to estimate the correct transformation using one of the robust methods available.
Both methods, <code>CV_RANSAC</code> and <code>CV_LMEDS</code>, try many different random subsets of the corresponding point pairs
(of 5 pairs each), estimate homography matrix using this subset using simple least-square algorithm and then compute
quality/goodness of the computed homography (which is the number of inliers for RANSAC or the median reprojection error for LMeDs).
The best subset is then used to produce the initial estimate of the homography matrix and the mask of inliers/outliers.
</p><p>
Regardless of the method, robust or not, the computed homography matrix is refined further (using inliers only in case of a robust method)
with Levenberg-Marquardt method in order to reduce the reprojection error even more.
</p><p>
The method <code>CV_RANSAC</code> can handle practically any ratio of outliers, but it needs the threshold to distinguish inliers from outliers.
The method <code>CV_LMEDS</code> does not need any threshold, but it works correctly only when there are more than 50% of inliers.
Finally, if you are sure in the computed features and there can be only some small noise, but no outliers,
the default method could be the best choice.
</p><p>
The function is used to find initial intrinsic and extrinsic matrices.
Homography matrix is determined up to a scale, thus it is normalized to make h33=1.</p>

<hr><h3><a name="decl_cvCalibrateCamera2">CalibrateCamera2</a></h3>
<p class="Blurb">Finds intrinsic and extrinsic camera parameters using calibration pattern</p>
<pre>
void cvCalibrateCamera2( const CvMat* object_points, const CvMat* image_points,
                         const CvMat* point_counts, CvSize image_size,
                         CvMat* intrinsic_matrix, CvMat* distortion_coeffs,
                         CvMat* rotation_vectors=NULL, CvMat* translation_vectors=NULL,
                         int flags=0 );
</pre><p><dl>
<dt>object_points<dd>The joint matrix of object points, 3xN or Nx3,
                     where N is the total number of points in all views.
<dt>image_points<dd>The joint matrix of corresponding image points, 2xN or Nx2,
                    where N is the total number of points in all views.
<dt>point_counts<dd>Vector containing numbers of points in each particular view,
                    1xM or Mx1, where M is the number of a scene views.
<dt>image_size<dd>Size of the image, used only to initialize intrinsic camera matrix.
<dt>intrinsic_matrix<dd>The output camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1].
                  If <code>CV_CALIB_USE_INTRINSIC_GUESS</code> and/or
                  <code>CV_CALIB_FIX_ASPECT_RATIO</code> are specified, some or all
                  of <code>fx, fy, cx, cy</code> must be initialized.
<dt>distortion_coeffs<dd>The output vector of distortion coefficients, <a href="#dist_coeffs_ordering">4x1, 1x4, 5x1 or 1x5</a>.
<dt>rotation_vectors<dd>The output 3xM or Mx3 array of rotation vectors
                        (compact representation of rotation matrices,
                        see <a href="#decl_cvRodrigues2">cvRodrigues2</a>).
<dt>translation_vectors<dd>The output 3xM or Mx3 array of translation vectors.
<dt>flags<dd>Different flags, may be 0 or combination of the following values:<br>
             <code>CV_CALIB_USE_INTRINSIC_GUESS</code> - <code>intrinsic_matrix</code> contains
             valid initial values of <code>fx, fy, cx, cy</code> that are optimized further.
             Otherwise, <code>(cx, cy)</code> is initially set to the image center
             (<code>image_size</code> is used here),
             and focal distances are computed in some least-squares fashion.
             Note, that if intrinsic parameters are known, there is no need to use this function.
             Use <a href="#decl_cvFindExtrinsicCameraParams2">cvFindExtrinsicCameraParams2</a> instead.<br>
             <code>CV_CALIB_FIX_PRINCIPAL_POINT</code> - The principal point is not changed during the global
             optimization, it stays at the center and at the other location specified (when
             <code>CV_CALIB_FIX_FOCAL_LENGTH</code> - Both fx and fy are fixed.<br>
             <code>CV_CALIB_USE_INTRINSIC_GUESS</code> is set as well).<br>
             <code>CV_CALIB_FIX_ASPECT_RATIO</code> - The optimization procedure consider only
             one of <code>fx</code> and <code>fy</code> as independent variable and keeps the aspect ratio
             <code>fx/fy</code> the same as it was set initially in <code>intrinsic_matrix</code>.
             In this case the actual initial values of <code>(fx, fy)</code> are either taken from the matrix
             (when <code>CV_CALIB_USE_INTRINSIC_GUESS</code> is set) or estimated somehow (in the latter case
             <code>fx, fy</code> may be set to arbitrary values, only their ratio is used).<br>
             <code>CV_CALIB_ZERO_TANGENT_DIST</code> - Tangential distortion coefficients are set to
             zeros and do not change during the optimization.<br>
             <code>CV_CALIB_FIX_K1</code> - The 0-th distortion coefficient (k1) is fixed (to 0 or to the initial passed value if <code>CV_CALIB_USE_INTRINSIC_GUESS</code> is passed)<br>
             <code>CV_CALIB_FIX_K2</code> - The 1-st distortion coefficient (k2) is fixed (see above)<br>
             <code>CV_CALIB_FIX_K3</code> - The 4-th distortion coefficient (k3) is fixed (see above)<br>
</dl></p><p>
The function <code>cvCalibrateCamera2</code> estimates intrinsic camera parameters and, optionally, the extrinsic parameters
for each view of the calibration pattern.
The coordinates of 3D object points and their correspondent 2D projections in each view
must be specified. That may be achieved by using an object with known geometry and easily detectable
feature points. Such an object is called a calibration rig or calibration pattern, and OpenCV has built-in
support for a chess board as a calibration rig
(see <a href="#decl_cvFindChessboardCorners">cvFindChessboardCorners</a>).
Currently, initialization of intrinsic parameters (when <code>CV_CALIB_USE_INTRINSIC_GUESS</code>
is not set) is only implemented for planar calibration rigs (z-coordinates of object points
must be all 0's or all 1's). 3D rigs can still be used as long as the initial <code>intrinsic_matrix</code>
is provided. After the initial values of intrinsic and extrinsic parameters are obtained by the function, they are
optimized further to minimize the total reprojection error - the sum of squared differences between the
actual coordinates of image points and the ones computed using
<a href="#decl_cvProjectPoints2">cvProjectPoints2</a> with current intrinsic and extrinsic parameters.
</p>

<hr><h3><a name="decl_cvCalibrationMatrixValues">CalibrationMatrixValues</a></h3>
<p class="Blurb">Finds intrinsic and extrinsic camera parameters using calibration pattern</p>
<pre>
void cvCalibrationMatrixValues( const CvMat *calibMatr,
                                int imgWidth, int imgHeight,
                                double apertureWidth=0, double apertureHeight=0,
                                double *fovx=NULL, double *fovy=NULL,
                                double *focalLength=NULL,
                                CvPoint2D64f *principalPoint=NULL,
                                double *pixelAspectRatio=NULL );
</pre><p><dl>
<dt>calibMatr<dd>The matrix of intrinsic parameters, e.g. computed by <a href="#decl_cvCalibrateCamera2">cvCalibrateCamera2</a>
<dt>imgWidth<dd>Image width in pixels
<dt>imgHeight<dd>Image height in pixels
<dt>apertureWidth<dd>Aperture width in realworld units (optional input parameter)
<dt>apertureHeight<dd>Aperture width in realworld units (optional input parameter)
<dt>fovx<dd>Field of view angle in x direction in degrees (optional output parameter)
<dt>fovx<dd>Field of view angle in y direction in degrees (optional output parameter)
<dt>focalLength<dd>Focal length in realworld units (optional output parameter)
<dt>principalPoint<dd>The principal point in realworld units (optional output parameter)
<dt>pixelAspectRatio<dd>The pixel aspect ratio ~ fy/fx (optional output parameter)
</dl></p><p>
The function <code>cvCalibrationMatrixValues</code> computes various useful camera (sensor/lens)
characteristics using the computed camera calibration matrix, image frame resolution in pixels
and the physical aperture size.</p>


<hr><h3><a name="decl_cvFindExtrinsicCameraParams2">FindExtrinsicCameraParams2</a></h3>
<p class="Blurb">Finds extrinsic camera parameters for particular view</p>
<pre>
void cvFindExtrinsicCameraParams2( const CvMat* object_points,
                                   const CvMat* image_points,
                                   const CvMat* intrinsic_matrix,
                                   const CvMat* distortion_coeffs,
                                   CvMat* rotation_vector,
                                   CvMat* translation_vector );
</pre><p><dl>
<dt>object_points<dd>The array of object points, 3xN or Nx3,
                     where N is the number of points in the view.
<dt>image_points<dd>The array of corresponding image points, 2xN or Nx2,
                    where N is the number of points in the view.
<dt>intrinsic_matrix<dd>The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1].
<dd><dt>distortion_coeffs<dd>The vector of distortion coefficients, <a href="#dist_coeffs_ordering">4x1, 1x4, 5x1 or 1x5</a>.
                         If it is NULL, the function assumes that all the distortion coefficients are 0's.
<dt>rotation_vector<dd>The output 3x1 or 1x3 rotation vector
                       (compact representation of a rotation matrix,
                       see <a href="#decl_cvRodrigues2">cvRodrigues2</a>).
<dt>translation_vector<dd>The output 3x1 or 1x3 translation vector.
</dl></p><p>
The function <code>cvFindExtrinsicCameraParams2</code> estimates the object pose
using the intrinsic camera parameters and a few (>=4) 2D<->3D point correspondences.
</p>


<hr><h3><a name="decl_cvStereoCalibrate">StereoCalibrate</a></h3>
<p class="Blurb">Calibrates stereo camera</p>
<pre>
void cvStereoCalibrate( const CvMat* object_points, const CvMat* image_points1,
                        const CvMat* image_points2, const CvMat* point_counts,
                        CvMat* camera_matrix1, CvMat* dist_coeffs1,
                        CvMat* camera_matrix2, CvMat* dist_coeffs2,
                        CvSize image_size, CvMat* R, CvMat* T,
                        CvMat* E=0, CvMat* F=0,
                        CvTermCriteria term_crit=cvTermCriteria(
                               CV_TERMCRIT_ITER+CV_TERMCRIT_EPS,30,1e-6),
                        int flags=CV_CALIB_FIX_INTRINSIC );
</pre><p><dl>
<dt>object_points<dd>The joint matrix of object points, 3xN or Nx3,
                     where N is the total number of points in all views.
<dt>image_points1<dd>The joint matrix of corresponding image points in the views from the 1st camera, 2xN or Nx2,
                    where N is the total number of points in all views.
<dt>image_points2<dd>The joint matrix of corresponding image points in the views from the 2nd camera, 2xN or Nx2,
                    where N is the total number of points in all views.
<dt>point_counts<dd>Vector containing numbers of points in each view,
                    1xM or Mx1, where M is the number of views.
<dt>camera_matrix1, camera_matrix2<dd>The input/output camera matrices [fx<sub>k</sub> 0 cx<sub>k</sub>; 0 fy<sub>k</sub> cy<sub>k</sub>; 0 0 1].
                  If <code>CV_CALIB_USE_INTRINSIC_GUESS</code> or
                  <code>CV_CALIB_FIX_ASPECT_RATIO</code> are specified, some or all
                  of the elements of the matrices must be initialized.
<dt>dist_coeffs1, dist_coeffs2<dd>The input/output vectors of distortion coefficients for each camera, <a href="#dist_coeffs_ordering">4x1, 1x4, 5x1 or 1x5</a>.
<dt>image_size<dd>Size of the image, used only to initialize intrinsic camera matrix.
<dt>R<dd>The rotation matrix between the 1st and the 2nd cameras' coordinate systems
<dt>T<dd>The translation vector between the cameras' coordinate systems.
<dt>E<dd>The optional output essential matrix
<dt>F<dd>The optional output fundamental matrix
<dt>term_crit<dd>Termination criteria for the iterative optimiziation algorithm.
<dt>flags<dd>Different flags, may be 0 or combination of the following values:<br>
             <code>CV_CALIB_FIX_INTRINSIC</code> - If it is set, <code>camera_matrix1,2</code>, as well as <code>dist_coeffs1,2</code> are fixed,
             so that only extrinsic parameters are optimized.<br>
             <code>CV_CALIB_USE_INTRINSIC_GUESS</code> - The flag allows the function to optimize some or all of the intrinsic parameters,
             depending on the other flags, but the initial values are provided by the user<br>
             <code>CV_CALIB_FIX_PRINCIPAL_POINT</code> - The principal points are fixed during the optimization.<br>
             <code>CV_CALIB_FIX_FOCAL_LENGTH</code> - fx<sub>k</sub> and fy<sub>k</sub> are fixed<br>
             <code>CV_CALIB_FIX_ASPECT_RATIO</code> - fy<sub>k</sub> is optimized, but the ratio fx<sub>k</sub>/fy<sub>k</sub> is fixed.<br>
             <code>CV_CALIB_SAME_FOCAL_LENGTH</code> - Enforces fx<sub>0</sub>=fx<sub>1</sub> and fy<sub>0</sub>=fy<sub>1</sub>.
             <code>CV_CALIB_ZERO_TANGENT_DIST</code> - Tangential distortion coefficients for each camera are set to zeros and fixed there.<br>
             <code>CV_CALIB_FIX_K1</code> - The 0-th distortion coefficients (k1) are fixed<br>
             <code>CV_CALIB_FIX_K2</code> - The 1-st distortion coefficients (k2) are fixed<br>
             <code>CV_CALIB_FIX_K3</code> - The 4-th distortion coefficients (k3) are fixed<br>
</dl></p><p>
The function <code>cvStereoCalibrate</code> estimates transformation between the 2 cameras making a stereo pair. If we have
a stereo camera, where the relative position and orientatation of the 2 cameras is fixed, and if we computed poses of an object relative to
the fist camera and to the second camera, (R<sub>1</sub>, T<sub>1</sub>) and (R<sub>2</sub>, T<sub>2</sub>), respectively (that can be done with
<a href="#decl_cvFindExtrinsicCameraParams2">cvFindExtrinsicCameraParams2</a>), obviously, those poses will relate to each other, i.e. given (R<sub>1</sub>, T<sub>1</sub>)
it should be possible to compute (R<sub>2</sub>, T<sub>2</sub>) - we only need to know the position and orientation of the 2nd camera
relative to the 1st camera. That's what the described function does. It computes (R, T) such that:</p>
<pre>
R<sub>2</sub>=R*R<sub>1</sub>
T<sub>2</sub>=R*T<sub>1</sub> + T,
</pre>
Optionally, it computes the essential matrix E:
<pre>
    [0 -T<sub>2</sub> T<sub>1</sub>]
E = [T<sub>2</sub> 0 -T<sub>0</sub>]*R,
    [-T<sub>1</sub> T<sub>0</sub> 0]
</pre>
where T<sub>i</sub> are components of the translation vector T:
T=[T<sub>0</sub>, T<sub>1</sub>, T<sub>2</sub>]<sup>T</sup>.
And also the function can compute the fundamental matrix F:
<pre>
F = inv(camera_matrix2)<sup>T</sup>*E*inv(camera_matrix1),
</pre>
Besides the stereo-related information, the function can also perform full calibration of each of the 2 cameras. However,
because of the high dimensionality of the parameter space and noise in the input data the function can diverge from the correct solution.
Thus, if intrinsic parameters can be estimated with high accuracy for each of the cameras individually
(e.g. using <a href="#decl_cvCalibrateCamera2">cvCalibrateCamera2</a>), it is recommended to do so and then pass
<code>CV_CALIB_FIX_INTRINSIC</code> flag to the function along with the computed intrinsic parameters. Otherwise, if all the parameters
are estimated at once, it makes sense to restrict some parameters, e.g. pass <code>CV_CALIB_SAME_FOCAL_LENGTH</code> and
<code>CV_CALIB_ZERO_TANGENT_DIST</code> flags, which are usually reasonable assumptions.


<hr><h3><a name="decl_cvStereoRectify">StereoRectify</a></h3>
<p class="Blurb">Computes rectification transform for stereo camera</p>
<pre>
void cvStereoRectify( const CvMat* camera_matrix1, const CvMat* camera_matrix2,
                      const CvMat* dist_coeffs1, const CvMat* dist_coeffs2,
                      CvSize image_size, const CvMat* R, const CvMat* T,
                      CvMat* R1, CvMat* R2, CvMat* P1, CvMat* P2,
                      CvMat* Q=0, int flags=CV_CALIB_ZERO_DISPARITY );
</pre><p><dl>
<dt>camera_matrix1, camera_matrix2<dd>The camera matrices [fx<sub>k</sub> 0 cx<sub>k</sub>; 0 fy<sub>k</sub> cy<sub>k</sub>; 0 0 1].
<dt>dist_coeffs1, dist_coeffs2<dd>The vectors of distortion coefficients for each camera, <a href="#dist_coeffs_ordering">4x1, 1x4, 5x1 or 1x5</a>.
<dt>image_size<dd>Size of the image used for stereo calibration.
<dt>R<dd>The rotation matrix between the 1st and the 2nd cameras' coordinate systems
<dt>T<dd>The translation vector between the cameras' coordinate systems.
<dt>R1, R2<dd>3x3 Rectification transforms (rotation matrices) for the first and the second cameras, respectively
<dt>P1, P2<dd>3x4 Projection matrices in the new (rectified) coordinate systems
<dt>Q<dd>The optional output disparity-to-depth mapping matrix, 4x4, see <a href="#decl_cvReprojectImageTo3D">cvReprojectImageTo3D</a>.
<dt>flags<dd>The operation flags; may be 0 or <code>CV_CALIB_ZERO_DISPARITY</code>. If the flag is set, the function makes
  the principal points of each camera have the same pixel coordinates in the rectified views. And if the flag is not set, the function can
  shift one of the image in horizontal or vertical direction (depending on the orientation of epipolar lines) in order to maximise
  the useful image area.
</dl></p><p>
The function <code>cvStereoRectify</code> computes the rotation matrices for each camera that (virtually) make both
camera image planes the same plane. Consequently, that makes all the epipolar lines parallel and thus simplifies
the dense stereo correspondence problem. On input the function takes the matrices computed by <a href="#decl_cvStereoCalibrate">cvStereoCalibrate</a>
and on output it gives 2 rotation matrices and also 2 projection matrices in the new coordinates.
The function is normally called after <a href="#decl_cvSteroCalibrate">cvStereoCalibrate</a> that computes
both camera matrices, the distortion coefficients, <code>R</code> and <code>T</code>.
The 2 cases are distinguished by the function:
<ol>
  <li>horizontal stereo, when 1st and 2nd camera views are shifted relative to each other mainly along the x axis (with possible small vertical shift).
  Then in the rectified images the corresponding epipolar lines in left and right cameras will be horizontal and have the same y-coordinate.
  P1 and P2 will look as:
  <pre>
     [f 0 cx1 0]
  P1=[0 f cy  0]
     [0 0  1  0]

     [f 0 cx2 Tx*f]
  P2=[0 f cy   0 ],
     [0 0  1   0 ]
  </pre>
  where Tx is horizontal shift between the cameras and cx1=cx2 if <code>CV_CALIB_ZERO_DISPARITY</code> is set.
  <li>vertical stereo, when 1st and 2nd camera views are shifted relative to each other mainly in vertical direction
  (and probably a bit in the horizontal direction too). Then the epipolar lines in the rectified images will be vertical and have the same x coordinate.
  P2 and P2 will look as:
  <pre>
     [f 0 cx  0]
  P1=[0 f cy1 0]
     [0 0  1  0]
  
     [f 0 cx   0  ]
  P2=[0 f cy2 Ty*f],
     [0 0  1   0  ]
  </pre>
  where Ty is vertical shift between the cameras and cy1=cy2 if <code>CV_CALIB_ZERO_DISPARITY</code> is set.
</ol>
As you can see, the first 3 columns of P1 and P2 will effectively be the new "rectified" camera matrices.
</p>


<hr><h3><a name="decl_cvStereoRectifyUncalibrated">StereoRectifyUncalibrated</a></h3>
<p class="Blurb">Computes rectification transform for uncalibrated stereo camera</p>
<pre>
void cvStereoRectifyUncalibrated( const CvMat* points1, const CvMat* points2,
                                  const CvMat* F, CvSize image_size,
                                  CvMat* H1, CvMat* H2,
                                  double threshold=5 );
</pre><p><dl>
<dt>points1, points2<dd>The 2 arrays of corresponding 2D points.
<dt>F<dd>Fundamental matrix. It can be computed using the same set of point pairs <code>points1</code> and <code>points2</code>
 using <a href="#decl_cvFindFundamentalMat">cvFindFundamentalMat</a>
<dt>image_size<dd>Size of the image.
<dt>H1, H2<dd>The rectification homography matrices for the first and for the second images.
<dt>threshold<dd>Optional threshold used to filter out the outliers. If the parameter is greater than zero,
then all the point pairs that do not comply the epipolar geometry well enough
(that is, the points for which <code>fabs(points2[i]<sup>T</sup>*F*points1[i])>threshold</code>)
are rejected prior to computing the homographies.
</dl></p><p>
The function <code>cvStereoRectifyUncalibrated</code> computes the rectification transformations
without knowing intrinsic parameters of the cameras and their relative position in space,
hence the suffix "Uncalibrated". Another related difference from <a href="#decl_cvStereoRectify">cvStereoRectify</a>
is that the function outputs not the rectification transformations in the object (3D) space, but
the planar perspective transformations, encoded by the homography matrices <code>H1</code> and <code>H2</code>.
The function implements the following algorithm <a href="#paper_hartley">[Hartley99]</a>.
</p><p>
Note that while the algorithm does not need to know the intrinsic parameters of the cameras,
it heavily depends on the epipolar geometry. Therefore, if the camera lenses have significant
distortion, it would better be corrected before computing the fundamental matrix
and calling this function.
For example, distortion coefficients can be estimated for each head of stereo camera separately by using
<a href="#decl_cvCalibrateCamera2">cvCalibrateCamera2</a> and then the images can be corrected using
<a href="#decl_cvUndistort2">cvUndistort2</a>.
</p>

<hr><h3><a name="decl_cvRodrigues2">Rodrigues2</a></h3>
<p class="Blurb">Converts rotation matrix to rotation vector or vice versa</p>
<pre>
int  cvRodrigues2( const CvMat* src, CvMat* dst, CvMat* jacobian=0 );
</pre><p><dl>
<dt>src<dd>The input rotation vector (3x1 or 1x3) or rotation matrix (3x3).
<dt>dst<dd>The output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively.
<dt>jacobian<dd>Optional output Jacobian matrix, 3x9 or 9x3 - partial derivatives of
                the output array components w.r.t the input array components.
</dl></p><p>
The function <code>cvRodrigues2</code> converts a rotation vector to rotation matrix or
vice versa. Rotation vector is a compact representation of rotation matrix.
Direction of the rotation vector is the rotation axis and the length of the vector is the rotation
angle around the axis.
The rotation matrix <code>R</code>, corresponding to the rotation vector <code>r</code>,
is computed as following:
<pre>
theta &lt;- norm(r)
r &lt;- r/theta
                                                   [0 -r<sub>z</sub> r<sub>y</sub>]
R = cos(theta)*I + (1-cos(theta))*rr<sup>T</sup> + sin(theta)*[r<sub>z</sub> 0 -r<sub>x</sub>]
                                                   [r<sub>y</sub> r<sub>x</sub> 0]
</pre>

Inverse transformation can also be done easily as

<pre>

[0 -r<sub>z</sub> r<sub>y</sub>]
sin(theta)*[r<sub>z</sub> 0 -r<sub>x</sub>] = (R - R<sup>T</sup>)/2
[r<sub>y</sub> r<sub>x</sub> 0]

</pre>

Rotation vector is a convenient representation of a rotation matrix as a matrix with only 3 degrees of freedom.
The representation is used in the global optimization procedures inside
<a href="#decl_cvFindExtrinsicCameraParams2">cvFindExtrinsicCameraParams2</a> and
<a href="#decl_cvCalibrateCamera2">cvCalibrateCamera2</a>.
</p>


<hr><h3><a name="decl_cvUndistort2">Undistort2</a></h3>
<p class="Blurb">Transforms image to compensate lens distortion</p>
<pre>
void cvUndistort2( const CvArr* src, CvArr* dst,
                   const CvMat* intrinsic_matrix,
                   const CvMat* distortion_coeffs );
</pre><p><dl>
<dt>src<dd>The input (distorted) image.
<dt>dst<dd>The output (corrected) image.
<dt>intrinsic_matrix<dd>The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1].
<dd><dt>distortion_coeffs<dd>The vector of distortion coefficients, <a href="#dist_coeffs_ordering">4x1, 1x4, 5x1 or 1x5</a>.
</dl></p><p>
The function <code>cvUndistort2</code> transforms the image to compensate radial and tangential lens distortion.
The camera matrix and distortion parameters can be determined using
<a href="#decl_cvCalibrateCamera2">cvCalibrateCamera2</a>.
For every pixel in the output image the function computes coordinates of the corresponding location in the input
image using the formulae in the section beginning. Then, the pixel value is computed using bilinear interpolation.
If the resolution of images is different from what was used at the calibration stage,
<code>fx, fy, cx</code> and <code>cy</code> need to be adjusted appropriately, while
the distortion coefficients remain the same.
</p><p>In the undistorted image the principal point will be at the image center.</p>


<hr><h3><a name="decl_cvInitUndistortMap">InitUndistortMap</a></h3>
<p class="Blurb">Computes undistortion map</p>
<pre>
void cvInitUndistortMap( const CvMat* camera_matrix,
                         const CvMat* distortion_coeffs,
                         CvArr* mapx, CvArr* mapy );
</pre><p><dl>
<dt>camera_matrix<dd>The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1].
<dd><dt>distortion_coeffs<dd>The vector of distortion coefficients, <a href="#dist_coeffs_ordering">4x1, 1x4, 5x1 or 1x5</a>.
<dt>mapx<dd>The output array of x-coordinates of the map.
<dt>mapy<dd>The output array of y-coordinates of the map.
</dl></p><p>
The function <code>cvInitUndistortMap</code> pre-computes the undistortion map
- coordinates of the corresponding pixel in the distorted image for every pixel in the corrected image.
Then, the map (together with input and output images) can be passed
to <a href="#decl_cvRemap">cvRemap</a> function.</p><p>In the undistorted image the principal point
will be at the image center.</p>


<hr><h3><a name="decl_cvInitUndistortRectifyMap">InitUndistortRectifyMap</a></h3>
<p class="Blurb">Computes undistortion+rectification transformation map a head of stereo camera</p>
<pre>
void cvInitUndistortRectifyMap( const CvMat* camera_matrix,
                                const CvMat* dist_coeffs,
                                const CvMat* R,
                                const CvMat* new_camera_matrix,
                                CvArr* mapx, CvArr* mapy );
</pre><p><dl>
<dt>camera_matrix<dd>The camera matrix A=[fx 0 cx; 0 fy cy; 0 0 1].
<dt>distortion_coeffs<dd>The vector of distortion coefficients, <a href="#dist_coeffs_ordering">4x1, 1x4, 5x1 or 1x5</a>.
<dt>R<dd>The rectification transformation in object space (3x3 matrix). <code>R1</code> or <code>R2</code>, computed
by <a href="#decl_cvStereoRectify">cvStereoRectify</a> can be passed here.
If the parameter is NULL, the identity matrix is used.
<dt>new_camera_matrix<dd>The new camera matrix A'=[fx' 0 cx'; 0 fy' cy'; 0 0 1].
<dt>mapx<dd>The output array of x-coordinates of the map.
<dt>mapy<dd>The output array of y-coordinates of the map.
</dl></p><p>
The function <code>cvInitUndistortRectifyMap</code> is an extended version of
<a href="#decl_cvInitUndistortMap">cvInitUndistortMap</a>. That is, in addition to the correction of lens distortion,
the function can also apply arbitrary perspective transformation R and finally it
can scale and shift the image according to the new camera matrix. That is, in pseudo code the
transformation can be represented as:</p>
<pre>
// (u,v) is the input point,
// camera_matrix=[fx 0 cx; 0 fy cy; 0 0 1]
// new_camera_matrix=[fx' 0 cx'; 0 fy' cy'; 0 0 1]
x = (u - cx')/fx'
y = (v - cy')/fy'
[X,Y,W]<sup>T</sup> = R<sup>-1</sup>*[x y 1]<sup>T</sup>
x' = X/W, y' = Y/W
x" = x'*(1 + k<sub>1</sub>r<sup>2</sup> + k<sub>2</sub>r<sup>4</sup> + k<sub>3</sub>r<sup>6</sup>) + 2*p<sub>1</sub>x'*y' + p<sub>2</sub>(r<sup>2</sup>+2*x'<sup>2</sup>)
y" = y'*(1 + k<sub>1</sub>r<sup>2</sup> + k<sub>2</sub>r<sup>4</sup> + k<sub>3</sub>r<sup>6</sup>) + p<sub>1</sub>(r<sup>2</sup>+2*y'<sup>2</sup>) + 2*p<sub>2</sub>*x'*y'
mapx(u,v) = x"*fx + cx
mapy(u,v) = y"*fy + cy
</pre>
Note that the code above does the reverse transformation from the target image (i.e. the ideal one,
after undistortion and rectification) to the original "raw" image straight from the camera. That's for bilinear
interpolation purposes and in order to fill the whole destination image w/o gaps using
<a href="#decl_cvRemap">cvRemap</a>.
<p>Normally, this function is called [twice, once for each head of stereo camera] after <a href="#decl_cvStereoRectify">cvStereoRectify</a>.
But it is also possible to compute the rectification transformations directly from the fundamental matrix, e.g.
by using <a href="#decl_cvStereoRectifyUncalibrated">cvStereoRectifyUncalibrated</a>. Such functions
work with pixels and produce homographies as rectification transformations, not rotation matrices
<code>R</code> in 3D space. In this case, the <code>R</code> can be computed from the homography matrix
<code>H</code> as
<pre>
R = inv(camera_matrix)*H*camera_matrix
</pre>
</p>


<hr><h3><a name="decl_cvUndistortPoints">UndistortPoints</a></h3>
<p class="Blurb">Computes the ideal point coordinates from the observed point coordinates</p>
<pre>
void cvUndistortPoints( const CvMat* src, CvMat* dst,
                        const CvMat* camera_matrix,
                        const CvMat* dist_coeffs,
                        const CvMat* R=NULL,
                        const CvMat* P=NULL);
</pre><p><dl>
<dt>src<dd>The observed point coordinates.
<dt>dst<dt>The ideal point coordinates, after undistortion and reverse perspective transformation.
<dt>camera_matrix<dd>The camera matrix A=[fx 0 cx; 0 fy cy; 0 0 1].
<dt>distortion_coeffs<dd>The vector of distortion coefficients, <a href="#dist_coeffs_ordering">4x1, 1x4, 5x1 or 1x5</a>.
<dt>R<dd>The rectification transformation in object space (3x3 matrix). <code>R1</code> or <code>R2</code>, computed
by <a href="#decl_cvStereoRectify">cvStereoRectify</a> can be passed here.
If the parameter is NULL, the identity matrix is used.
<dt>P<dd>The new camera matrix (3x3) or the new projection matrix (3x4). <code>P1</code> or <code>P2</code>, computed
by <a href="#decl_cvStereoRectify">cvStereoRectify</a> can be passed here.
If the parameter is NULL, the identity matrix is used.
</dl></p><p>
The function <code>cvUndistortPoints</code> is similar to
<a href="#decl_cvInitUndistortRectifyMap">cvInitUndistortRectifyMap</a> and is opposite to it at the same time.
The functions are similar in that they both are used to correct lens distortion and to perform
the optional perspective (rectification) transformation. They are opposite because the
function <a href="#decl_cvInitUndistortRectifyMap">cvInitUndistortRectifyMap</a> does actually perform
the reverse transformation in order to initialize the maps properly, while this function
does the forward transformation. That is, in pseudo-code it can be expressed as:</p>
<pre>
// (u,v) is the input point, (u', v') is the output point
// camera_matrix=[fx 0 cx; 0 fy cy; 0 0 1]
// P=[fx' 0 cx' tx; 0 fy' cy' ty; 0 0 1 tz]
x" = (u - cx)/fx
y" = (v - cy)/fy
(x',y') = undistort(x",y",dist_coeffs)
[X,Y,W]<sup>T</sup> = R*[x' y' 1]<sup>T</sup>
x = X/W, y = Y/W
u' = x*fx' + cx'
v' = y*fy' + cy',
</pre>
where undistort() is approximate iterative algorithm that estimates the normalized original point coordinates
out of the normalized distorted point coordinates
("normalized" means that the coordinates do not depend on the camera matrix).
</p>
<p>The function can be used as for stereo cameras, as well as for individual cameras when R=NULL.
</p>


<hr><h3><a name="decl_cvFindChessboardCorners">FindChessboardCorners</a></h3>
<p class="Blurb">Finds positions of internal corners of the chessboard</p>
<pre>
int cvFindChessboardCorners( const void* image, CvSize pattern_size,
                             CvPoint2D32f* corners, int* corner_count=NULL,
                             int flags=CV_CALIB_CB_ADAPTIVE_THRESH );
</pre><p><dl>
<dt>image<dd>Source chessboard view; it must be 8-bit grayscale or color image.
<dt>pattern_size<dd>The number of inner corners per chessboard row and column.
<dt>corners<dd>The output array of corners detected.
<dt>corner_count<dd>The output corner counter. If it is not NULL, the function stores
there the number of corners found.
<dt>flags<dd>Various operation flags, can be 0 or a combination of the following values:<br>
                     <code>CV_CALIB_CB_ADAPTIVE_THRESH</code> - use adaptive thresholding to convert the
                     image to black-n-white, rather than a fixed threshold level (computed from the average image brightness).<br>
                     <code>CV_CALIB_CB_NORMALIZE_IMAGE</code> - normalize the image using
                     <a href="#decl_cvNormalizeHist">cvNormalizeHist</a> before applying fixed or adaptive thresholding.<br>
                     <code>CV_CALIB_CB_FILTER_QUADS</code> - use additional criteria (like contour area, perimeter,
                     square-like shape) to filter out false quads that are extracted at the contour retrieval stage.<br>
</dl></p><p>
The function <code>cvFindChessboardCorners</code> attempts to determine whether the input
image is a view of the chessboard pattern and locate internal chessboard
corners. The function returns non-zero value if all the corners have been found
and they have been placed in a certain order (row by row, left to right in every
row), otherwise, if the function fails to find all the corners or reorder them,
it returns 0. For example, a regular chessboard has 8 x 8 squares and 7
x 7 internal corners, that is, points, where the black squares touch each other.
The coordinates detected are approximate, and to determine their position more accurately,
the user may use the function <a href="#decl_cvFindCornerSubPix">cvFindCornerSubPix</a>.
</p>


<hr><h3><a name="decl_cvDrawChessBoardCorners">DrawChessBoardCorners</a></h3>
<p class="Blurb">Renders the detected chessboard corners</p>
<pre>
void cvDrawChessboardCorners( CvArr* image, CvSize pattern_size,
                              CvPoint2D32f* corners, int count,
                              int pattern_was_found );
</pre><p><dl>
<dt>image<dd>The destination image; it must be 8-bit color image.
<dt>pattern_size<dd>The number of inner corners per chessboard row and column.
<dt>corners<dd>The array of corners detected.
<dt>count<dd>The number of corners.
<dt>pattern_was_found<dd>Indicates whether the complete board was found (&ne;0) or not (=0). One may just
                     pass the return value <a href="#decl_cvFindChessboardCorners">cvFindChessboardCorners</a> here.
</dl></p><p>
The function <code>cvDrawChessboardCorners</code> draws the individual chessboard corners detected (as red circles)
in case if the board was not found (<code>pattern_was_found</code>=0) or the colored corners connected with lines
when the board was found (<code>pattern_was_found</code>&ne;0).
</p>


<hr><h2><a name="cv_3d_pose">Pose Estimation</a></h2>

<hr><h3><a name="decl_cvCreatePOSITObject">CreatePOSITObject</a></h3>
<p class="Blurb">Initializes structure containing object information</p>
<pre>
CvPOSITObject* cvCreatePOSITObject( CvPoint3D32f* points, int point_count );
</pre><p><dl>
<dt>points<dd>Pointer to the points of the 3D object model.
<dt>point_count<dd>Number of object points.
</dl></p><p>
The function <code>cvCreatePOSITObject</code> allocates memory for the object structure and
computes the object inverse matrix.
<p>
The pre-processed object data is stored in the structure <a href="#decl_CvPOSITObject">CvPOSITObject</a>, internal
for OpenCV, which means that the user cannot directly access the structure data.
The user may only create this structure and pass its pointer to the function.
</p>
<p>
Object is defined as a set of points given in a coordinate system. The function
<a href="#decl_cvPOSIT">cvPOSIT</a> computes a vector that begins at a camera-related coordinate system center
and ends at the <code>points[0]</code> of the object.
</p>
Once the work with a given object is finished, the function
<a href="#decl_cvReleasePOSITObject">cvReleasePOSITObject</a>
must be called to free memory.

</p><hr><h3><a name="decl_cvPOSIT">POSIT</a></h3>
<p class="Blurb">Implements POSIT algorithm</p>
<pre>
void cvPOSIT( CvPOSITObject* posit_object, CvPoint2D32f* image_points, double focal_length,
              CvTermCriteria criteria, CvMatr32f rotation_matrix, CvVect32f translation_vector );
</pre><p><dl>
<dt>posit_object<dd>Pointer to the object structure.
<dt>image_points<dd>Pointer to the object points projections on the 2D image plane.
<dt>focal_length<dd>Focal length of the camera used.
<dt>criteria<dd>Termination criteria of the iterative POSIT algorithm.
<dt>rotation_matrix<dd>Matrix of rotations.
<dt>translation_vector<dd>Translation vector.
</dl></p><p>
The function <code>cvPOSIT</code> implements POSIT algorithm. Image coordinates are given in a
camera-related coordinate system. The focal length may be retrieved using camera
calibration functions. At every iteration of the algorithm new perspective
projection of estimated pose is computed.
<p>
Difference norm between two projections is the maximal distance between
corresponding points. The parameter <code>criteria.epsilon</code> serves to stop the
algorithm if the difference is small.
</p>

</p><hr><h3><a name="decl_cvReleasePOSITObject">ReleasePOSITObject</a></h3>
<p class="Blurb">Deallocates 3D object structure</p>
<pre>
void cvReleasePOSITObject( CvPOSITObject** posit_object );
</pre><p><dl>
<dt>posit_object<dd>Double pointer to <code>CvPOSIT</code> structure.
</dl></p><p>
The function <code>cvReleasePOSITObject</code> releases memory previously allocated by the
function <a href="#decl_cvCreatePOSITObject">cvCreatePOSITObject</a>.
</p>

<hr><h3><a name="decl_cvCalcImageHomography">CalcImageHomography</a></h3>
<p class="Blurb">Calculates homography matrix for oblong planar object (e.g. arm)</p>
<pre>
void cvCalcImageHomography( float* line, CvPoint3D32f* center,
                            float* intrinsic, float* homography );
</pre><p><dl>
<dt>line<dd>the main object axis direction (vector (dx,dy,dz)).
<dt>center<dd>object center ((cx,cy,cz)).
<dt>intrinsic<dd>intrinsic camera parameters (3x3 matrix).
<dt>homography<dd>output homography matrix (3x3).
</dl></p><p>
The function <code>cvCalcImageHomography</code> calculates the homography matrix for the initial
image transformation from image plane to the plane, defined by 3D oblong object line (See
<u><font color=blue>Figure 6-10</font></u> in OpenCV Guide 3D Reconstruction Chapter).
</p>

<!-- by Valery Mosyagin -->

<hr><h2><a name="cv_3d_epipolar">Epipolar Geometry, Stereo Correspondence</a></h2>

<hr><h3><a name="decl_cvFindFundamentalMat">FindFundamentalMat</a></h3>
<p class="Blurb">Calculates fundamental matrix from corresponding points in two images</p>
<pre>
int cvFindFundamentalMat( const CvMat* points1,
                          const CvMat* points2,
                          CvMat* fundamental_matrix,
                          int    method=CV_FM_RANSAC,
                          double param1=3.,
                          double param2=0.99,
                          CvMat* status=NULL);
</pre>
<p>
<dl>
<dt>points1<dd>Array of the first image points of <code>2xN, Nx2, 3xN</code> or <code>Nx3</code> size
               (where <code>N</code> is number of points).
               Multi-channel <code>1xN</code> or <code>Nx1</code> array is also acceptable.
               The point coordinates should be floating-point (single or double precision)
<dt>points2<dd>Array of the second image points of the same size and format as <code>points1</code>
<dt>fundamental_matrix <dd>The output fundamental matrix or matrices. The size should be 3x3 or 9x3
                           (7-point method may return up to 3 matrices).
<dt>method<dd>Method for computing the fundamental matrix
          <dd>CV_FM_7POINT - for 7-point algorithm. N == 7
          <dd>CV_FM_8POINT - for 8-point algorithm. N >= 8
          <dd>CV_FM_RANSAC - for RANSAC  algorithm. N > 8
          <dd>CV_FM_LMEDS  - for LMedS   algorithm. N > 8
<dt>param1<dd>The parameter is used for RANSAC method only.
            It is the maximum distance from point to epipolar line in pixels,
            beyond which the point is considered an outlier and is not used
            for computing the final fundamental matrix.
            Usually it is set somewhere from 1 to 3.
<dt>param2 <dd>The parameter is used for RANSAC or LMedS methods only.
            It denotes the desirable level of confidence of the fundamental matrix estimate.
<dt>status<dd>The optional output array of N elements,
            every element of which is set to 0 for outliers
            and to 1 for the "inliers", i.e. points that comply
            well with the estimated epipolar geometry.
            The array is computed only in RANSAC and LMedS methods.
            For other methods it is set to all 1&#146;s.</p>
</dl></p>

<p>
The epipolar geometry is described by the following equation:
<pre>p<sub>2</sub><sup>T</sup>*F*p<sub>1</sub>=0,</pre>
</p>

<p>where <code>F</code> is fundamental matrix, <code>p<sub>1</sub></code> and <code>p<sub>2</sub></code> are corresponding
points in the first and the second images, respectively.
</p>

<p>
The function <code>cvFindFundamentalMat</code> calculates fundamental matrix using one of four
methods listed above and returns the number of fundamental matrices found (1 or 3) and 0,
if no matrix is found.
</p>

<p>
The calculated fundamental matrix may be passed further to <code>cvComputeCorrespondEpilines</code>
that finds epipolar lines corresponding to the specified points.</p>

<h4>Example. Estimation of fundamental matrix using RANSAC algorithm</h4>
<pre>
int point_count = 100;
CvMat* points1;
CvMat* points2;
CvMat* status;
CvMat* fundamental_matrix;

points1 = cvCreateMat(1,point_count,CV_32FC2);
points2 = cvCreateMat(1,point_count,CV_32FC2);
status = cvCreateMat(1,point_count,CV_8UC1);

/* Fill the points here ... */
for( i = 0; i &lt; point_count; i++ )
{
    points1->data.db[i*2] = &lt;x<sub>1,i</sub>&gt;;
    points1->data.db[i*2+1] = &lt;y<sub>1,i</sub>&gt;;
    points2->data.db[i*2] = &lt;x<sub>2,i</sub>&gt;;
    points2->data.db[i*2+1] = &lt;y<sub>2,i</sub>&gt;;
}

fundamental_matrix = cvCreateMat(3,3,CV_32FC1);
int fm_count = cvFindFundamentalMat( points1,points2,fundamental_matrix,
                                     CV_FM_RANSAC,3,0.99,status );
</pre>


<hr>
<h3><a name="decl_cvComputeCorrespondEpilines">ComputeCorrespondEpilines</a></h3>
<p class="Blurb">For points in one image of stereo pair computes the corresponding epilines in the other image</p>

<pre>
void cvComputeCorrespondEpilines( const CvMat* points,
                                  int which_image,
                                  const CvMat* fundamental_matrix,
                                  CvMat* correspondent_lines);
</pre>
<p><dl>

<dt>points<dd>The input points. <code>2xN, Nx2, 3xN</code> or <code>Nx3</code> array (where <code>N</code> number of points).
              Multi-channel <code>1xN</code> or <code>Nx1</code> array is also acceptable.
<dt>which_image<dd>Index of the image (1 or 2) that contains the <code>points</code>
<dt>fundamental_matrix <dd>Fundamental matrix
<dt>correspondent_lines<dd>Computed epilines, <code>3xN</code> or <code>Nx3</code> array

</dl></p>

<p>
For every point in one of the two images of stereo-pair the function
<code>cvComputeCorrespondEpilines</code> finds equation of a line that contains
the corresponding point (i.e. projection of the same 3D point) in the other image.
Each line is encoded by a vector of 3 elements <code>l=[a,b,c]<sup>T</sup></code>, so that:
<pre>

l<sup>T</sup>*[x, y, 1]<sup>T</sup>=0, or
a*x + b*y + c = 0

</pre>

From the fundamental matrix definition (see <a href="#decl_cvFindFundamentalMatrix">cvFindFundamentalMatrix</a>
discussion), line <code>l<sub>2</sub></code> for a point <code>p<sub>1</sub></code>
in the first image (<code>which_image</code>=1) can be computed as:

<pre>l<sub>2</sub>=F*p<sub>1</sub></pre>

and the line <code>l<sub>1</sub></code> for a point <code>p<sub>2</sub></code>
in the second image (<code>which_image</code>=1) can be computed as:

<pre>l<sub>1</sub>=F<sup>T</sup>*p<sub>2</sub></pre>

<p>
Line coefficients are defined up to a scale.
They are normalized (<code>a<sup>2</sup>+b<sup>2</sup>=1</code>)
are stored into <code>correspondent_lines</code>.
</p>


<hr>
<h3><a name="decl_cvConvertPointsHomogeneous">ConvertPointsHomogeneous</a></h3>
<p class="Blurb">Convert points to/from homogeneous coordinates</p>

<pre>
void cvConvertPointsHomogeneous( const CvMat* src, CvMat* dst );
</pre>
<p><dl>

<dt>src<dd>The input point array, <code>2xN, Nx2, 3xN, Nx3, 4xN or Nx4</code>
           (where <code>N</code> is the number of points).
           Multi-channel <code>1xN</code> or <code>Nx1</code> array is also acceptable.
<dt>dst<dd>The output point array, must contain the same number of points as the input;
           The dimensionality must be the same, 1 less or 1 more than the input, and
           also within 2..4.
</dl></p>

<p>
The function <code>cvConvertPointsHomogeneous</code> converts 2D or 3D points
from/to homogeneous coordinates, or simply copies or transposes the array.
In case if the input array dimensionality is larger than the output,
each point coordinates are divided by the last coordinate:
<pre>
(x,y[,z],w) -> (x',y'[,z']):

x' = x/w
y' = y/w
z' = z/w (if output is 3D)
</pre>

If the output array dimensionality is larger, an extra 1 is appended to each point.
<pre>
(x,y[,z]) -> (x,y[,z],1)
</pre>

Otherwise, the input array is simply copied (with optional transposition) to the output.
<b>Note</b> that, because the function accepts a large variety of array layouts, it
may report an error when input/output array dimensionality is ambiguous.
It is always safe to use the function with number of points <code>N</code>&gt;=5, or
to use multi-channel <code>Nx1</code> or <code>1xN</code> arrays.


<hr><h3><a name="decl_CvStereoBMState">CvStereoBMState</a></h3>
<p class="Blurb">The structure for block matching stereo correspondence algorithm</p>
<pre>
typedef struct CvStereoBMState
{
    //pre filters (normalize input images):
    int       preFilterType; // 0 for now
    int       preFilterSize; // ~5x5..21x21
    int       preFilterCap;  // up to ~31
    //correspondence using Sum of Absolute Difference (SAD):
    int       SADWindowSize; // Could be 5x5..21x21
    int       minDisparity;  // minimum disparity (=0)
    int       numberOfDisparities; // maximum disparity - minimum disparity
    //post filters (knock out bad matches):
    int       textureThreshold; // areas with no texture are ignored
    float     uniquenessRatio;// filter out pixels if there are other close matches
                              // with different disparity
    int       speckleWindowSize;// Disparity variation window (not used)
    int       speckleRange; // Acceptable range of variation in window (not used)
    // internal buffers, do not modify (!)
    CvMat* preFilteredImg0;
    CvMat* preFilteredImg1;
    CvMat* slidingSumBuf;
}
CvStereoBMState;
</pre>
<p>
The block matching stereo correspondence algorithm, by Kurt Konolige, is very fast
one-pass stereo matching algorithm that uses sliding sums of absolute differences
between pixels in the left image and the pixels in the right image,
shifted by some varying amount of pixels (from <code>minDisparity</code> to
<code>minDisparity+numberOfDisparities</code>). On a pair of images WxH the algorithm
computes disparity in <code>O(W*H*numberOfDisparities)</code> time. In order to improve
quality and reability of the disparity map, the algorithm includes pre-filtering and
post-filtering procedures.</p>
<p>Note that the algorithm searches for the corresponding blocks in x direction only.
It means that the supplied stereo pair should be rectified. Vertical stereo layout is not directly
supported, but in such a case the images could be transposed by user.</p>

<hr><h3><a name="decl_cvCreateStereoBMState">CreateStereoBMState</a></h3>
<p class="Blurb">Creates block matching stereo correspondence structure</p>
<pre>
#define CV_STEREO_BM_BASIC 0
#define CV_STEREO_BM_FISH_EYE 1
#define CV_STEREO_BM_NARROW 2

CvStereoBMState* cvCreateStereoBMState( int preset=CV_STEREO_BM_BASIC,
                                        int numberOfDisparities=0 );
</pre>
<p>
<dl>
<dt>preset<dd>ID of one of the pre-defined parameter sets.
              Any of the parameters can be overridden after creating the structure.
<dt>numberOfDisparities<dd>The number of disparities. If the parameter is 0, it is taken from the preset,
              otherwise the supplied value overrides the one from preset.
</dl></p>
<p>
The function cvCreateStereoBMState creates the stereo correspondence structure and initializes it.
It is possible to override any of the parameters at any time between the calls to
<a href="#decl_cvFindStereoCorrespondeceBM">cvFindStereoCorrespondenceBM</a>.
</p>


<hr><h3><a name="decl_cvReleaseStereoBMState">ReleaseStereoBMState</a></h3>
<p class="Blurb">Releases block matching stereo correspondence structure</p>
<pre>
void cvReleaseStereoBMState( CvStereoBMState** state );
</pre>
<p>
<dl>
<dt>state<dd>Double pointer to the released structure
</dl></p>
<p>
The function cvReleaseStereoBMState releases the stereo correspondence structure and
all the associated internal buffers.
</p>


<hr><h3><a name="decl_cvFindStereoCorrespondenceBM">FindStereoCorrespondenceBM</a></h3>
<p class="Blurb">Computes the disparity map using block matching algorithm</p>
<pre>
void cvFindStereoCorrespondenceBM( const CvArr* left, const CvArr* right,
                                   CvArr* disparity, CvStereoBMState* state );
</pre>
<p>
<dl>
<dt>left<dd>The left single-channel, 8-bit image.
<dt>right<dd>The right image of the same size and the same type.
<dt>disparity<dd>The output single-channel 16-bit signed disparity map of the same size as input images.
                 Its elements will be the computed disparities, multiplied by 16 and rounded to integer's.
<dt>state<dd>Stereo correspondence structure.
</dl></p>
<p>
The function cvFindStereoCorrespondenceBM computes disparity map for
the input rectified stereo pair.
</p>


<hr><h3><a name="decl_CvStereoGCState">CvStereoGCState</a></h3>
<p class="Blurb">The structure for graph cuts-based stereo correspondence algorithm</p>
<pre>
typedef struct CvStereoGCState
{
    int Ithreshold; // threshold for piece-wise linear data cost function (5 by default)
    int interactionRadius; // radius for smoothness cost function (1 by default; means Potts model)
    float K, lambda, lambda1, lambda2; // parameters for the cost function
                                       // (usually computed adaptively from the input data)
    int occlusionCost; // 10000 by default
    int minDisparity; // 0 by default; see CvStereoBMState
    int numberOfDisparities; // defined by user; see CvStereoBMState
    int maxIters; // number of iterations; defined by user.

    // internal buffers
    CvMat* left;
    CvMat* right;
    CvMat* dispLeft;
    CvMat* dispRight;
    CvMat* ptrLeft;
    CvMat* ptrRight;
    CvMat* vtxBuf;
    CvMat* edgeBuf;
}
CvStereoGCState;
</pre>
<p>
The graph cuts stereo correspondence algorithm,
described in <a href="#paper_kolmogorov03">[Kolmogorov03]</a> (as <b>KZ1</b>), is non-realtime
stereo correpsondence algorithm that usually gives very accurate depth map with well-defined
object boundaries. The algorithm represents stereo problem as a sequence of binary
optimization problems, each of those is solved using maximum graph flow algorithm.
The state structure above should not be allocated and initialized manually; instead, use
<a href="#decl_cvCreateStereoGCState">cvCreateStereoGCState</a> and then override
necessary parameters if needed.</p>

<hr><h3><a name="decl_cvCreateStereoGCState">CreateStereoGCState</a></h3>
<p class="Blurb">Creates the state of graph cut-based stereo correspondence algorithm</p>
<pre>
CvStereoGCState* cvCreateStereoGCState( int numberOfDisparities,
                                        int maxIters );
</pre>
<p>
<dl>
<dt>numberOfDisparities<dd>The number of disparities. The disparity search range will be
   <code>state->minDisparity &le; disparity &lt; state->minDisparity + state->numberOfDisparities</code>
<dt>maxIters<dd>Maximum number of iterations. On each iteration all possible (or reasonable)
   alpha-expansions are tried. The algorithm may terminate earlier if it could not find
   an alpha-expansion that decreases the overall cost function value. See
   <a href="#paper_kolmogorov">[Kolmogorov03]</a>
   for details.
</dl></p>
<p>
The function cvCreateStereoGCState creates the stereo correspondence structure and initializes it.
It is possible to override any of the parameters at any time between the calls to
<a href="#decl_cvFindStereoCorrespondenceGC">cvFindStereoCorrespondenceGC</a>.
</p>


<hr><h3><a name="decl_cvReleaseStereoGCState">ReleaseStereoGCState</a></h3>
<p class="Blurb">Releases the state structure of the graph cut-based stereo correspondence algorithm</p>
<pre>
void cvReleaseStereoGCState( CvStereoGCState** state );
</pre>
<p>
<dl>
<dt>state<dd>Double pointer to the released structure
</dl></p>
<p>
The function cvReleaseStereoGCState releases the stereo correspondence structure and
all the associated internal buffers.
</p>


<hr><h3><a name="decl_cvFindStereoCorrespondenceGC">FindStereoCorrespondenceGC</a></h3>
<p class="Blurb">Computes the disparity map using graph cut-based algorithm</p>
<pre>
void cvFindStereoCorrespondenceGC( const CvArr* left, const CvArr* right,
                                   CvArr* dispLeft, CvArr* dispRight,
                                   CvStereoGCState* state,
                                   int useDisparityGuess CV_DEFAULT(0) );
</pre>
<p>
<dl>
<dt>left<dd>The left single-channel, 8-bit image.
<dt>right<dd>The right image of the same size and the same type.
<dt>dispLeft<dd>The optional output single-channel 16-bit signed left disparity map of the same size as input images.
<dt>dispRight<dd>The optional output single-channel 16-bit signed right disparity map of the same size as input images.
<dt>state<dd>Stereo correspondence structure.
<dt>useDisparityGuess<dd>If the parameter is not zero, the algorithm will start with pre-defined
             disparity maps. Both dispLeft and dispRight should be valid disparity maps. Otherwise,
             the function starts with blank disparity maps (all pixels are marked as occlusions).
</dl></p>
<p>
The function cvFindStereoCorrespondenceGC computes disparity maps for
the input rectified stereo pair. Note that the left disparity image will contain values in the following range:
<pre>
-state->numberOfDisparities-state->minDisparity &lt; dispLeft(x,y) &le; -state->minDisparity,
or
dispLeft(x,y) == CV_STEREO_GC_OCCLUSION,
</pre>
where as for the right disparity image the following will be true:
<pre>
state->minDisparity &le; dispRight(x,y) &lt; state->minDisparity+state->numberOfDisparities,
or
dispRight(x,y) == CV_STEREO_GC_OCCLUSION,
</pre>
that is, the range for the left disparity image will be inversed, and the pixels for
which no good match has been found, will be marked as occlusions.
</p>
<p>Here is how the function can be called:</p>
<pre>
// image_left and image_right are the input 8-bit single-channel images
// from the left and the right cameras, respectively
CvSize size = cvGetSize(image_left);
CvMat* disparity_left = cvCreateMat( size.height, size.width, CV_16S );
CvMat* disparity_right = cvCreateMat( size.height, size.width, CV_16S );
CvStereoGCState* state = cvCreateStereoGCState( 16, 2 );
cvFindStereoCorrespondenceGC( image_left, image_right,
    disparity_left, disparity_right, state, 0 );
cvReleaseStereoGCState( &state );
// now process the computed disparity images as you want ...
</pre>
and this is the output left disparity image computed from the well-known
Tsukuba stereo pair and multiplied by -16 (because the values in the left
disparity images are usually negative):
<pre>
CvMat* disparity_left_visual = cvCreateMat( size.height, size.width, CV_8U );
cvConvertScale( disparity_left, disparity_left_visual, -16 );
cvSave( "disparity.png", disparity_left_visual );
</pre>
<p><img align="center" src="pics/disparity.png"></p>

<hr><h3><a name="decl_cvReprojectImageTo3D">ReprojectImageTo3D</a></h3>
<p class="Blurb">Reprojects disparity image to 3D space</p>
<pre>
void cvReprojectImageTo3D( const CvArr* disparity,
                           CvArr* _3dImage, const CvMat* Q );
</pre>
<p>
<dl>
<dt>disparity<dd>Disparity map.
<dt>_3dImage<dd>3-channel, 16-bit integer or 32-bit floating-point image - the output map of 3D points.
<dt>Q<dd>The reprojection 4x4 matrix.
</dl></p>
<p>
The function cvReprojectImageTo3D transforms 1-channel disparity map to 3-channel image, a 3D surface.
That is, for each pixel <code>(x,y)</code> and the corresponding disparity
<code>d=disparity(x,y)</code> it computes:
<pre>
[X Y Z W]<sup>T</sup> = Q*[x y d 1]<sup>T</sup>
_3dImage(x,y) = (X/W, Y/W, Z/W)
</pre>
<p>The matrix Q can be arbitrary, e.g. the one, computed by
<a href="#decl_cvStereoRectify">cvStereoRectify</a>.
To reproject a sparse set of points {(x,y,d),...} to 3D space, use
<a href="opencvref_cxcore.htm#decl_cvPerspectiveTransform">cvPerspectiveTransform</a>.

<hr><h1><a name="cv_func_index">Alphabetical List of Functions</a></h1>

<hr><h3>2</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cv2DRotationMatrix">2DRotationMatrix</a></td>
<td width="25%%"></td>
<td width="25%%"></td>
</tr>
</table>
<hr><h3>A</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvAcc">Acc</a></td>
<td width="25%"><a href="#decl_cvApproxChains">ApproxChains</a></td>
<td width="25%"><a href="#decl_cvArcLength">ArcLength</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvAdaptiveThreshold">AdaptiveThreshold</a></td>
<td width="25%"><a href="#decl_cvApproxPoly">ApproxPoly</a></td>
<td width="25%%"></td>
</tr>
</table>
<hr><h3>B</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvBoundingRect">BoundingRect</a></td>
<td width="25%"><a href="#decl_cvBoxPoints">BoxPoints</a></td>
<td width="25%%"></td>
</tr>
</table>
<hr><h3>C</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvCalcBackProject">CalcBackProject</a></td>
<td width="25%"><a href="#decl_cvCalibrationMatrixValues">CalibrationMatrixValues</a></td>
<td width="25%"><a href="#decl_cvCopyHist">CopyHist</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvCalcBackProjectPatch">CalcBackProjectPatch</a></td>
<td width="25%"><a href="#decl_cvCamShift">CamShift</a></td>
<td width="25%"><a href="#decl_cvCopyMakeBorder">CopyMakeBorder</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvCalcEMD2">CalcEMD2</a></td>
<td width="25%"><a href="#decl_cvCanny">Canny</a></td>
<td width="25%"><a href="#decl_cvCornerEigenValsAndVecs">CornerEigenValsAndVecs</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvCalcGlobalOrientation">CalcGlobalOrientation</a></td>
<td width="25%"><a href="#decl_cvCheckContourConvexity">CheckContourConvexity</a></td>
<td width="25%"><a href="#decl_cvCornerHarris">CornerHarris</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvCalcHist">CalcHist</a></td>
<td width="25%"><a href="#decl_cvClearHist">ClearHist</a></td>
<td width="25%"><a href="#decl_cvCornerMinEigenVal">CornerMinEigenVal</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvCalcImageHomography">CalcImageHomography</a></td>
<td width="25%"><a href="#decl_cvClearSubdivVoronoi2D">ClearSubdivVoronoi2D</a></td>
<td width="25%"><a href="#decl_cvCreateConDensation">CreateConDensation</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvCalcMotionGradient">CalcMotionGradient</a></td>
<td width="25%"><a href="#decl_cvCompareHist">CompareHist</a></td>
<td width="25%"><a href="#decl_cvCreateContourTree">CreateContourTree</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvCalcOpticalFlowBM">CalcOpticalFlowBM</a></td>
<td width="25%"><a href="#decl_cvComputeCorrespondEpilines">ComputeCorrespondEpilines</a></td>
<td width="25%"><a href="#decl_cvCreateFeatureTree">CreateFeatureTree</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvCalcOpticalFlowHS">CalcOpticalFlowHS</a></td>
<td width="25%"><a href="#decl_cvConDensInitSampleSet">ConDensInitSampleSet</a></td>
<td width="25%"><a href="#decl_cvCreateHist">CreateHist</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvCalcOpticalFlowLK">CalcOpticalFlowLK</a></td>
<td width="25%"><a href="#decl_cvConDensUpdateByTime">ConDensUpdateByTime</a></td>
<td width="25%"><a href="#decl_cvCreateKalman">CreateKalman</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvCalcOpticalFlowPyrLK">CalcOpticalFlowPyrLK</a></td>
<td width="25%"><a href="#decl_cvContourArea">ContourArea</a></td>
<td width="25%"><a href="#decl_cvCreatePOSITObject">CreatePOSITObject</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvCalcPGH">CalcPGH</a></td>
<td width="25%"><a href="#decl_cvContourFromContourTree">ContourFromContourTree</a></td>
<td width="25%"><a href="#decl_cvCreateStateBM">CreateStateBM</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvCalcProbDensity">CalcProbDensity</a></td>
<td width="25%"><a href="#decl_cvConvertPointsHomogeneous">ConvertPointsHomogeneous</a></td>
<td width="25%"><a href="#decl_cvCreateStructuringElementEx">CreateStructuringElementEx</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvCalcSubdivVoronoi2D">CalcSubdivVoronoi2D</a></td>
<td width="25%"><a href="#decl_cvConvexHull2">ConvexHull2</a></td>
<td width="25%"><a href="#decl_cvCreateSubdivDelaunay2D">CreateSubdivDelaunay2D</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvCalibrateCamera2">CalibrateCamera2</a></td>
<td width="25%"><a href="#decl_cvConvexityDefects">ConvexityDefects</a></td>
<td width="25%"><a href="#decl_cvCvtColor">CvtColor</a></td>
</tr>
</table>
<hr><h3>D</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvDilate">Dilate</a></td>
<td width="25%"><a href="#decl_cvDistTransform">DistTransform</a></td>
<td width="25%"><a href="#decl_cvDrawChessBoardCorners">DrawChessBoardCorners</a></td>
</tr>
</table>
<hr><h3>E</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvEndFindContours">EndFindContours</a></td>
<td width="25%"><a href="#decl_cvEqualizeHist">EqualizeHist</a></td>
<td width="25%"><a href="#decl_cvErode">Erode</a></td>
</tr>
</table>
<hr><h3>F</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvFilter2D">Filter2D</a></td>
<td width="25%"><a href="#decl_cvFindFeatures">FindFeatures</a></td>
<td width="25%"><a href="#decl_cvFindNextContour">FindNextContour</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvFindChessboardCorners">FindChessboardCorners</a></td>
<td width="25%"><a href="#decl_cvFindFeaturesBoxed">FindFeaturesBoxed</a></td>
<td width="25%"><a href="#decl_cvFindStereoCorrespondenceBM">FindStereoCorrespondenceBM</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvFindContours">FindContours</a></td>
<td width="25%"><a href="#decl_cvFindFundamentalMat">FindFundamentalMat</a></td>
<td width="25%"><a href="#decl_cvFitEllipse">FitEllipse</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvFindCornerSubPix">FindCornerSubPix</a></td>
<td width="25%"><a href="#decl_cvFindHomography">FindHomography</a></td>
<td width="25%"><a href="#decl_cvFitLine2D">FitLine2D</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvFindExtrinsicCameraParams2">FindExtrinsicCameraParams2</a></td>
<td width="25%"><a href="#decl_cvFindNearestPoint2D">FindNearestPoint2D</a></td>
<td width="25%"><a href="#decl_cvFloodFill">FloodFill</a></td>
</tr>
</table>
<hr><h3>G</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvGetAffineTransform">GetAffineTransform</a></td>
<td width="25%"><a href="#decl_cvGetMinMaxHistValue">GetMinMaxHistValue</a></td>
<td width="25%"><a href="#decl_cvGetRectSubPix">GetRectSubPix</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvGetCentralMoment">GetCentralMoment</a></td>
<td width="25%"><a href="#decl_cvGetNormalizedCentralMoment">GetNormalizedCentralMoment</a></td>
<td width="25%"><a href="#decl_cvGetSpatialMoment">GetSpatialMoment</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvGetHistValue_*D">GetHistValue_*D</a></td>
<td width="25%"><a href="#decl_cvGetPerspectiveTransform">GetPerspectiveTransform</a></td>
<td width="25%"><a href="#decl_cvGoodFeaturesToTrack">GoodFeaturesToTrack</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvGetHuMoments">GetHuMoments</a></td>
<td width="25%"><a href="#decl_cvGetQuadrangleSubPix">GetQuadrangleSubPix</a></td>
<td width="25%%"></td>
</tr>
</table>
<hr><h3>H</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvHaarDetectObjects">HaarDetectObjects</a></td>
<td width="25%"><a href="#decl_cvHoughCircles">HoughCircles</a></td>
<td width="25%"><a href="#decl_cvHoughLines2">HoughLines2</a></td>
</tr>
</table>
<hr><h3>I</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvInitUndistortMap">InitUndistortMap</a></td>
<td width="25%"><a href="#decl_cvInpaint">Inpaint</a></td>
<td width="25%%"></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvInitUndistortRectifyMap">InitUndistortRectifyMap</a></td>
<td width="25%"><a href="#decl_cvIntegral">Integral</a></td>
<td width="25%%"></td>
</tr>
</table>
<hr><h3>K</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvKalmanCorrect">KalmanCorrect</a></td>
<td width="25%"><a href="#decl_cvKalmanPredict">KalmanPredict</a></td>
<td width="25%%"></td>
</tr>
</table>
<hr><h3>L</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvLaplace">Laplace</a></td>
<td width="25%"><a href="#decl_cvLoadHaarClassifierCascade">LoadHaarClassifierCascade</a></td>
<td width="25%"><a href="#decl_cvLogPolar">LogPolar</a></td>
</tr>
</table>
<hr><h3>M</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvMakeHistHeaderForArray">MakeHistHeaderForArray</a></td>
<td width="25%"><a href="#decl_cvMaxRect">MaxRect</a></td>
<td width="25%"><a href="#decl_cvMoments">Moments</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvMatchContourTrees">MatchContourTrees</a></td>
<td width="25%"><a href="#decl_cvMeanShift">MeanShift</a></td>
<td width="25%"><a href="#decl_cvMorphologyEx">MorphologyEx</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvMatchShapes">MatchShapes</a></td>
<td width="25%"><a href="#decl_cvMinAreaRect2">MinAreaRect2</a></td>
<td width="25%"><a href="#decl_cvMultiplyAcc">MultiplyAcc</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvMatchTemplate">MatchTemplate</a></td>
<td width="25%"><a href="#decl_cvMinEnclosingCircle">MinEnclosingCircle</a></td>
<td width="25%%"></td>
</tr>
</table>
<hr><h3>N</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvNormalizeHist">NormalizeHist</a></td>
<td width="25%%"></td>
<td width="25%%"></td>
</tr>
</table>
<hr><h3>P</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvPOSIT">POSIT</a></td>
<td width="25%"><a href="#decl_cvPreCornerDetect">PreCornerDetect</a></td>
<td width="25%"><a href="#decl_cvPyrMeanShiftFiltering">PyrMeanShiftFiltering</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvPointPolygonTest">PointPolygonTest</a></td>
<td width="25%"><a href="#decl_cvProjectPoints2">ProjectPoints2</a></td>
<td width="25%"><a href="#decl_cvPyrSegmentation">PyrSegmentation</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvPointSeqFromMat">PointSeqFromMat</a></td>
<td width="25%"><a href="#decl_cvPyrDown">PyrDown</a></td>
<td width="25%"><a href="#decl_cvPyrUp">PyrUp</a></td>
</tr>
</table>
<hr><h3>Q</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvQueryHistValue_*D">QueryHistValue_*D</a></td>
<td width="25%%"></td>
<td width="25%%"></td>
</tr>
</table>
<hr><h3>R</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvReadChainPoint">ReadChainPoint</a></td>
<td width="25%"><a href="#decl_cvReleaseKalman">ReleaseKalman</a></td>
<td width="25%"><a href="#decl_cvReprojectImageTo3D">ReprojectImageTo3D</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvReleaseConDensation">ReleaseConDensation</a></td>
<td width="25%"><a href="#decl_cvReleasePOSITObject">ReleasePOSITObject</a></td>
<td width="25%"><a href="#decl_cvResize">Resize</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvReleaseFeatureTree">ReleaseFeatureTree</a></td>
<td width="25%"><a href="#decl_cvReleaseStateBM">ReleaseStateBM</a></td>
<td width="25%"><a href="#decl_cvRodrigues2">Rodrigues2</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvReleaseHaarClassifierCascade">ReleaseHaarClassifierCascade</a></td>
<td width="25%"><a href="#decl_cvReleaseStructuringElement">ReleaseStructuringElement</a></td>
<td width="25%"><a href="#decl_cvRunHaarClassifierCascade">RunHaarClassifierCascade</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvReleaseHist">ReleaseHist</a></td>
<td width="25%"><a href="#decl_cvRemap">Remap</a></td>
<td width="25%"><a href="#decl_cvRunningAvg">RunningAvg</a></td>
</tr>
</table>
<hr><h3>S</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvSampleLine">SampleLine</a></td>
<td width="25%"><a href="#decl_cvSquareAcc">SquareAcc</a></td>
<td width="25%"><a href="#decl_cvSubdiv2DEdgeOrg">Subdiv2DEdgeOrg</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvSegmentMotion">SegmentMotion</a></td>
<td width="25%"><a href="#decl_cvStartFindContours">StartFindContours</a></td>
<td width="25%"><a href="#decl_cvSubdiv2DGetEdge">Subdiv2DGetEdge</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvSetHistBinRanges">SetHistBinRanges</a></td>
<td width="25%"><a href="#decl_cvStartReadChainPoints">StartReadChainPoints</a></td>
<td width="25%"><a href="#decl_cvSubdiv2DLocate">Subdiv2DLocate</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvSetImagesForHaarClassifierCascade">SetImagesForHaarClassifierCascade</a></td>
<td width="25%"><a href="#decl_cvStereoCalibrate">StereoCalibrate</a></td>
<td width="25%"><a href="#decl_cvSubdiv2DRotateEdge">Subdiv2DRotateEdge</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvSmooth">Smooth</a></td>
<td width="25%"><a href="#decl_cvStereoRectify">StereoRectify</a></td>
<td width="25%"><a href="#decl_cvSubdivDelaunay2DInsert">SubdivDelaunay2DInsert</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvSnakeImage">SnakeImage</a></td>
<td width="25%"><a href="#decl_cvStereoRectifyUncalibrated">StereoRectifyUncalibrated</a></td>
<td width="25%"><a href="#decl_cvSubstituteContour">SubstituteContour</a></td>
</tr>
<tr>
<td width="25%"><a href="#decl_cvSobel">Sobel</a></td>
<td width="25%"><a href="#decl_cvSubdiv2DEdgeDst">Subdiv2DEdgeDst</a></td>
<td width="25%%"></td>
</tr>
</table>
<hr><h3>T</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvThreshHist">ThreshHist</a></td>
<td width="25%"><a href="#decl_cvThreshold">Threshold</a></td>
<td width="25%%"></td>
</tr>
</table>
<hr><h3>U</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvUndistort2">Undistort2</a></td>
<td width="25%"><a href="#decl_cvUndistortPoints">UndistortPoints</a></td>
<td width="25%"><a href="#decl_cvUpdateMotionHistory">UpdateMotionHistory</a></td>
</tr>
</table>
<hr><h3>W</h3>
<table width="100%">
<tr>
<td width="25%"><a href="#decl_cvWarpAffine">WarpAffine</a></td>
<td width="25%"><a href="#decl_cvWarpPerspective">WarpPerspective</a></td>
<td width="25%"><a href="#decl_cvWatershed">Watershed</a></td>
</tr>
</table>

<hr><h1><a name="cv_bib">Bibliography</a></h1>
<p>
This bibliography provides a list of publications that were might be useful to
the OpenCV users. This list is not complete; it serves only
as a starting point.
</p>
<ol>

<li><a name="paper_agrawal08"><b>[Agrawal08]</b>
Motilal Agrawal, Kurt Konolige, and Morten Rufus Blas
"CenSurE: Center Surround Extremas for Realtime Feature Detection and Matching".
ECCV 2008, Part IV, LNCS 5305, pp. 102-115, 2008.
</a>

<li><a name="paper_bay06"><b>[Bay06]</b>
Herbert Bay, Tinne Tuytelaars and Luc Van Gool
"SURF: Speeded Up Robust Features", Proceedings of the 9th European Conference
on Computer Vision, Springer LNCS volume 3951, part 1, pp 404--417, 2006.
</a>

<li><a name="paper_beis97"><b>[Beis97]</b>
J.S. Beis and D.G. Lowe, "Shape indexing using approximate nearest-neighbor search in highdimensional spaces".
In Proc. IEEE Conf. Comp. Vision Patt. Recog., pages 1000--1006, 1997.
</a>

<li><a name="paper_borgefors86"><b>[Borgefors86]</b>
Gunilla Borgefors, "Distance Transformations in Digital Images". Computer Vision, Graphics and Image Processing 34, 344-371 (1986).
</a>

<li><a name="paper_bouguet00"><b>[Bouguet00]</b>
Jean-Yves Bouguet. Pyramidal Implementation of the Lucas Kanade Feature Tracker.</a><br>
The paper is included into OpenCV distribution (<a href="../papers/algo_tracking.pdf">algo_tracking.pdf</a>)

<li><a name="paper_bouguet04"><b>[Bouguet04]</b>
Jean-Yves Bouguet. The Camera Calibration Toolbox for Matlab.
<a href="http://www.vision.caltech.edu/bouguetj/calib_doc/">http://www.vision.caltech.edu/bouguetj/calib_doc/</a>

<li><a name="paper_bradski98"><b>[Bradski98]</b>
G.R. Bradski. Computer vision face tracking as a component of a perceptual
user interface. In Workshop on Applications of Computer Vision, pages 214219,
Princeton, NJ, Oct. 1998.</a><br>
Updated version can be found at
<a href="http://www.intel.com/technology/itj/q21998/articles/art_2.htm">
http://www.intel.com/technology/itj/q21998/articles/art_2.htm</a>.<br>
Also, it is included into OpenCV distribution (<a href="../papers/camshift.pdf">camshift.pdf</a>)

<li><b>[Bradski00]</b> G. Bradski and J. Davis. Motion Segmentation and Pose Recognition
with Motion History Gradients. IEEE WACV'00, 2000.

<li><b>[Burt81]</b> P. J. Burt, T. H. Hong, A. Rosenfeld. Segmentation and Estimation of
Image Region Properties Through Cooperative Hierarchical Computation. IEEE Tran.
On SMC, Vol. 11, N.12, 1981, pp. 802-809.

<li><b>[Canny86]</b> J. Canny. A Computational Approach to Edge Detection, IEEE Trans. on
Pattern Analysis and Machine Intelligence, 8(6), pp. 679-698 (1986).

<li><b>[Davis97]</b> J. Davis and Bobick. The Representation and Recognition of Action
Using Temporal Templates. MIT Media Lab Technical Report 402, 1997.

<li><b>[DeMenthon92]</b> Daniel F. DeMenthon and Larry S. Davis. Model-Based Object Pose in
25 Lines of Code. In Proceedings of ECCV '92, pp. 335-343, 1992.

<li><a name="paper_felzenszwalb04"><b>[Felzenszwalb04]</b>
Pedro F. Felzenszwalb and Daniel P. Huttenlocher.
Distance Transforms of Sampled Functions.
Cornell Computing and Information Science TR2004-1963.</a>

<li><b>[Fitzgibbon95]</b> Andrew W. Fitzgibbon, R.B.Fisher. A Buyer&#146;s Guide to Conic
Fitting. Proc.5th British Machine Vision Conference, Birmingham, pp. 513-522,
1995.

<li><a name="paper_ford98"><b>[Ford98]</b> Adrian Ford, Alan Roberts. Colour Space Conversions.</a>
<a href="http://www.poynton.com/PDFs/coloureq.pdf">http://www.poynton.com/PDFs/coloureq.pdf</a>

<li><a name="paper_hartley99"><b>[Hartley99]</b> Richard I. Hartley.
Theory and practice of projective rectification. Int J Computer Vision 35(2): 116

<li><a name="paper_horn81"><b>[Horn81]</b>
Berthold K.P. Horn and Brian G. Schunck. Determining Optical Flow.
Artificial Intelligence, 17, pp. 185-203, 1981.
</a>

<li><b>[Hu62]</b> M. Hu. Visual Pattern Recognition by Moment Invariants, IRE Transactions
on Information Theory, 8:2, pp. 179-187, 1962.

<li><a name="paper_iivarinen97"><b>[Iivarinen97]</b>
Jukka Iivarinen, Markus Peura, Jaakko Srel, and Ari Visa.
Comparison of Combined Shape Descriptors for Irregular Objects, 8th British Machine Vision Conference, BMVC'97.</a><br>
<a href="http://www.cis.hut.fi/research/IA/paper/publications/bmvc97/bmvc97.html">
http://www.cis.hut.fi/research/IA/paper/publications/bmvc97/bmvc97.html</a>

<li><b>[Jahne97]</b> B. Jahne. Digital Image Processing. Springer, New York, 1997.

<li><a name="paper_lucas81"></a><b>[Lucas81]</b>
Lucas, B., and Kanade, T. An Iterative Image
Registration Technique with an Application to Stereo
Vision, Proc. of 7th International Joint Conference on
Artificial Intelligence (IJCAI), pp. 674-679.
</a>

<li><b>[Kass88]</b> M. Kass, A. Witkin, and D. Terzopoulos. Snakes: Active Contour Models,
International Journal of Computer Vision, pp. 321-331, 1988.

<li><a name ="paper_kolmogorov03"></a><b>[Kolmogorov03]</b>V. Kolmogorov. Graph Based Algorithms for Scene Reconstruction
from Two or More Views. PhD thesis, Cornell University, September 2003.

<li><a name="paper_lienhart02"><b>[Lienhart02]</b>
Rainer Lienhart and Jochen Maydt.
An Extended Set of Haar-like Features for Rapid Object Detection.
IEEE ICIP 2002, Vol. 1, pp. 900-903, Sep. 2002.</a><br>
This paper, as well as the extended technical report, can be retrieved at
<a href="http://www.lienhart.de/Publications/publications.html">http://www.lienhart.de/Publications/publications.html</a>


<li><b>[Matas98]</b> J.Matas, C.Galambos, J.Kittler. Progressive Probabilistic Hough
Transform. British Machine Vision Conference, 1998.

<li><a name="paper_meyer92"><b>[Meyer92]</b>
Meyer, F. (1992). Color image segmentation. In Proceedings of the International Conference on Image Processing and its Applications, pages 303--306.</a>

<li><b>[Rosenfeld73]</b> A. Rosenfeld and E. Johnston. Angle Detection on Digital Curves.
IEEE Trans. Computers, 22:875-878, 1973.

<li><b>[RubnerJan98]</b> Y. Rubner. C. Tomasi, L.J. Guibas. Metrics for Distributions with
Applications to Image Databases. Proceedings of the 1998 IEEE International
Conference on Computer Vision, Bombay, India, January 1998, pp. 59-66.

<li><a name="paper_rubnersept98"><b>[RubnerSept98]</b>
Y. Rubner. C. Tomasi, L.J. Guibas. The Earth Mover&#146;s Distance as a
Metric for Image Retrieval. Technical Report STAN-CS-TN-98-86,
Department of Computer Science, Stanford University, September
1998.
</a>

<li><b>[RubnerOct98]</b> Y. Rubner. C. Tomasi. Texture Metrics. Proceeding of the IEEE
International Conference on Systems, Man, and Cybernetics, San-Diego, CA,
October 1998, pp. 4601-4607.
<a href="http://robotics.stanford.edu/~rubner/publications.html">
http://robotics.stanford.edu/~rubner/publications.html</a>

<li><b>[Serra82]</b> J. Serra. Image Analysis and Mathematical Morphology. Academic Press,
1982.

<li><b>[Schiele00]</b> Bernt Schiele and James L. Crowley. Recognition without
Correspondence Using Multidimensional Receptive Field Histograms. In
International Journal of Computer Vision 36 (1), pp. 31-50, January 2000.

<li><b>[Suzuki85]</b> S. Suzuki, K. Abe. Topological Structural Analysis of Digital Binary
Images by Border Following. CVGIP, v.30, n.1. 1985, pp. 32-46.

<li><b>[Teh89]</b> C.H. Teh, R.T. Chin. On the Detection of Dominant Points on Digital
Curves. - IEEE Tr. PAMI, 1989, v.11, No.8, p. 859-872.

<li><a name="paper_telea04"><b>[Telea04]</b>
A. Telea, "An image inpainting technique based on the fast marching method,"
J. Graphics Tools, vol.9, no.1, pp.2536, 2004.<br>

<li><b>[Trucco98]</b> Emanuele Trucco, Alessandro Verri. Introductory Techniques for 3-D
Computer Vision. Prentice Hall, Inc., 1998.

<li><a name="paper_viola01"><b>[Viola01]</b>
Paul Viola and Michael J. Jones.
Rapid Object Detection using a Boosted Cascade of Simple Features. IEEE CVPR, 2001.</a><br>
The paper is available online at
<a href="http://www.ai.mit.edu/people/viola/">http://www.ai.mit.edu/people/viola/</a>


<li><a name="paper_welch95"><b>[Welch95]</b>
Greg Welch, Gary Bishop. An Introduction To the Kalman Filter.
Technical Report TR95-041, University of North Carolina at Chapel Hill, 1995.</a><br>
Online version is available at <a href="http://www.cs.unc.edu/~welch/kalman/kalmanIntro.html">
http://www.cs.unc.edu/~welch/kalman/kalmanIntro.html</a>

<li><b>[Williams92]</b> D. J. Williams and M. Shah. A Fast Algorithm for Active Contours
and Curvature Estimation. CVGIP: Image Understanding, Vol. 55, No. 1, pp. 14-26,
Jan., 1992. http://www.cs.ucf.edu/~vision/papers/shah/92/WIS92A.pdf.

<li><a name="paper_yuen03"><b>[Yuen03]</b>
H.K. Yuen, J. Princen, J. Illingworth and J. Kittler.
Comparative study of Hough Transform methods for circle finding.<br>
<a href="http://www.sciencedirect.com/science/article/B6V09-48TCV4N-5Y/2/91f551d124777f7a4cf7b18325235673">
http://www.sciencedirect.com/science/article/B6V09-48TCV4N-5Y/2/91f551d124777f7a4cf7b18325235673</a>

<li><b>[Yuille89]</b> A.Y.Yuille, D.S.Cohen, and P.W.Hallinan. Feature Extraction from
Faces Using Deformable Templates in CVPR, pp. 104-109, 1989.

<li><b>[Zhang96]</b> Z. Zhang. Parameter Estimation Techniques: A Tutorial with Application
to Conic Fitting, Image and Vision Computing Journal, 1996.

<li><b>[Zhang99]</b> Z. Zhang. Flexible Camera Calibration By Viewing a Plane From Unknown
Orientations. International Conference on Computer Vision (ICCV'99), Corfu,
Greece, pages 666-673, September 1999.

<li><b>[Zhang00]</b> Z. Zhang. A Flexible New Technique for Camera Calibration. IEEE
Transactions on Pattern Analysis and Machine Intelligence, 22(11):1330-1334,
2000.
</ol>

</body>
</html>

